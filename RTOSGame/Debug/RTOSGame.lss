
RTOSGame.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000066d4  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000005a  00800060  000066d4  00006768  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000660  008000ba  008000ba  000067c2  2**0
                  ALLOC
  3 .stab         000097f8  00000000  00000000  000067c4  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00004b57  00000000  00000000  0000ffbc  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000140  00000000  00000000  00014b13  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 00000170  00000000  00000000  00014c53  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00001c49  00000000  00000000  00014dc3  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00000eeb  00000000  00000000  00016a0c  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000dad  00000000  00000000  000178f7  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000160  00000000  00000000  000186a4  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    0000028d  00000000  00000000  00018804  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    000007ce  00000000  00000000  00018a91  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000050  00000000  00000000  0001925f  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 ea 16 	jmp	0x2dd4	; 0x2dd4 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e4 ed       	ldi	r30, 0xD4	; 212
      68:	f6 e6       	ldi	r31, 0x66	; 102
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	aa 3b       	cpi	r26, 0xBA	; 186
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	17 e0       	ldi	r17, 0x07	; 7
      78:	aa eb       	ldi	r26, 0xBA	; 186
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	aa 31       	cpi	r26, 0x1A	; 26
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 5f 12 	call	0x24be	; 0x24be <main>
      8a:	0c 94 68 33 	jmp	0x66d0	; 0x66d0 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <__fixunssfsi>:
      92:	ef 92       	push	r14
      94:	ff 92       	push	r15
      96:	0f 93       	push	r16
      98:	1f 93       	push	r17
      9a:	7b 01       	movw	r14, r22
      9c:	8c 01       	movw	r16, r24
      9e:	20 e0       	ldi	r18, 0x00	; 0
      a0:	30 e0       	ldi	r19, 0x00	; 0
      a2:	40 e0       	ldi	r20, 0x00	; 0
      a4:	5f e4       	ldi	r21, 0x4F	; 79
      a6:	0e 94 49 03 	call	0x692	; 0x692 <__gesf2>
      aa:	88 23       	and	r24, r24
      ac:	8c f0       	brlt	.+34     	; 0xd0 <__fixunssfsi+0x3e>
      ae:	c8 01       	movw	r24, r16
      b0:	b7 01       	movw	r22, r14
      b2:	20 e0       	ldi	r18, 0x00	; 0
      b4:	30 e0       	ldi	r19, 0x00	; 0
      b6:	40 e0       	ldi	r20, 0x00	; 0
      b8:	5f e4       	ldi	r21, 0x4F	; 79
      ba:	0e 94 c1 01 	call	0x382	; 0x382 <__subsf3>
      be:	0e 94 a9 03 	call	0x752	; 0x752 <__fixsfsi>
      c2:	9b 01       	movw	r18, r22
      c4:	ac 01       	movw	r20, r24
      c6:	20 50       	subi	r18, 0x00	; 0
      c8:	30 40       	sbci	r19, 0x00	; 0
      ca:	40 40       	sbci	r20, 0x00	; 0
      cc:	50 48       	sbci	r21, 0x80	; 128
      ce:	06 c0       	rjmp	.+12     	; 0xdc <__fixunssfsi+0x4a>
      d0:	c8 01       	movw	r24, r16
      d2:	b7 01       	movw	r22, r14
      d4:	0e 94 a9 03 	call	0x752	; 0x752 <__fixsfsi>
      d8:	9b 01       	movw	r18, r22
      da:	ac 01       	movw	r20, r24
      dc:	b9 01       	movw	r22, r18
      de:	ca 01       	movw	r24, r20
      e0:	1f 91       	pop	r17
      e2:	0f 91       	pop	r16
      e4:	ff 90       	pop	r15
      e6:	ef 90       	pop	r14
      e8:	08 95       	ret

000000ea <_fpadd_parts>:
      ea:	a0 e0       	ldi	r26, 0x00	; 0
      ec:	b0 e0       	ldi	r27, 0x00	; 0
      ee:	eb e7       	ldi	r30, 0x7B	; 123
      f0:	f0 e0       	ldi	r31, 0x00	; 0
      f2:	0c 94 dc 32 	jmp	0x65b8	; 0x65b8 <__prologue_saves__>
      f6:	dc 01       	movw	r26, r24
      f8:	2b 01       	movw	r4, r22
      fa:	fa 01       	movw	r30, r20
      fc:	9c 91       	ld	r25, X
      fe:	92 30       	cpi	r25, 0x02	; 2
     100:	08 f4       	brcc	.+2      	; 0x104 <_fpadd_parts+0x1a>
     102:	39 c1       	rjmp	.+626    	; 0x376 <_fpadd_parts+0x28c>
     104:	eb 01       	movw	r28, r22
     106:	88 81       	ld	r24, Y
     108:	82 30       	cpi	r24, 0x02	; 2
     10a:	08 f4       	brcc	.+2      	; 0x10e <_fpadd_parts+0x24>
     10c:	33 c1       	rjmp	.+614    	; 0x374 <_fpadd_parts+0x28a>
     10e:	94 30       	cpi	r25, 0x04	; 4
     110:	69 f4       	brne	.+26     	; 0x12c <_fpadd_parts+0x42>
     112:	84 30       	cpi	r24, 0x04	; 4
     114:	09 f0       	breq	.+2      	; 0x118 <_fpadd_parts+0x2e>
     116:	2f c1       	rjmp	.+606    	; 0x376 <_fpadd_parts+0x28c>
     118:	11 96       	adiw	r26, 0x01	; 1
     11a:	9c 91       	ld	r25, X
     11c:	11 97       	sbiw	r26, 0x01	; 1
     11e:	89 81       	ldd	r24, Y+1	; 0x01
     120:	98 17       	cp	r25, r24
     122:	09 f4       	brne	.+2      	; 0x126 <_fpadd_parts+0x3c>
     124:	28 c1       	rjmp	.+592    	; 0x376 <_fpadd_parts+0x28c>
     126:	a1 eb       	ldi	r26, 0xB1	; 177
     128:	b0 e0       	ldi	r27, 0x00	; 0
     12a:	25 c1       	rjmp	.+586    	; 0x376 <_fpadd_parts+0x28c>
     12c:	84 30       	cpi	r24, 0x04	; 4
     12e:	09 f4       	brne	.+2      	; 0x132 <_fpadd_parts+0x48>
     130:	21 c1       	rjmp	.+578    	; 0x374 <_fpadd_parts+0x28a>
     132:	82 30       	cpi	r24, 0x02	; 2
     134:	a9 f4       	brne	.+42     	; 0x160 <_fpadd_parts+0x76>
     136:	92 30       	cpi	r25, 0x02	; 2
     138:	09 f0       	breq	.+2      	; 0x13c <_fpadd_parts+0x52>
     13a:	1d c1       	rjmp	.+570    	; 0x376 <_fpadd_parts+0x28c>
     13c:	9a 01       	movw	r18, r20
     13e:	ad 01       	movw	r20, r26
     140:	88 e0       	ldi	r24, 0x08	; 8
     142:	ea 01       	movw	r28, r20
     144:	09 90       	ld	r0, Y+
     146:	ae 01       	movw	r20, r28
     148:	e9 01       	movw	r28, r18
     14a:	09 92       	st	Y+, r0
     14c:	9e 01       	movw	r18, r28
     14e:	81 50       	subi	r24, 0x01	; 1
     150:	c1 f7       	brne	.-16     	; 0x142 <_fpadd_parts+0x58>
     152:	e2 01       	movw	r28, r4
     154:	89 81       	ldd	r24, Y+1	; 0x01
     156:	11 96       	adiw	r26, 0x01	; 1
     158:	9c 91       	ld	r25, X
     15a:	89 23       	and	r24, r25
     15c:	81 83       	std	Z+1, r24	; 0x01
     15e:	08 c1       	rjmp	.+528    	; 0x370 <_fpadd_parts+0x286>
     160:	92 30       	cpi	r25, 0x02	; 2
     162:	09 f4       	brne	.+2      	; 0x166 <_fpadd_parts+0x7c>
     164:	07 c1       	rjmp	.+526    	; 0x374 <_fpadd_parts+0x28a>
     166:	12 96       	adiw	r26, 0x02	; 2
     168:	2d 90       	ld	r2, X+
     16a:	3c 90       	ld	r3, X
     16c:	13 97       	sbiw	r26, 0x03	; 3
     16e:	eb 01       	movw	r28, r22
     170:	8a 81       	ldd	r24, Y+2	; 0x02
     172:	9b 81       	ldd	r25, Y+3	; 0x03
     174:	14 96       	adiw	r26, 0x04	; 4
     176:	ad 90       	ld	r10, X+
     178:	bd 90       	ld	r11, X+
     17a:	cd 90       	ld	r12, X+
     17c:	dc 90       	ld	r13, X
     17e:	17 97       	sbiw	r26, 0x07	; 7
     180:	ec 80       	ldd	r14, Y+4	; 0x04
     182:	fd 80       	ldd	r15, Y+5	; 0x05
     184:	0e 81       	ldd	r16, Y+6	; 0x06
     186:	1f 81       	ldd	r17, Y+7	; 0x07
     188:	91 01       	movw	r18, r2
     18a:	28 1b       	sub	r18, r24
     18c:	39 0b       	sbc	r19, r25
     18e:	b9 01       	movw	r22, r18
     190:	37 ff       	sbrs	r19, 7
     192:	04 c0       	rjmp	.+8      	; 0x19c <_fpadd_parts+0xb2>
     194:	66 27       	eor	r22, r22
     196:	77 27       	eor	r23, r23
     198:	62 1b       	sub	r22, r18
     19a:	73 0b       	sbc	r23, r19
     19c:	60 32       	cpi	r22, 0x20	; 32
     19e:	71 05       	cpc	r23, r1
     1a0:	0c f0       	brlt	.+2      	; 0x1a4 <_fpadd_parts+0xba>
     1a2:	61 c0       	rjmp	.+194    	; 0x266 <_fpadd_parts+0x17c>
     1a4:	12 16       	cp	r1, r18
     1a6:	13 06       	cpc	r1, r19
     1a8:	6c f5       	brge	.+90     	; 0x204 <_fpadd_parts+0x11a>
     1aa:	37 01       	movw	r6, r14
     1ac:	48 01       	movw	r8, r16
     1ae:	06 2e       	mov	r0, r22
     1b0:	04 c0       	rjmp	.+8      	; 0x1ba <_fpadd_parts+0xd0>
     1b2:	96 94       	lsr	r9
     1b4:	87 94       	ror	r8
     1b6:	77 94       	ror	r7
     1b8:	67 94       	ror	r6
     1ba:	0a 94       	dec	r0
     1bc:	d2 f7       	brpl	.-12     	; 0x1b2 <_fpadd_parts+0xc8>
     1be:	21 e0       	ldi	r18, 0x01	; 1
     1c0:	30 e0       	ldi	r19, 0x00	; 0
     1c2:	40 e0       	ldi	r20, 0x00	; 0
     1c4:	50 e0       	ldi	r21, 0x00	; 0
     1c6:	04 c0       	rjmp	.+8      	; 0x1d0 <_fpadd_parts+0xe6>
     1c8:	22 0f       	add	r18, r18
     1ca:	33 1f       	adc	r19, r19
     1cc:	44 1f       	adc	r20, r20
     1ce:	55 1f       	adc	r21, r21
     1d0:	6a 95       	dec	r22
     1d2:	d2 f7       	brpl	.-12     	; 0x1c8 <_fpadd_parts+0xde>
     1d4:	21 50       	subi	r18, 0x01	; 1
     1d6:	30 40       	sbci	r19, 0x00	; 0
     1d8:	40 40       	sbci	r20, 0x00	; 0
     1da:	50 40       	sbci	r21, 0x00	; 0
     1dc:	2e 21       	and	r18, r14
     1de:	3f 21       	and	r19, r15
     1e0:	40 23       	and	r20, r16
     1e2:	51 23       	and	r21, r17
     1e4:	21 15       	cp	r18, r1
     1e6:	31 05       	cpc	r19, r1
     1e8:	41 05       	cpc	r20, r1
     1ea:	51 05       	cpc	r21, r1
     1ec:	21 f0       	breq	.+8      	; 0x1f6 <_fpadd_parts+0x10c>
     1ee:	21 e0       	ldi	r18, 0x01	; 1
     1f0:	30 e0       	ldi	r19, 0x00	; 0
     1f2:	40 e0       	ldi	r20, 0x00	; 0
     1f4:	50 e0       	ldi	r21, 0x00	; 0
     1f6:	79 01       	movw	r14, r18
     1f8:	8a 01       	movw	r16, r20
     1fa:	e6 28       	or	r14, r6
     1fc:	f7 28       	or	r15, r7
     1fe:	08 29       	or	r16, r8
     200:	19 29       	or	r17, r9
     202:	3c c0       	rjmp	.+120    	; 0x27c <_fpadd_parts+0x192>
     204:	23 2b       	or	r18, r19
     206:	d1 f1       	breq	.+116    	; 0x27c <_fpadd_parts+0x192>
     208:	26 0e       	add	r2, r22
     20a:	37 1e       	adc	r3, r23
     20c:	35 01       	movw	r6, r10
     20e:	46 01       	movw	r8, r12
     210:	06 2e       	mov	r0, r22
     212:	04 c0       	rjmp	.+8      	; 0x21c <_fpadd_parts+0x132>
     214:	96 94       	lsr	r9
     216:	87 94       	ror	r8
     218:	77 94       	ror	r7
     21a:	67 94       	ror	r6
     21c:	0a 94       	dec	r0
     21e:	d2 f7       	brpl	.-12     	; 0x214 <_fpadd_parts+0x12a>
     220:	21 e0       	ldi	r18, 0x01	; 1
     222:	30 e0       	ldi	r19, 0x00	; 0
     224:	40 e0       	ldi	r20, 0x00	; 0
     226:	50 e0       	ldi	r21, 0x00	; 0
     228:	04 c0       	rjmp	.+8      	; 0x232 <_fpadd_parts+0x148>
     22a:	22 0f       	add	r18, r18
     22c:	33 1f       	adc	r19, r19
     22e:	44 1f       	adc	r20, r20
     230:	55 1f       	adc	r21, r21
     232:	6a 95       	dec	r22
     234:	d2 f7       	brpl	.-12     	; 0x22a <_fpadd_parts+0x140>
     236:	21 50       	subi	r18, 0x01	; 1
     238:	30 40       	sbci	r19, 0x00	; 0
     23a:	40 40       	sbci	r20, 0x00	; 0
     23c:	50 40       	sbci	r21, 0x00	; 0
     23e:	2a 21       	and	r18, r10
     240:	3b 21       	and	r19, r11
     242:	4c 21       	and	r20, r12
     244:	5d 21       	and	r21, r13
     246:	21 15       	cp	r18, r1
     248:	31 05       	cpc	r19, r1
     24a:	41 05       	cpc	r20, r1
     24c:	51 05       	cpc	r21, r1
     24e:	21 f0       	breq	.+8      	; 0x258 <_fpadd_parts+0x16e>
     250:	21 e0       	ldi	r18, 0x01	; 1
     252:	30 e0       	ldi	r19, 0x00	; 0
     254:	40 e0       	ldi	r20, 0x00	; 0
     256:	50 e0       	ldi	r21, 0x00	; 0
     258:	59 01       	movw	r10, r18
     25a:	6a 01       	movw	r12, r20
     25c:	a6 28       	or	r10, r6
     25e:	b7 28       	or	r11, r7
     260:	c8 28       	or	r12, r8
     262:	d9 28       	or	r13, r9
     264:	0b c0       	rjmp	.+22     	; 0x27c <_fpadd_parts+0x192>
     266:	82 15       	cp	r24, r2
     268:	93 05       	cpc	r25, r3
     26a:	2c f0       	brlt	.+10     	; 0x276 <_fpadd_parts+0x18c>
     26c:	1c 01       	movw	r2, r24
     26e:	aa 24       	eor	r10, r10
     270:	bb 24       	eor	r11, r11
     272:	65 01       	movw	r12, r10
     274:	03 c0       	rjmp	.+6      	; 0x27c <_fpadd_parts+0x192>
     276:	ee 24       	eor	r14, r14
     278:	ff 24       	eor	r15, r15
     27a:	87 01       	movw	r16, r14
     27c:	11 96       	adiw	r26, 0x01	; 1
     27e:	9c 91       	ld	r25, X
     280:	d2 01       	movw	r26, r4
     282:	11 96       	adiw	r26, 0x01	; 1
     284:	8c 91       	ld	r24, X
     286:	98 17       	cp	r25, r24
     288:	09 f4       	brne	.+2      	; 0x28c <_fpadd_parts+0x1a2>
     28a:	45 c0       	rjmp	.+138    	; 0x316 <_fpadd_parts+0x22c>
     28c:	99 23       	and	r25, r25
     28e:	39 f0       	breq	.+14     	; 0x29e <_fpadd_parts+0x1b4>
     290:	a8 01       	movw	r20, r16
     292:	97 01       	movw	r18, r14
     294:	2a 19       	sub	r18, r10
     296:	3b 09       	sbc	r19, r11
     298:	4c 09       	sbc	r20, r12
     29a:	5d 09       	sbc	r21, r13
     29c:	06 c0       	rjmp	.+12     	; 0x2aa <_fpadd_parts+0x1c0>
     29e:	a6 01       	movw	r20, r12
     2a0:	95 01       	movw	r18, r10
     2a2:	2e 19       	sub	r18, r14
     2a4:	3f 09       	sbc	r19, r15
     2a6:	40 0b       	sbc	r20, r16
     2a8:	51 0b       	sbc	r21, r17
     2aa:	57 fd       	sbrc	r21, 7
     2ac:	08 c0       	rjmp	.+16     	; 0x2be <_fpadd_parts+0x1d4>
     2ae:	11 82       	std	Z+1, r1	; 0x01
     2b0:	33 82       	std	Z+3, r3	; 0x03
     2b2:	22 82       	std	Z+2, r2	; 0x02
     2b4:	24 83       	std	Z+4, r18	; 0x04
     2b6:	35 83       	std	Z+5, r19	; 0x05
     2b8:	46 83       	std	Z+6, r20	; 0x06
     2ba:	57 83       	std	Z+7, r21	; 0x07
     2bc:	1d c0       	rjmp	.+58     	; 0x2f8 <_fpadd_parts+0x20e>
     2be:	81 e0       	ldi	r24, 0x01	; 1
     2c0:	81 83       	std	Z+1, r24	; 0x01
     2c2:	33 82       	std	Z+3, r3	; 0x03
     2c4:	22 82       	std	Z+2, r2	; 0x02
     2c6:	88 27       	eor	r24, r24
     2c8:	99 27       	eor	r25, r25
     2ca:	dc 01       	movw	r26, r24
     2cc:	82 1b       	sub	r24, r18
     2ce:	93 0b       	sbc	r25, r19
     2d0:	a4 0b       	sbc	r26, r20
     2d2:	b5 0b       	sbc	r27, r21
     2d4:	84 83       	std	Z+4, r24	; 0x04
     2d6:	95 83       	std	Z+5, r25	; 0x05
     2d8:	a6 83       	std	Z+6, r26	; 0x06
     2da:	b7 83       	std	Z+7, r27	; 0x07
     2dc:	0d c0       	rjmp	.+26     	; 0x2f8 <_fpadd_parts+0x20e>
     2de:	22 0f       	add	r18, r18
     2e0:	33 1f       	adc	r19, r19
     2e2:	44 1f       	adc	r20, r20
     2e4:	55 1f       	adc	r21, r21
     2e6:	24 83       	std	Z+4, r18	; 0x04
     2e8:	35 83       	std	Z+5, r19	; 0x05
     2ea:	46 83       	std	Z+6, r20	; 0x06
     2ec:	57 83       	std	Z+7, r21	; 0x07
     2ee:	82 81       	ldd	r24, Z+2	; 0x02
     2f0:	93 81       	ldd	r25, Z+3	; 0x03
     2f2:	01 97       	sbiw	r24, 0x01	; 1
     2f4:	93 83       	std	Z+3, r25	; 0x03
     2f6:	82 83       	std	Z+2, r24	; 0x02
     2f8:	24 81       	ldd	r18, Z+4	; 0x04
     2fa:	35 81       	ldd	r19, Z+5	; 0x05
     2fc:	46 81       	ldd	r20, Z+6	; 0x06
     2fe:	57 81       	ldd	r21, Z+7	; 0x07
     300:	da 01       	movw	r26, r20
     302:	c9 01       	movw	r24, r18
     304:	01 97       	sbiw	r24, 0x01	; 1
     306:	a1 09       	sbc	r26, r1
     308:	b1 09       	sbc	r27, r1
     30a:	8f 5f       	subi	r24, 0xFF	; 255
     30c:	9f 4f       	sbci	r25, 0xFF	; 255
     30e:	af 4f       	sbci	r26, 0xFF	; 255
     310:	bf 43       	sbci	r27, 0x3F	; 63
     312:	28 f3       	brcs	.-54     	; 0x2de <_fpadd_parts+0x1f4>
     314:	0b c0       	rjmp	.+22     	; 0x32c <_fpadd_parts+0x242>
     316:	91 83       	std	Z+1, r25	; 0x01
     318:	33 82       	std	Z+3, r3	; 0x03
     31a:	22 82       	std	Z+2, r2	; 0x02
     31c:	ea 0c       	add	r14, r10
     31e:	fb 1c       	adc	r15, r11
     320:	0c 1d       	adc	r16, r12
     322:	1d 1d       	adc	r17, r13
     324:	e4 82       	std	Z+4, r14	; 0x04
     326:	f5 82       	std	Z+5, r15	; 0x05
     328:	06 83       	std	Z+6, r16	; 0x06
     32a:	17 83       	std	Z+7, r17	; 0x07
     32c:	83 e0       	ldi	r24, 0x03	; 3
     32e:	80 83       	st	Z, r24
     330:	24 81       	ldd	r18, Z+4	; 0x04
     332:	35 81       	ldd	r19, Z+5	; 0x05
     334:	46 81       	ldd	r20, Z+6	; 0x06
     336:	57 81       	ldd	r21, Z+7	; 0x07
     338:	57 ff       	sbrs	r21, 7
     33a:	1a c0       	rjmp	.+52     	; 0x370 <_fpadd_parts+0x286>
     33c:	c9 01       	movw	r24, r18
     33e:	aa 27       	eor	r26, r26
     340:	97 fd       	sbrc	r25, 7
     342:	a0 95       	com	r26
     344:	ba 2f       	mov	r27, r26
     346:	81 70       	andi	r24, 0x01	; 1
     348:	90 70       	andi	r25, 0x00	; 0
     34a:	a0 70       	andi	r26, 0x00	; 0
     34c:	b0 70       	andi	r27, 0x00	; 0
     34e:	56 95       	lsr	r21
     350:	47 95       	ror	r20
     352:	37 95       	ror	r19
     354:	27 95       	ror	r18
     356:	82 2b       	or	r24, r18
     358:	93 2b       	or	r25, r19
     35a:	a4 2b       	or	r26, r20
     35c:	b5 2b       	or	r27, r21
     35e:	84 83       	std	Z+4, r24	; 0x04
     360:	95 83       	std	Z+5, r25	; 0x05
     362:	a6 83       	std	Z+6, r26	; 0x06
     364:	b7 83       	std	Z+7, r27	; 0x07
     366:	82 81       	ldd	r24, Z+2	; 0x02
     368:	93 81       	ldd	r25, Z+3	; 0x03
     36a:	01 96       	adiw	r24, 0x01	; 1
     36c:	93 83       	std	Z+3, r25	; 0x03
     36e:	82 83       	std	Z+2, r24	; 0x02
     370:	df 01       	movw	r26, r30
     372:	01 c0       	rjmp	.+2      	; 0x376 <_fpadd_parts+0x28c>
     374:	d2 01       	movw	r26, r4
     376:	cd 01       	movw	r24, r26
     378:	cd b7       	in	r28, 0x3d	; 61
     37a:	de b7       	in	r29, 0x3e	; 62
     37c:	e2 e1       	ldi	r30, 0x12	; 18
     37e:	0c 94 f8 32 	jmp	0x65f0	; 0x65f0 <__epilogue_restores__>

00000382 <__subsf3>:
     382:	a0 e2       	ldi	r26, 0x20	; 32
     384:	b0 e0       	ldi	r27, 0x00	; 0
     386:	e7 ec       	ldi	r30, 0xC7	; 199
     388:	f1 e0       	ldi	r31, 0x01	; 1
     38a:	0c 94 e8 32 	jmp	0x65d0	; 0x65d0 <__prologue_saves__+0x18>
     38e:	69 83       	std	Y+1, r22	; 0x01
     390:	7a 83       	std	Y+2, r23	; 0x02
     392:	8b 83       	std	Y+3, r24	; 0x03
     394:	9c 83       	std	Y+4, r25	; 0x04
     396:	2d 83       	std	Y+5, r18	; 0x05
     398:	3e 83       	std	Y+6, r19	; 0x06
     39a:	4f 83       	std	Y+7, r20	; 0x07
     39c:	58 87       	std	Y+8, r21	; 0x08
     39e:	e9 e0       	ldi	r30, 0x09	; 9
     3a0:	ee 2e       	mov	r14, r30
     3a2:	f1 2c       	mov	r15, r1
     3a4:	ec 0e       	add	r14, r28
     3a6:	fd 1e       	adc	r15, r29
     3a8:	ce 01       	movw	r24, r28
     3aa:	01 96       	adiw	r24, 0x01	; 1
     3ac:	b7 01       	movw	r22, r14
     3ae:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     3b2:	8e 01       	movw	r16, r28
     3b4:	0f 5e       	subi	r16, 0xEF	; 239
     3b6:	1f 4f       	sbci	r17, 0xFF	; 255
     3b8:	ce 01       	movw	r24, r28
     3ba:	05 96       	adiw	r24, 0x05	; 5
     3bc:	b8 01       	movw	r22, r16
     3be:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     3c2:	8a 89       	ldd	r24, Y+18	; 0x12
     3c4:	91 e0       	ldi	r25, 0x01	; 1
     3c6:	89 27       	eor	r24, r25
     3c8:	8a 8b       	std	Y+18, r24	; 0x12
     3ca:	c7 01       	movw	r24, r14
     3cc:	b8 01       	movw	r22, r16
     3ce:	ae 01       	movw	r20, r28
     3d0:	47 5e       	subi	r20, 0xE7	; 231
     3d2:	5f 4f       	sbci	r21, 0xFF	; 255
     3d4:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     3d8:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     3dc:	a0 96       	adiw	r28, 0x20	; 32
     3de:	e6 e0       	ldi	r30, 0x06	; 6
     3e0:	0c 94 04 33 	jmp	0x6608	; 0x6608 <__epilogue_restores__+0x18>

000003e4 <__addsf3>:
     3e4:	a0 e2       	ldi	r26, 0x20	; 32
     3e6:	b0 e0       	ldi	r27, 0x00	; 0
     3e8:	e8 ef       	ldi	r30, 0xF8	; 248
     3ea:	f1 e0       	ldi	r31, 0x01	; 1
     3ec:	0c 94 e8 32 	jmp	0x65d0	; 0x65d0 <__prologue_saves__+0x18>
     3f0:	69 83       	std	Y+1, r22	; 0x01
     3f2:	7a 83       	std	Y+2, r23	; 0x02
     3f4:	8b 83       	std	Y+3, r24	; 0x03
     3f6:	9c 83       	std	Y+4, r25	; 0x04
     3f8:	2d 83       	std	Y+5, r18	; 0x05
     3fa:	3e 83       	std	Y+6, r19	; 0x06
     3fc:	4f 83       	std	Y+7, r20	; 0x07
     3fe:	58 87       	std	Y+8, r21	; 0x08
     400:	f9 e0       	ldi	r31, 0x09	; 9
     402:	ef 2e       	mov	r14, r31
     404:	f1 2c       	mov	r15, r1
     406:	ec 0e       	add	r14, r28
     408:	fd 1e       	adc	r15, r29
     40a:	ce 01       	movw	r24, r28
     40c:	01 96       	adiw	r24, 0x01	; 1
     40e:	b7 01       	movw	r22, r14
     410:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     414:	8e 01       	movw	r16, r28
     416:	0f 5e       	subi	r16, 0xEF	; 239
     418:	1f 4f       	sbci	r17, 0xFF	; 255
     41a:	ce 01       	movw	r24, r28
     41c:	05 96       	adiw	r24, 0x05	; 5
     41e:	b8 01       	movw	r22, r16
     420:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     424:	c7 01       	movw	r24, r14
     426:	b8 01       	movw	r22, r16
     428:	ae 01       	movw	r20, r28
     42a:	47 5e       	subi	r20, 0xE7	; 231
     42c:	5f 4f       	sbci	r21, 0xFF	; 255
     42e:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     432:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     436:	a0 96       	adiw	r28, 0x20	; 32
     438:	e6 e0       	ldi	r30, 0x06	; 6
     43a:	0c 94 04 33 	jmp	0x6608	; 0x6608 <__epilogue_restores__+0x18>

0000043e <__mulsf3>:
     43e:	a0 e2       	ldi	r26, 0x20	; 32
     440:	b0 e0       	ldi	r27, 0x00	; 0
     442:	e5 e2       	ldi	r30, 0x25	; 37
     444:	f2 e0       	ldi	r31, 0x02	; 2
     446:	0c 94 dc 32 	jmp	0x65b8	; 0x65b8 <__prologue_saves__>
     44a:	69 83       	std	Y+1, r22	; 0x01
     44c:	7a 83       	std	Y+2, r23	; 0x02
     44e:	8b 83       	std	Y+3, r24	; 0x03
     450:	9c 83       	std	Y+4, r25	; 0x04
     452:	2d 83       	std	Y+5, r18	; 0x05
     454:	3e 83       	std	Y+6, r19	; 0x06
     456:	4f 83       	std	Y+7, r20	; 0x07
     458:	58 87       	std	Y+8, r21	; 0x08
     45a:	ce 01       	movw	r24, r28
     45c:	01 96       	adiw	r24, 0x01	; 1
     45e:	be 01       	movw	r22, r28
     460:	67 5f       	subi	r22, 0xF7	; 247
     462:	7f 4f       	sbci	r23, 0xFF	; 255
     464:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     468:	ce 01       	movw	r24, r28
     46a:	05 96       	adiw	r24, 0x05	; 5
     46c:	be 01       	movw	r22, r28
     46e:	6f 5e       	subi	r22, 0xEF	; 239
     470:	7f 4f       	sbci	r23, 0xFF	; 255
     472:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     476:	99 85       	ldd	r25, Y+9	; 0x09
     478:	92 30       	cpi	r25, 0x02	; 2
     47a:	88 f0       	brcs	.+34     	; 0x49e <__mulsf3+0x60>
     47c:	89 89       	ldd	r24, Y+17	; 0x11
     47e:	82 30       	cpi	r24, 0x02	; 2
     480:	c8 f0       	brcs	.+50     	; 0x4b4 <__mulsf3+0x76>
     482:	94 30       	cpi	r25, 0x04	; 4
     484:	19 f4       	brne	.+6      	; 0x48c <__mulsf3+0x4e>
     486:	82 30       	cpi	r24, 0x02	; 2
     488:	51 f4       	brne	.+20     	; 0x49e <__mulsf3+0x60>
     48a:	04 c0       	rjmp	.+8      	; 0x494 <__mulsf3+0x56>
     48c:	84 30       	cpi	r24, 0x04	; 4
     48e:	29 f4       	brne	.+10     	; 0x49a <__mulsf3+0x5c>
     490:	92 30       	cpi	r25, 0x02	; 2
     492:	81 f4       	brne	.+32     	; 0x4b4 <__mulsf3+0x76>
     494:	81 eb       	ldi	r24, 0xB1	; 177
     496:	90 e0       	ldi	r25, 0x00	; 0
     498:	c6 c0       	rjmp	.+396    	; 0x626 <__mulsf3+0x1e8>
     49a:	92 30       	cpi	r25, 0x02	; 2
     49c:	49 f4       	brne	.+18     	; 0x4b0 <__mulsf3+0x72>
     49e:	20 e0       	ldi	r18, 0x00	; 0
     4a0:	9a 85       	ldd	r25, Y+10	; 0x0a
     4a2:	8a 89       	ldd	r24, Y+18	; 0x12
     4a4:	98 13       	cpse	r25, r24
     4a6:	21 e0       	ldi	r18, 0x01	; 1
     4a8:	2a 87       	std	Y+10, r18	; 0x0a
     4aa:	ce 01       	movw	r24, r28
     4ac:	09 96       	adiw	r24, 0x09	; 9
     4ae:	bb c0       	rjmp	.+374    	; 0x626 <__mulsf3+0x1e8>
     4b0:	82 30       	cpi	r24, 0x02	; 2
     4b2:	49 f4       	brne	.+18     	; 0x4c6 <__mulsf3+0x88>
     4b4:	20 e0       	ldi	r18, 0x00	; 0
     4b6:	9a 85       	ldd	r25, Y+10	; 0x0a
     4b8:	8a 89       	ldd	r24, Y+18	; 0x12
     4ba:	98 13       	cpse	r25, r24
     4bc:	21 e0       	ldi	r18, 0x01	; 1
     4be:	2a 8b       	std	Y+18, r18	; 0x12
     4c0:	ce 01       	movw	r24, r28
     4c2:	41 96       	adiw	r24, 0x11	; 17
     4c4:	b0 c0       	rjmp	.+352    	; 0x626 <__mulsf3+0x1e8>
     4c6:	2d 84       	ldd	r2, Y+13	; 0x0d
     4c8:	3e 84       	ldd	r3, Y+14	; 0x0e
     4ca:	4f 84       	ldd	r4, Y+15	; 0x0f
     4cc:	58 88       	ldd	r5, Y+16	; 0x10
     4ce:	6d 88       	ldd	r6, Y+21	; 0x15
     4d0:	7e 88       	ldd	r7, Y+22	; 0x16
     4d2:	8f 88       	ldd	r8, Y+23	; 0x17
     4d4:	98 8c       	ldd	r9, Y+24	; 0x18
     4d6:	ee 24       	eor	r14, r14
     4d8:	ff 24       	eor	r15, r15
     4da:	87 01       	movw	r16, r14
     4dc:	aa 24       	eor	r10, r10
     4de:	bb 24       	eor	r11, r11
     4e0:	65 01       	movw	r12, r10
     4e2:	40 e0       	ldi	r20, 0x00	; 0
     4e4:	50 e0       	ldi	r21, 0x00	; 0
     4e6:	60 e0       	ldi	r22, 0x00	; 0
     4e8:	70 e0       	ldi	r23, 0x00	; 0
     4ea:	e0 e0       	ldi	r30, 0x00	; 0
     4ec:	f0 e0       	ldi	r31, 0x00	; 0
     4ee:	c1 01       	movw	r24, r2
     4f0:	81 70       	andi	r24, 0x01	; 1
     4f2:	90 70       	andi	r25, 0x00	; 0
     4f4:	89 2b       	or	r24, r25
     4f6:	e9 f0       	breq	.+58     	; 0x532 <__mulsf3+0xf4>
     4f8:	e6 0c       	add	r14, r6
     4fa:	f7 1c       	adc	r15, r7
     4fc:	08 1d       	adc	r16, r8
     4fe:	19 1d       	adc	r17, r9
     500:	9a 01       	movw	r18, r20
     502:	ab 01       	movw	r20, r22
     504:	2a 0d       	add	r18, r10
     506:	3b 1d       	adc	r19, r11
     508:	4c 1d       	adc	r20, r12
     50a:	5d 1d       	adc	r21, r13
     50c:	80 e0       	ldi	r24, 0x00	; 0
     50e:	90 e0       	ldi	r25, 0x00	; 0
     510:	a0 e0       	ldi	r26, 0x00	; 0
     512:	b0 e0       	ldi	r27, 0x00	; 0
     514:	e6 14       	cp	r14, r6
     516:	f7 04       	cpc	r15, r7
     518:	08 05       	cpc	r16, r8
     51a:	19 05       	cpc	r17, r9
     51c:	20 f4       	brcc	.+8      	; 0x526 <__mulsf3+0xe8>
     51e:	81 e0       	ldi	r24, 0x01	; 1
     520:	90 e0       	ldi	r25, 0x00	; 0
     522:	a0 e0       	ldi	r26, 0x00	; 0
     524:	b0 e0       	ldi	r27, 0x00	; 0
     526:	ba 01       	movw	r22, r20
     528:	a9 01       	movw	r20, r18
     52a:	48 0f       	add	r20, r24
     52c:	59 1f       	adc	r21, r25
     52e:	6a 1f       	adc	r22, r26
     530:	7b 1f       	adc	r23, r27
     532:	aa 0c       	add	r10, r10
     534:	bb 1c       	adc	r11, r11
     536:	cc 1c       	adc	r12, r12
     538:	dd 1c       	adc	r13, r13
     53a:	97 fe       	sbrs	r9, 7
     53c:	08 c0       	rjmp	.+16     	; 0x54e <__mulsf3+0x110>
     53e:	81 e0       	ldi	r24, 0x01	; 1
     540:	90 e0       	ldi	r25, 0x00	; 0
     542:	a0 e0       	ldi	r26, 0x00	; 0
     544:	b0 e0       	ldi	r27, 0x00	; 0
     546:	a8 2a       	or	r10, r24
     548:	b9 2a       	or	r11, r25
     54a:	ca 2a       	or	r12, r26
     54c:	db 2a       	or	r13, r27
     54e:	31 96       	adiw	r30, 0x01	; 1
     550:	e0 32       	cpi	r30, 0x20	; 32
     552:	f1 05       	cpc	r31, r1
     554:	49 f0       	breq	.+18     	; 0x568 <__mulsf3+0x12a>
     556:	66 0c       	add	r6, r6
     558:	77 1c       	adc	r7, r7
     55a:	88 1c       	adc	r8, r8
     55c:	99 1c       	adc	r9, r9
     55e:	56 94       	lsr	r5
     560:	47 94       	ror	r4
     562:	37 94       	ror	r3
     564:	27 94       	ror	r2
     566:	c3 cf       	rjmp	.-122    	; 0x4ee <__mulsf3+0xb0>
     568:	fa 85       	ldd	r31, Y+10	; 0x0a
     56a:	ea 89       	ldd	r30, Y+18	; 0x12
     56c:	2b 89       	ldd	r18, Y+19	; 0x13
     56e:	3c 89       	ldd	r19, Y+20	; 0x14
     570:	8b 85       	ldd	r24, Y+11	; 0x0b
     572:	9c 85       	ldd	r25, Y+12	; 0x0c
     574:	28 0f       	add	r18, r24
     576:	39 1f       	adc	r19, r25
     578:	2e 5f       	subi	r18, 0xFE	; 254
     57a:	3f 4f       	sbci	r19, 0xFF	; 255
     57c:	17 c0       	rjmp	.+46     	; 0x5ac <__mulsf3+0x16e>
     57e:	ca 01       	movw	r24, r20
     580:	81 70       	andi	r24, 0x01	; 1
     582:	90 70       	andi	r25, 0x00	; 0
     584:	89 2b       	or	r24, r25
     586:	61 f0       	breq	.+24     	; 0x5a0 <__mulsf3+0x162>
     588:	16 95       	lsr	r17
     58a:	07 95       	ror	r16
     58c:	f7 94       	ror	r15
     58e:	e7 94       	ror	r14
     590:	80 e0       	ldi	r24, 0x00	; 0
     592:	90 e0       	ldi	r25, 0x00	; 0
     594:	a0 e0       	ldi	r26, 0x00	; 0
     596:	b0 e8       	ldi	r27, 0x80	; 128
     598:	e8 2a       	or	r14, r24
     59a:	f9 2a       	or	r15, r25
     59c:	0a 2b       	or	r16, r26
     59e:	1b 2b       	or	r17, r27
     5a0:	76 95       	lsr	r23
     5a2:	67 95       	ror	r22
     5a4:	57 95       	ror	r21
     5a6:	47 95       	ror	r20
     5a8:	2f 5f       	subi	r18, 0xFF	; 255
     5aa:	3f 4f       	sbci	r19, 0xFF	; 255
     5ac:	77 fd       	sbrc	r23, 7
     5ae:	e7 cf       	rjmp	.-50     	; 0x57e <__mulsf3+0x140>
     5b0:	0c c0       	rjmp	.+24     	; 0x5ca <__mulsf3+0x18c>
     5b2:	44 0f       	add	r20, r20
     5b4:	55 1f       	adc	r21, r21
     5b6:	66 1f       	adc	r22, r22
     5b8:	77 1f       	adc	r23, r23
     5ba:	17 fd       	sbrc	r17, 7
     5bc:	41 60       	ori	r20, 0x01	; 1
     5be:	ee 0c       	add	r14, r14
     5c0:	ff 1c       	adc	r15, r15
     5c2:	00 1f       	adc	r16, r16
     5c4:	11 1f       	adc	r17, r17
     5c6:	21 50       	subi	r18, 0x01	; 1
     5c8:	30 40       	sbci	r19, 0x00	; 0
     5ca:	40 30       	cpi	r20, 0x00	; 0
     5cc:	90 e0       	ldi	r25, 0x00	; 0
     5ce:	59 07       	cpc	r21, r25
     5d0:	90 e0       	ldi	r25, 0x00	; 0
     5d2:	69 07       	cpc	r22, r25
     5d4:	90 e4       	ldi	r25, 0x40	; 64
     5d6:	79 07       	cpc	r23, r25
     5d8:	60 f3       	brcs	.-40     	; 0x5b2 <__mulsf3+0x174>
     5da:	2b 8f       	std	Y+27, r18	; 0x1b
     5dc:	3c 8f       	std	Y+28, r19	; 0x1c
     5de:	db 01       	movw	r26, r22
     5e0:	ca 01       	movw	r24, r20
     5e2:	8f 77       	andi	r24, 0x7F	; 127
     5e4:	90 70       	andi	r25, 0x00	; 0
     5e6:	a0 70       	andi	r26, 0x00	; 0
     5e8:	b0 70       	andi	r27, 0x00	; 0
     5ea:	80 34       	cpi	r24, 0x40	; 64
     5ec:	91 05       	cpc	r25, r1
     5ee:	a1 05       	cpc	r26, r1
     5f0:	b1 05       	cpc	r27, r1
     5f2:	61 f4       	brne	.+24     	; 0x60c <__mulsf3+0x1ce>
     5f4:	47 fd       	sbrc	r20, 7
     5f6:	0a c0       	rjmp	.+20     	; 0x60c <__mulsf3+0x1ce>
     5f8:	e1 14       	cp	r14, r1
     5fa:	f1 04       	cpc	r15, r1
     5fc:	01 05       	cpc	r16, r1
     5fe:	11 05       	cpc	r17, r1
     600:	29 f0       	breq	.+10     	; 0x60c <__mulsf3+0x1ce>
     602:	40 5c       	subi	r20, 0xC0	; 192
     604:	5f 4f       	sbci	r21, 0xFF	; 255
     606:	6f 4f       	sbci	r22, 0xFF	; 255
     608:	7f 4f       	sbci	r23, 0xFF	; 255
     60a:	40 78       	andi	r20, 0x80	; 128
     60c:	1a 8e       	std	Y+26, r1	; 0x1a
     60e:	fe 17       	cp	r31, r30
     610:	11 f0       	breq	.+4      	; 0x616 <__mulsf3+0x1d8>
     612:	81 e0       	ldi	r24, 0x01	; 1
     614:	8a 8f       	std	Y+26, r24	; 0x1a
     616:	4d 8f       	std	Y+29, r20	; 0x1d
     618:	5e 8f       	std	Y+30, r21	; 0x1e
     61a:	6f 8f       	std	Y+31, r22	; 0x1f
     61c:	78 a3       	std	Y+32, r23	; 0x20
     61e:	83 e0       	ldi	r24, 0x03	; 3
     620:	89 8f       	std	Y+25, r24	; 0x19
     622:	ce 01       	movw	r24, r28
     624:	49 96       	adiw	r24, 0x19	; 25
     626:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     62a:	a0 96       	adiw	r28, 0x20	; 32
     62c:	e2 e1       	ldi	r30, 0x12	; 18
     62e:	0c 94 f8 32 	jmp	0x65f0	; 0x65f0 <__epilogue_restores__>

00000632 <__gtsf2>:
     632:	a8 e1       	ldi	r26, 0x18	; 24
     634:	b0 e0       	ldi	r27, 0x00	; 0
     636:	ef e1       	ldi	r30, 0x1F	; 31
     638:	f3 e0       	ldi	r31, 0x03	; 3
     63a:	0c 94 e8 32 	jmp	0x65d0	; 0x65d0 <__prologue_saves__+0x18>
     63e:	69 83       	std	Y+1, r22	; 0x01
     640:	7a 83       	std	Y+2, r23	; 0x02
     642:	8b 83       	std	Y+3, r24	; 0x03
     644:	9c 83       	std	Y+4, r25	; 0x04
     646:	2d 83       	std	Y+5, r18	; 0x05
     648:	3e 83       	std	Y+6, r19	; 0x06
     64a:	4f 83       	std	Y+7, r20	; 0x07
     64c:	58 87       	std	Y+8, r21	; 0x08
     64e:	89 e0       	ldi	r24, 0x09	; 9
     650:	e8 2e       	mov	r14, r24
     652:	f1 2c       	mov	r15, r1
     654:	ec 0e       	add	r14, r28
     656:	fd 1e       	adc	r15, r29
     658:	ce 01       	movw	r24, r28
     65a:	01 96       	adiw	r24, 0x01	; 1
     65c:	b7 01       	movw	r22, r14
     65e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     662:	8e 01       	movw	r16, r28
     664:	0f 5e       	subi	r16, 0xEF	; 239
     666:	1f 4f       	sbci	r17, 0xFF	; 255
     668:	ce 01       	movw	r24, r28
     66a:	05 96       	adiw	r24, 0x05	; 5
     66c:	b8 01       	movw	r22, r16
     66e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     672:	89 85       	ldd	r24, Y+9	; 0x09
     674:	82 30       	cpi	r24, 0x02	; 2
     676:	40 f0       	brcs	.+16     	; 0x688 <__gtsf2+0x56>
     678:	89 89       	ldd	r24, Y+17	; 0x11
     67a:	82 30       	cpi	r24, 0x02	; 2
     67c:	28 f0       	brcs	.+10     	; 0x688 <__gtsf2+0x56>
     67e:	c7 01       	movw	r24, r14
     680:	b8 01       	movw	r22, r16
     682:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     686:	01 c0       	rjmp	.+2      	; 0x68a <__gtsf2+0x58>
     688:	8f ef       	ldi	r24, 0xFF	; 255
     68a:	68 96       	adiw	r28, 0x18	; 24
     68c:	e6 e0       	ldi	r30, 0x06	; 6
     68e:	0c 94 04 33 	jmp	0x6608	; 0x6608 <__epilogue_restores__+0x18>

00000692 <__gesf2>:
     692:	a8 e1       	ldi	r26, 0x18	; 24
     694:	b0 e0       	ldi	r27, 0x00	; 0
     696:	ef e4       	ldi	r30, 0x4F	; 79
     698:	f3 e0       	ldi	r31, 0x03	; 3
     69a:	0c 94 e8 32 	jmp	0x65d0	; 0x65d0 <__prologue_saves__+0x18>
     69e:	69 83       	std	Y+1, r22	; 0x01
     6a0:	7a 83       	std	Y+2, r23	; 0x02
     6a2:	8b 83       	std	Y+3, r24	; 0x03
     6a4:	9c 83       	std	Y+4, r25	; 0x04
     6a6:	2d 83       	std	Y+5, r18	; 0x05
     6a8:	3e 83       	std	Y+6, r19	; 0x06
     6aa:	4f 83       	std	Y+7, r20	; 0x07
     6ac:	58 87       	std	Y+8, r21	; 0x08
     6ae:	89 e0       	ldi	r24, 0x09	; 9
     6b0:	e8 2e       	mov	r14, r24
     6b2:	f1 2c       	mov	r15, r1
     6b4:	ec 0e       	add	r14, r28
     6b6:	fd 1e       	adc	r15, r29
     6b8:	ce 01       	movw	r24, r28
     6ba:	01 96       	adiw	r24, 0x01	; 1
     6bc:	b7 01       	movw	r22, r14
     6be:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     6c2:	8e 01       	movw	r16, r28
     6c4:	0f 5e       	subi	r16, 0xEF	; 239
     6c6:	1f 4f       	sbci	r17, 0xFF	; 255
     6c8:	ce 01       	movw	r24, r28
     6ca:	05 96       	adiw	r24, 0x05	; 5
     6cc:	b8 01       	movw	r22, r16
     6ce:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     6d2:	89 85       	ldd	r24, Y+9	; 0x09
     6d4:	82 30       	cpi	r24, 0x02	; 2
     6d6:	40 f0       	brcs	.+16     	; 0x6e8 <__gesf2+0x56>
     6d8:	89 89       	ldd	r24, Y+17	; 0x11
     6da:	82 30       	cpi	r24, 0x02	; 2
     6dc:	28 f0       	brcs	.+10     	; 0x6e8 <__gesf2+0x56>
     6de:	c7 01       	movw	r24, r14
     6e0:	b8 01       	movw	r22, r16
     6e2:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     6e6:	01 c0       	rjmp	.+2      	; 0x6ea <__gesf2+0x58>
     6e8:	8f ef       	ldi	r24, 0xFF	; 255
     6ea:	68 96       	adiw	r28, 0x18	; 24
     6ec:	e6 e0       	ldi	r30, 0x06	; 6
     6ee:	0c 94 04 33 	jmp	0x6608	; 0x6608 <__epilogue_restores__+0x18>

000006f2 <__ltsf2>:
     6f2:	a8 e1       	ldi	r26, 0x18	; 24
     6f4:	b0 e0       	ldi	r27, 0x00	; 0
     6f6:	ef e7       	ldi	r30, 0x7F	; 127
     6f8:	f3 e0       	ldi	r31, 0x03	; 3
     6fa:	0c 94 e8 32 	jmp	0x65d0	; 0x65d0 <__prologue_saves__+0x18>
     6fe:	69 83       	std	Y+1, r22	; 0x01
     700:	7a 83       	std	Y+2, r23	; 0x02
     702:	8b 83       	std	Y+3, r24	; 0x03
     704:	9c 83       	std	Y+4, r25	; 0x04
     706:	2d 83       	std	Y+5, r18	; 0x05
     708:	3e 83       	std	Y+6, r19	; 0x06
     70a:	4f 83       	std	Y+7, r20	; 0x07
     70c:	58 87       	std	Y+8, r21	; 0x08
     70e:	89 e0       	ldi	r24, 0x09	; 9
     710:	e8 2e       	mov	r14, r24
     712:	f1 2c       	mov	r15, r1
     714:	ec 0e       	add	r14, r28
     716:	fd 1e       	adc	r15, r29
     718:	ce 01       	movw	r24, r28
     71a:	01 96       	adiw	r24, 0x01	; 1
     71c:	b7 01       	movw	r22, r14
     71e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     722:	8e 01       	movw	r16, r28
     724:	0f 5e       	subi	r16, 0xEF	; 239
     726:	1f 4f       	sbci	r17, 0xFF	; 255
     728:	ce 01       	movw	r24, r28
     72a:	05 96       	adiw	r24, 0x05	; 5
     72c:	b8 01       	movw	r22, r16
     72e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     732:	89 85       	ldd	r24, Y+9	; 0x09
     734:	82 30       	cpi	r24, 0x02	; 2
     736:	40 f0       	brcs	.+16     	; 0x748 <__ltsf2+0x56>
     738:	89 89       	ldd	r24, Y+17	; 0x11
     73a:	82 30       	cpi	r24, 0x02	; 2
     73c:	28 f0       	brcs	.+10     	; 0x748 <__ltsf2+0x56>
     73e:	c7 01       	movw	r24, r14
     740:	b8 01       	movw	r22, r16
     742:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     746:	01 c0       	rjmp	.+2      	; 0x74a <__ltsf2+0x58>
     748:	81 e0       	ldi	r24, 0x01	; 1
     74a:	68 96       	adiw	r28, 0x18	; 24
     74c:	e6 e0       	ldi	r30, 0x06	; 6
     74e:	0c 94 04 33 	jmp	0x6608	; 0x6608 <__epilogue_restores__+0x18>

00000752 <__fixsfsi>:
     752:	ac e0       	ldi	r26, 0x0C	; 12
     754:	b0 e0       	ldi	r27, 0x00	; 0
     756:	ef ea       	ldi	r30, 0xAF	; 175
     758:	f3 e0       	ldi	r31, 0x03	; 3
     75a:	0c 94 ec 32 	jmp	0x65d8	; 0x65d8 <__prologue_saves__+0x20>
     75e:	69 83       	std	Y+1, r22	; 0x01
     760:	7a 83       	std	Y+2, r23	; 0x02
     762:	8b 83       	std	Y+3, r24	; 0x03
     764:	9c 83       	std	Y+4, r25	; 0x04
     766:	ce 01       	movw	r24, r28
     768:	01 96       	adiw	r24, 0x01	; 1
     76a:	be 01       	movw	r22, r28
     76c:	6b 5f       	subi	r22, 0xFB	; 251
     76e:	7f 4f       	sbci	r23, 0xFF	; 255
     770:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     774:	8d 81       	ldd	r24, Y+5	; 0x05
     776:	82 30       	cpi	r24, 0x02	; 2
     778:	61 f1       	breq	.+88     	; 0x7d2 <__fixsfsi+0x80>
     77a:	82 30       	cpi	r24, 0x02	; 2
     77c:	50 f1       	brcs	.+84     	; 0x7d2 <__fixsfsi+0x80>
     77e:	84 30       	cpi	r24, 0x04	; 4
     780:	21 f4       	brne	.+8      	; 0x78a <__fixsfsi+0x38>
     782:	8e 81       	ldd	r24, Y+6	; 0x06
     784:	88 23       	and	r24, r24
     786:	51 f1       	breq	.+84     	; 0x7dc <__fixsfsi+0x8a>
     788:	2e c0       	rjmp	.+92     	; 0x7e6 <__fixsfsi+0x94>
     78a:	2f 81       	ldd	r18, Y+7	; 0x07
     78c:	38 85       	ldd	r19, Y+8	; 0x08
     78e:	37 fd       	sbrc	r19, 7
     790:	20 c0       	rjmp	.+64     	; 0x7d2 <__fixsfsi+0x80>
     792:	6e 81       	ldd	r22, Y+6	; 0x06
     794:	2f 31       	cpi	r18, 0x1F	; 31
     796:	31 05       	cpc	r19, r1
     798:	1c f0       	brlt	.+6      	; 0x7a0 <__fixsfsi+0x4e>
     79a:	66 23       	and	r22, r22
     79c:	f9 f0       	breq	.+62     	; 0x7dc <__fixsfsi+0x8a>
     79e:	23 c0       	rjmp	.+70     	; 0x7e6 <__fixsfsi+0x94>
     7a0:	8e e1       	ldi	r24, 0x1E	; 30
     7a2:	90 e0       	ldi	r25, 0x00	; 0
     7a4:	82 1b       	sub	r24, r18
     7a6:	93 0b       	sbc	r25, r19
     7a8:	29 85       	ldd	r18, Y+9	; 0x09
     7aa:	3a 85       	ldd	r19, Y+10	; 0x0a
     7ac:	4b 85       	ldd	r20, Y+11	; 0x0b
     7ae:	5c 85       	ldd	r21, Y+12	; 0x0c
     7b0:	04 c0       	rjmp	.+8      	; 0x7ba <__fixsfsi+0x68>
     7b2:	56 95       	lsr	r21
     7b4:	47 95       	ror	r20
     7b6:	37 95       	ror	r19
     7b8:	27 95       	ror	r18
     7ba:	8a 95       	dec	r24
     7bc:	d2 f7       	brpl	.-12     	; 0x7b2 <__fixsfsi+0x60>
     7be:	66 23       	and	r22, r22
     7c0:	b1 f0       	breq	.+44     	; 0x7ee <__fixsfsi+0x9c>
     7c2:	50 95       	com	r21
     7c4:	40 95       	com	r20
     7c6:	30 95       	com	r19
     7c8:	21 95       	neg	r18
     7ca:	3f 4f       	sbci	r19, 0xFF	; 255
     7cc:	4f 4f       	sbci	r20, 0xFF	; 255
     7ce:	5f 4f       	sbci	r21, 0xFF	; 255
     7d0:	0e c0       	rjmp	.+28     	; 0x7ee <__fixsfsi+0x9c>
     7d2:	20 e0       	ldi	r18, 0x00	; 0
     7d4:	30 e0       	ldi	r19, 0x00	; 0
     7d6:	40 e0       	ldi	r20, 0x00	; 0
     7d8:	50 e0       	ldi	r21, 0x00	; 0
     7da:	09 c0       	rjmp	.+18     	; 0x7ee <__fixsfsi+0x9c>
     7dc:	2f ef       	ldi	r18, 0xFF	; 255
     7de:	3f ef       	ldi	r19, 0xFF	; 255
     7e0:	4f ef       	ldi	r20, 0xFF	; 255
     7e2:	5f e7       	ldi	r21, 0x7F	; 127
     7e4:	04 c0       	rjmp	.+8      	; 0x7ee <__fixsfsi+0x9c>
     7e6:	20 e0       	ldi	r18, 0x00	; 0
     7e8:	30 e0       	ldi	r19, 0x00	; 0
     7ea:	40 e0       	ldi	r20, 0x00	; 0
     7ec:	50 e8       	ldi	r21, 0x80	; 128
     7ee:	b9 01       	movw	r22, r18
     7f0:	ca 01       	movw	r24, r20
     7f2:	2c 96       	adiw	r28, 0x0c	; 12
     7f4:	e2 e0       	ldi	r30, 0x02	; 2
     7f6:	0c 94 08 33 	jmp	0x6610	; 0x6610 <__epilogue_restores__+0x20>

000007fa <__pack_f>:
     7fa:	df 92       	push	r13
     7fc:	ef 92       	push	r14
     7fe:	ff 92       	push	r15
     800:	0f 93       	push	r16
     802:	1f 93       	push	r17
     804:	fc 01       	movw	r30, r24
     806:	e4 80       	ldd	r14, Z+4	; 0x04
     808:	f5 80       	ldd	r15, Z+5	; 0x05
     80a:	06 81       	ldd	r16, Z+6	; 0x06
     80c:	17 81       	ldd	r17, Z+7	; 0x07
     80e:	d1 80       	ldd	r13, Z+1	; 0x01
     810:	80 81       	ld	r24, Z
     812:	82 30       	cpi	r24, 0x02	; 2
     814:	48 f4       	brcc	.+18     	; 0x828 <__pack_f+0x2e>
     816:	80 e0       	ldi	r24, 0x00	; 0
     818:	90 e0       	ldi	r25, 0x00	; 0
     81a:	a0 e1       	ldi	r26, 0x10	; 16
     81c:	b0 e0       	ldi	r27, 0x00	; 0
     81e:	e8 2a       	or	r14, r24
     820:	f9 2a       	or	r15, r25
     822:	0a 2b       	or	r16, r26
     824:	1b 2b       	or	r17, r27
     826:	a5 c0       	rjmp	.+330    	; 0x972 <__stack+0x113>
     828:	84 30       	cpi	r24, 0x04	; 4
     82a:	09 f4       	brne	.+2      	; 0x82e <__pack_f+0x34>
     82c:	9f c0       	rjmp	.+318    	; 0x96c <__stack+0x10d>
     82e:	82 30       	cpi	r24, 0x02	; 2
     830:	21 f4       	brne	.+8      	; 0x83a <__pack_f+0x40>
     832:	ee 24       	eor	r14, r14
     834:	ff 24       	eor	r15, r15
     836:	87 01       	movw	r16, r14
     838:	05 c0       	rjmp	.+10     	; 0x844 <__pack_f+0x4a>
     83a:	e1 14       	cp	r14, r1
     83c:	f1 04       	cpc	r15, r1
     83e:	01 05       	cpc	r16, r1
     840:	11 05       	cpc	r17, r1
     842:	19 f4       	brne	.+6      	; 0x84a <__pack_f+0x50>
     844:	e0 e0       	ldi	r30, 0x00	; 0
     846:	f0 e0       	ldi	r31, 0x00	; 0
     848:	96 c0       	rjmp	.+300    	; 0x976 <__stack+0x117>
     84a:	62 81       	ldd	r22, Z+2	; 0x02
     84c:	73 81       	ldd	r23, Z+3	; 0x03
     84e:	9f ef       	ldi	r25, 0xFF	; 255
     850:	62 38       	cpi	r22, 0x82	; 130
     852:	79 07       	cpc	r23, r25
     854:	0c f0       	brlt	.+2      	; 0x858 <__pack_f+0x5e>
     856:	5b c0       	rjmp	.+182    	; 0x90e <__stack+0xaf>
     858:	22 e8       	ldi	r18, 0x82	; 130
     85a:	3f ef       	ldi	r19, 0xFF	; 255
     85c:	26 1b       	sub	r18, r22
     85e:	37 0b       	sbc	r19, r23
     860:	2a 31       	cpi	r18, 0x1A	; 26
     862:	31 05       	cpc	r19, r1
     864:	2c f0       	brlt	.+10     	; 0x870 <__stack+0x11>
     866:	20 e0       	ldi	r18, 0x00	; 0
     868:	30 e0       	ldi	r19, 0x00	; 0
     86a:	40 e0       	ldi	r20, 0x00	; 0
     86c:	50 e0       	ldi	r21, 0x00	; 0
     86e:	2a c0       	rjmp	.+84     	; 0x8c4 <__stack+0x65>
     870:	b8 01       	movw	r22, r16
     872:	a7 01       	movw	r20, r14
     874:	02 2e       	mov	r0, r18
     876:	04 c0       	rjmp	.+8      	; 0x880 <__stack+0x21>
     878:	76 95       	lsr	r23
     87a:	67 95       	ror	r22
     87c:	57 95       	ror	r21
     87e:	47 95       	ror	r20
     880:	0a 94       	dec	r0
     882:	d2 f7       	brpl	.-12     	; 0x878 <__stack+0x19>
     884:	81 e0       	ldi	r24, 0x01	; 1
     886:	90 e0       	ldi	r25, 0x00	; 0
     888:	a0 e0       	ldi	r26, 0x00	; 0
     88a:	b0 e0       	ldi	r27, 0x00	; 0
     88c:	04 c0       	rjmp	.+8      	; 0x896 <__stack+0x37>
     88e:	88 0f       	add	r24, r24
     890:	99 1f       	adc	r25, r25
     892:	aa 1f       	adc	r26, r26
     894:	bb 1f       	adc	r27, r27
     896:	2a 95       	dec	r18
     898:	d2 f7       	brpl	.-12     	; 0x88e <__stack+0x2f>
     89a:	01 97       	sbiw	r24, 0x01	; 1
     89c:	a1 09       	sbc	r26, r1
     89e:	b1 09       	sbc	r27, r1
     8a0:	8e 21       	and	r24, r14
     8a2:	9f 21       	and	r25, r15
     8a4:	a0 23       	and	r26, r16
     8a6:	b1 23       	and	r27, r17
     8a8:	00 97       	sbiw	r24, 0x00	; 0
     8aa:	a1 05       	cpc	r26, r1
     8ac:	b1 05       	cpc	r27, r1
     8ae:	21 f0       	breq	.+8      	; 0x8b8 <__stack+0x59>
     8b0:	81 e0       	ldi	r24, 0x01	; 1
     8b2:	90 e0       	ldi	r25, 0x00	; 0
     8b4:	a0 e0       	ldi	r26, 0x00	; 0
     8b6:	b0 e0       	ldi	r27, 0x00	; 0
     8b8:	9a 01       	movw	r18, r20
     8ba:	ab 01       	movw	r20, r22
     8bc:	28 2b       	or	r18, r24
     8be:	39 2b       	or	r19, r25
     8c0:	4a 2b       	or	r20, r26
     8c2:	5b 2b       	or	r21, r27
     8c4:	da 01       	movw	r26, r20
     8c6:	c9 01       	movw	r24, r18
     8c8:	8f 77       	andi	r24, 0x7F	; 127
     8ca:	90 70       	andi	r25, 0x00	; 0
     8cc:	a0 70       	andi	r26, 0x00	; 0
     8ce:	b0 70       	andi	r27, 0x00	; 0
     8d0:	80 34       	cpi	r24, 0x40	; 64
     8d2:	91 05       	cpc	r25, r1
     8d4:	a1 05       	cpc	r26, r1
     8d6:	b1 05       	cpc	r27, r1
     8d8:	39 f4       	brne	.+14     	; 0x8e8 <__stack+0x89>
     8da:	27 ff       	sbrs	r18, 7
     8dc:	09 c0       	rjmp	.+18     	; 0x8f0 <__stack+0x91>
     8de:	20 5c       	subi	r18, 0xC0	; 192
     8e0:	3f 4f       	sbci	r19, 0xFF	; 255
     8e2:	4f 4f       	sbci	r20, 0xFF	; 255
     8e4:	5f 4f       	sbci	r21, 0xFF	; 255
     8e6:	04 c0       	rjmp	.+8      	; 0x8f0 <__stack+0x91>
     8e8:	21 5c       	subi	r18, 0xC1	; 193
     8ea:	3f 4f       	sbci	r19, 0xFF	; 255
     8ec:	4f 4f       	sbci	r20, 0xFF	; 255
     8ee:	5f 4f       	sbci	r21, 0xFF	; 255
     8f0:	e0 e0       	ldi	r30, 0x00	; 0
     8f2:	f0 e0       	ldi	r31, 0x00	; 0
     8f4:	20 30       	cpi	r18, 0x00	; 0
     8f6:	a0 e0       	ldi	r26, 0x00	; 0
     8f8:	3a 07       	cpc	r19, r26
     8fa:	a0 e0       	ldi	r26, 0x00	; 0
     8fc:	4a 07       	cpc	r20, r26
     8fe:	a0 e4       	ldi	r26, 0x40	; 64
     900:	5a 07       	cpc	r21, r26
     902:	10 f0       	brcs	.+4      	; 0x908 <__stack+0xa9>
     904:	e1 e0       	ldi	r30, 0x01	; 1
     906:	f0 e0       	ldi	r31, 0x00	; 0
     908:	79 01       	movw	r14, r18
     90a:	8a 01       	movw	r16, r20
     90c:	27 c0       	rjmp	.+78     	; 0x95c <__stack+0xfd>
     90e:	60 38       	cpi	r22, 0x80	; 128
     910:	71 05       	cpc	r23, r1
     912:	64 f5       	brge	.+88     	; 0x96c <__stack+0x10d>
     914:	fb 01       	movw	r30, r22
     916:	e1 58       	subi	r30, 0x81	; 129
     918:	ff 4f       	sbci	r31, 0xFF	; 255
     91a:	d8 01       	movw	r26, r16
     91c:	c7 01       	movw	r24, r14
     91e:	8f 77       	andi	r24, 0x7F	; 127
     920:	90 70       	andi	r25, 0x00	; 0
     922:	a0 70       	andi	r26, 0x00	; 0
     924:	b0 70       	andi	r27, 0x00	; 0
     926:	80 34       	cpi	r24, 0x40	; 64
     928:	91 05       	cpc	r25, r1
     92a:	a1 05       	cpc	r26, r1
     92c:	b1 05       	cpc	r27, r1
     92e:	39 f4       	brne	.+14     	; 0x93e <__stack+0xdf>
     930:	e7 fe       	sbrs	r14, 7
     932:	0d c0       	rjmp	.+26     	; 0x94e <__stack+0xef>
     934:	80 e4       	ldi	r24, 0x40	; 64
     936:	90 e0       	ldi	r25, 0x00	; 0
     938:	a0 e0       	ldi	r26, 0x00	; 0
     93a:	b0 e0       	ldi	r27, 0x00	; 0
     93c:	04 c0       	rjmp	.+8      	; 0x946 <__stack+0xe7>
     93e:	8f e3       	ldi	r24, 0x3F	; 63
     940:	90 e0       	ldi	r25, 0x00	; 0
     942:	a0 e0       	ldi	r26, 0x00	; 0
     944:	b0 e0       	ldi	r27, 0x00	; 0
     946:	e8 0e       	add	r14, r24
     948:	f9 1e       	adc	r15, r25
     94a:	0a 1f       	adc	r16, r26
     94c:	1b 1f       	adc	r17, r27
     94e:	17 ff       	sbrs	r17, 7
     950:	05 c0       	rjmp	.+10     	; 0x95c <__stack+0xfd>
     952:	16 95       	lsr	r17
     954:	07 95       	ror	r16
     956:	f7 94       	ror	r15
     958:	e7 94       	ror	r14
     95a:	31 96       	adiw	r30, 0x01	; 1
     95c:	87 e0       	ldi	r24, 0x07	; 7
     95e:	16 95       	lsr	r17
     960:	07 95       	ror	r16
     962:	f7 94       	ror	r15
     964:	e7 94       	ror	r14
     966:	8a 95       	dec	r24
     968:	d1 f7       	brne	.-12     	; 0x95e <__stack+0xff>
     96a:	05 c0       	rjmp	.+10     	; 0x976 <__stack+0x117>
     96c:	ee 24       	eor	r14, r14
     96e:	ff 24       	eor	r15, r15
     970:	87 01       	movw	r16, r14
     972:	ef ef       	ldi	r30, 0xFF	; 255
     974:	f0 e0       	ldi	r31, 0x00	; 0
     976:	6e 2f       	mov	r22, r30
     978:	67 95       	ror	r22
     97a:	66 27       	eor	r22, r22
     97c:	67 95       	ror	r22
     97e:	90 2f       	mov	r25, r16
     980:	9f 77       	andi	r25, 0x7F	; 127
     982:	d7 94       	ror	r13
     984:	dd 24       	eor	r13, r13
     986:	d7 94       	ror	r13
     988:	8e 2f       	mov	r24, r30
     98a:	86 95       	lsr	r24
     98c:	49 2f       	mov	r20, r25
     98e:	46 2b       	or	r20, r22
     990:	58 2f       	mov	r21, r24
     992:	5d 29       	or	r21, r13
     994:	b7 01       	movw	r22, r14
     996:	ca 01       	movw	r24, r20
     998:	1f 91       	pop	r17
     99a:	0f 91       	pop	r16
     99c:	ff 90       	pop	r15
     99e:	ef 90       	pop	r14
     9a0:	df 90       	pop	r13
     9a2:	08 95       	ret

000009a4 <__unpack_f>:
     9a4:	fc 01       	movw	r30, r24
     9a6:	db 01       	movw	r26, r22
     9a8:	40 81       	ld	r20, Z
     9aa:	51 81       	ldd	r21, Z+1	; 0x01
     9ac:	22 81       	ldd	r18, Z+2	; 0x02
     9ae:	62 2f       	mov	r22, r18
     9b0:	6f 77       	andi	r22, 0x7F	; 127
     9b2:	70 e0       	ldi	r23, 0x00	; 0
     9b4:	22 1f       	adc	r18, r18
     9b6:	22 27       	eor	r18, r18
     9b8:	22 1f       	adc	r18, r18
     9ba:	93 81       	ldd	r25, Z+3	; 0x03
     9bc:	89 2f       	mov	r24, r25
     9be:	88 0f       	add	r24, r24
     9c0:	82 2b       	or	r24, r18
     9c2:	28 2f       	mov	r18, r24
     9c4:	30 e0       	ldi	r19, 0x00	; 0
     9c6:	99 1f       	adc	r25, r25
     9c8:	99 27       	eor	r25, r25
     9ca:	99 1f       	adc	r25, r25
     9cc:	11 96       	adiw	r26, 0x01	; 1
     9ce:	9c 93       	st	X, r25
     9d0:	11 97       	sbiw	r26, 0x01	; 1
     9d2:	21 15       	cp	r18, r1
     9d4:	31 05       	cpc	r19, r1
     9d6:	a9 f5       	brne	.+106    	; 0xa42 <__unpack_f+0x9e>
     9d8:	41 15       	cp	r20, r1
     9da:	51 05       	cpc	r21, r1
     9dc:	61 05       	cpc	r22, r1
     9de:	71 05       	cpc	r23, r1
     9e0:	11 f4       	brne	.+4      	; 0x9e6 <__unpack_f+0x42>
     9e2:	82 e0       	ldi	r24, 0x02	; 2
     9e4:	37 c0       	rjmp	.+110    	; 0xa54 <__unpack_f+0xb0>
     9e6:	82 e8       	ldi	r24, 0x82	; 130
     9e8:	9f ef       	ldi	r25, 0xFF	; 255
     9ea:	13 96       	adiw	r26, 0x03	; 3
     9ec:	9c 93       	st	X, r25
     9ee:	8e 93       	st	-X, r24
     9f0:	12 97       	sbiw	r26, 0x02	; 2
     9f2:	9a 01       	movw	r18, r20
     9f4:	ab 01       	movw	r20, r22
     9f6:	67 e0       	ldi	r22, 0x07	; 7
     9f8:	22 0f       	add	r18, r18
     9fa:	33 1f       	adc	r19, r19
     9fc:	44 1f       	adc	r20, r20
     9fe:	55 1f       	adc	r21, r21
     a00:	6a 95       	dec	r22
     a02:	d1 f7       	brne	.-12     	; 0x9f8 <__unpack_f+0x54>
     a04:	83 e0       	ldi	r24, 0x03	; 3
     a06:	8c 93       	st	X, r24
     a08:	0d c0       	rjmp	.+26     	; 0xa24 <__unpack_f+0x80>
     a0a:	22 0f       	add	r18, r18
     a0c:	33 1f       	adc	r19, r19
     a0e:	44 1f       	adc	r20, r20
     a10:	55 1f       	adc	r21, r21
     a12:	12 96       	adiw	r26, 0x02	; 2
     a14:	8d 91       	ld	r24, X+
     a16:	9c 91       	ld	r25, X
     a18:	13 97       	sbiw	r26, 0x03	; 3
     a1a:	01 97       	sbiw	r24, 0x01	; 1
     a1c:	13 96       	adiw	r26, 0x03	; 3
     a1e:	9c 93       	st	X, r25
     a20:	8e 93       	st	-X, r24
     a22:	12 97       	sbiw	r26, 0x02	; 2
     a24:	20 30       	cpi	r18, 0x00	; 0
     a26:	80 e0       	ldi	r24, 0x00	; 0
     a28:	38 07       	cpc	r19, r24
     a2a:	80 e0       	ldi	r24, 0x00	; 0
     a2c:	48 07       	cpc	r20, r24
     a2e:	80 e4       	ldi	r24, 0x40	; 64
     a30:	58 07       	cpc	r21, r24
     a32:	58 f3       	brcs	.-42     	; 0xa0a <__unpack_f+0x66>
     a34:	14 96       	adiw	r26, 0x04	; 4
     a36:	2d 93       	st	X+, r18
     a38:	3d 93       	st	X+, r19
     a3a:	4d 93       	st	X+, r20
     a3c:	5c 93       	st	X, r21
     a3e:	17 97       	sbiw	r26, 0x07	; 7
     a40:	08 95       	ret
     a42:	2f 3f       	cpi	r18, 0xFF	; 255
     a44:	31 05       	cpc	r19, r1
     a46:	79 f4       	brne	.+30     	; 0xa66 <__unpack_f+0xc2>
     a48:	41 15       	cp	r20, r1
     a4a:	51 05       	cpc	r21, r1
     a4c:	61 05       	cpc	r22, r1
     a4e:	71 05       	cpc	r23, r1
     a50:	19 f4       	brne	.+6      	; 0xa58 <__unpack_f+0xb4>
     a52:	84 e0       	ldi	r24, 0x04	; 4
     a54:	8c 93       	st	X, r24
     a56:	08 95       	ret
     a58:	64 ff       	sbrs	r22, 4
     a5a:	03 c0       	rjmp	.+6      	; 0xa62 <__unpack_f+0xbe>
     a5c:	81 e0       	ldi	r24, 0x01	; 1
     a5e:	8c 93       	st	X, r24
     a60:	12 c0       	rjmp	.+36     	; 0xa86 <__unpack_f+0xe2>
     a62:	1c 92       	st	X, r1
     a64:	10 c0       	rjmp	.+32     	; 0xa86 <__unpack_f+0xe2>
     a66:	2f 57       	subi	r18, 0x7F	; 127
     a68:	30 40       	sbci	r19, 0x00	; 0
     a6a:	13 96       	adiw	r26, 0x03	; 3
     a6c:	3c 93       	st	X, r19
     a6e:	2e 93       	st	-X, r18
     a70:	12 97       	sbiw	r26, 0x02	; 2
     a72:	83 e0       	ldi	r24, 0x03	; 3
     a74:	8c 93       	st	X, r24
     a76:	87 e0       	ldi	r24, 0x07	; 7
     a78:	44 0f       	add	r20, r20
     a7a:	55 1f       	adc	r21, r21
     a7c:	66 1f       	adc	r22, r22
     a7e:	77 1f       	adc	r23, r23
     a80:	8a 95       	dec	r24
     a82:	d1 f7       	brne	.-12     	; 0xa78 <__unpack_f+0xd4>
     a84:	70 64       	ori	r23, 0x40	; 64
     a86:	14 96       	adiw	r26, 0x04	; 4
     a88:	4d 93       	st	X+, r20
     a8a:	5d 93       	st	X+, r21
     a8c:	6d 93       	st	X+, r22
     a8e:	7c 93       	st	X, r23
     a90:	17 97       	sbiw	r26, 0x07	; 7
     a92:	08 95       	ret

00000a94 <__fpcmp_parts_f>:
     a94:	1f 93       	push	r17
     a96:	dc 01       	movw	r26, r24
     a98:	fb 01       	movw	r30, r22
     a9a:	9c 91       	ld	r25, X
     a9c:	92 30       	cpi	r25, 0x02	; 2
     a9e:	08 f4       	brcc	.+2      	; 0xaa2 <__fpcmp_parts_f+0xe>
     aa0:	47 c0       	rjmp	.+142    	; 0xb30 <__fpcmp_parts_f+0x9c>
     aa2:	80 81       	ld	r24, Z
     aa4:	82 30       	cpi	r24, 0x02	; 2
     aa6:	08 f4       	brcc	.+2      	; 0xaaa <__fpcmp_parts_f+0x16>
     aa8:	43 c0       	rjmp	.+134    	; 0xb30 <__fpcmp_parts_f+0x9c>
     aaa:	94 30       	cpi	r25, 0x04	; 4
     aac:	51 f4       	brne	.+20     	; 0xac2 <__fpcmp_parts_f+0x2e>
     aae:	11 96       	adiw	r26, 0x01	; 1
     ab0:	1c 91       	ld	r17, X
     ab2:	84 30       	cpi	r24, 0x04	; 4
     ab4:	99 f5       	brne	.+102    	; 0xb1c <__fpcmp_parts_f+0x88>
     ab6:	81 81       	ldd	r24, Z+1	; 0x01
     ab8:	68 2f       	mov	r22, r24
     aba:	70 e0       	ldi	r23, 0x00	; 0
     abc:	61 1b       	sub	r22, r17
     abe:	71 09       	sbc	r23, r1
     ac0:	3f c0       	rjmp	.+126    	; 0xb40 <__fpcmp_parts_f+0xac>
     ac2:	84 30       	cpi	r24, 0x04	; 4
     ac4:	21 f0       	breq	.+8      	; 0xace <__fpcmp_parts_f+0x3a>
     ac6:	92 30       	cpi	r25, 0x02	; 2
     ac8:	31 f4       	brne	.+12     	; 0xad6 <__fpcmp_parts_f+0x42>
     aca:	82 30       	cpi	r24, 0x02	; 2
     acc:	b9 f1       	breq	.+110    	; 0xb3c <__fpcmp_parts_f+0xa8>
     ace:	81 81       	ldd	r24, Z+1	; 0x01
     ad0:	88 23       	and	r24, r24
     ad2:	89 f1       	breq	.+98     	; 0xb36 <__fpcmp_parts_f+0xa2>
     ad4:	2d c0       	rjmp	.+90     	; 0xb30 <__fpcmp_parts_f+0x9c>
     ad6:	11 96       	adiw	r26, 0x01	; 1
     ad8:	1c 91       	ld	r17, X
     ada:	11 97       	sbiw	r26, 0x01	; 1
     adc:	82 30       	cpi	r24, 0x02	; 2
     ade:	f1 f0       	breq	.+60     	; 0xb1c <__fpcmp_parts_f+0x88>
     ae0:	81 81       	ldd	r24, Z+1	; 0x01
     ae2:	18 17       	cp	r17, r24
     ae4:	d9 f4       	brne	.+54     	; 0xb1c <__fpcmp_parts_f+0x88>
     ae6:	12 96       	adiw	r26, 0x02	; 2
     ae8:	2d 91       	ld	r18, X+
     aea:	3c 91       	ld	r19, X
     aec:	13 97       	sbiw	r26, 0x03	; 3
     aee:	82 81       	ldd	r24, Z+2	; 0x02
     af0:	93 81       	ldd	r25, Z+3	; 0x03
     af2:	82 17       	cp	r24, r18
     af4:	93 07       	cpc	r25, r19
     af6:	94 f0       	brlt	.+36     	; 0xb1c <__fpcmp_parts_f+0x88>
     af8:	28 17       	cp	r18, r24
     afa:	39 07       	cpc	r19, r25
     afc:	bc f0       	brlt	.+46     	; 0xb2c <__fpcmp_parts_f+0x98>
     afe:	14 96       	adiw	r26, 0x04	; 4
     b00:	8d 91       	ld	r24, X+
     b02:	9d 91       	ld	r25, X+
     b04:	0d 90       	ld	r0, X+
     b06:	bc 91       	ld	r27, X
     b08:	a0 2d       	mov	r26, r0
     b0a:	24 81       	ldd	r18, Z+4	; 0x04
     b0c:	35 81       	ldd	r19, Z+5	; 0x05
     b0e:	46 81       	ldd	r20, Z+6	; 0x06
     b10:	57 81       	ldd	r21, Z+7	; 0x07
     b12:	28 17       	cp	r18, r24
     b14:	39 07       	cpc	r19, r25
     b16:	4a 07       	cpc	r20, r26
     b18:	5b 07       	cpc	r21, r27
     b1a:	18 f4       	brcc	.+6      	; 0xb22 <__fpcmp_parts_f+0x8e>
     b1c:	11 23       	and	r17, r17
     b1e:	41 f0       	breq	.+16     	; 0xb30 <__fpcmp_parts_f+0x9c>
     b20:	0a c0       	rjmp	.+20     	; 0xb36 <__fpcmp_parts_f+0xa2>
     b22:	82 17       	cp	r24, r18
     b24:	93 07       	cpc	r25, r19
     b26:	a4 07       	cpc	r26, r20
     b28:	b5 07       	cpc	r27, r21
     b2a:	40 f4       	brcc	.+16     	; 0xb3c <__fpcmp_parts_f+0xa8>
     b2c:	11 23       	and	r17, r17
     b2e:	19 f0       	breq	.+6      	; 0xb36 <__fpcmp_parts_f+0xa2>
     b30:	61 e0       	ldi	r22, 0x01	; 1
     b32:	70 e0       	ldi	r23, 0x00	; 0
     b34:	05 c0       	rjmp	.+10     	; 0xb40 <__fpcmp_parts_f+0xac>
     b36:	6f ef       	ldi	r22, 0xFF	; 255
     b38:	7f ef       	ldi	r23, 0xFF	; 255
     b3a:	02 c0       	rjmp	.+4      	; 0xb40 <__fpcmp_parts_f+0xac>
     b3c:	60 e0       	ldi	r22, 0x00	; 0
     b3e:	70 e0       	ldi	r23, 0x00	; 0
     b40:	cb 01       	movw	r24, r22
     b42:	1f 91       	pop	r17
     b44:	08 95       	ret

00000b46 <DIO_WritePin>:
 */

#include "DIO_operations.h"
#include "Memory_map.h"
void DIO_WritePin(uint8 PinNum,uint8 PinValue)
{
     b46:	df 93       	push	r29
     b48:	cf 93       	push	r28
     b4a:	00 d0       	rcall	.+0      	; 0xb4c <DIO_WritePin+0x6>
     b4c:	cd b7       	in	r28, 0x3d	; 61
     b4e:	de b7       	in	r29, 0x3e	; 62
     b50:	89 83       	std	Y+1, r24	; 0x01
     b52:	6a 83       	std	Y+2, r22	; 0x02
if(PinValue==1)
     b54:	8a 81       	ldd	r24, Y+2	; 0x02
     b56:	81 30       	cpi	r24, 0x01	; 1
     b58:	09 f0       	breq	.+2      	; 0xb5c <DIO_WritePin+0x16>
     b5a:	70 c0       	rjmp	.+224    	; 0xc3c <DIO_WritePin+0xf6>
{
	if(PinNum>=PinA0&&PinNum<=PinA7)
     b5c:	89 81       	ldd	r24, Y+1	; 0x01
     b5e:	88 30       	cpi	r24, 0x08	; 8
     b60:	a0 f4       	brcc	.+40     	; 0xb8a <DIO_WritePin+0x44>
	{
		Set_Bit(PORTA,PinNum);
     b62:	ab e3       	ldi	r26, 0x3B	; 59
     b64:	b0 e0       	ldi	r27, 0x00	; 0
     b66:	eb e3       	ldi	r30, 0x3B	; 59
     b68:	f0 e0       	ldi	r31, 0x00	; 0
     b6a:	80 81       	ld	r24, Z
     b6c:	48 2f       	mov	r20, r24
     b6e:	89 81       	ldd	r24, Y+1	; 0x01
     b70:	28 2f       	mov	r18, r24
     b72:	30 e0       	ldi	r19, 0x00	; 0
     b74:	81 e0       	ldi	r24, 0x01	; 1
     b76:	90 e0       	ldi	r25, 0x00	; 0
     b78:	02 2e       	mov	r0, r18
     b7a:	02 c0       	rjmp	.+4      	; 0xb80 <DIO_WritePin+0x3a>
     b7c:	88 0f       	add	r24, r24
     b7e:	99 1f       	adc	r25, r25
     b80:	0a 94       	dec	r0
     b82:	e2 f7       	brpl	.-8      	; 0xb7c <DIO_WritePin+0x36>
     b84:	84 2b       	or	r24, r20
     b86:	8c 93       	st	X, r24
     b88:	ce c0       	rjmp	.+412    	; 0xd26 <DIO_WritePin+0x1e0>
	}
	else if(PinNum>=PinB0&&PinNum<=PinB7)
     b8a:	89 81       	ldd	r24, Y+1	; 0x01
     b8c:	88 30       	cpi	r24, 0x08	; 8
     b8e:	d0 f0       	brcs	.+52     	; 0xbc4 <DIO_WritePin+0x7e>
     b90:	89 81       	ldd	r24, Y+1	; 0x01
     b92:	80 31       	cpi	r24, 0x10	; 16
     b94:	b8 f4       	brcc	.+46     	; 0xbc4 <DIO_WritePin+0x7e>
	{
		Set_Bit(PORTB,(PinNum-8));
     b96:	a8 e3       	ldi	r26, 0x38	; 56
     b98:	b0 e0       	ldi	r27, 0x00	; 0
     b9a:	e8 e3       	ldi	r30, 0x38	; 56
     b9c:	f0 e0       	ldi	r31, 0x00	; 0
     b9e:	80 81       	ld	r24, Z
     ba0:	48 2f       	mov	r20, r24
     ba2:	89 81       	ldd	r24, Y+1	; 0x01
     ba4:	88 2f       	mov	r24, r24
     ba6:	90 e0       	ldi	r25, 0x00	; 0
     ba8:	9c 01       	movw	r18, r24
     baa:	28 50       	subi	r18, 0x08	; 8
     bac:	30 40       	sbci	r19, 0x00	; 0
     bae:	81 e0       	ldi	r24, 0x01	; 1
     bb0:	90 e0       	ldi	r25, 0x00	; 0
     bb2:	02 2e       	mov	r0, r18
     bb4:	02 c0       	rjmp	.+4      	; 0xbba <DIO_WritePin+0x74>
     bb6:	88 0f       	add	r24, r24
     bb8:	99 1f       	adc	r25, r25
     bba:	0a 94       	dec	r0
     bbc:	e2 f7       	brpl	.-8      	; 0xbb6 <DIO_WritePin+0x70>
     bbe:	84 2b       	or	r24, r20
     bc0:	8c 93       	st	X, r24
     bc2:	b1 c0       	rjmp	.+354    	; 0xd26 <DIO_WritePin+0x1e0>
	}
	else if(PinNum>=PinC0&&PinNum<=PinC7)
     bc4:	89 81       	ldd	r24, Y+1	; 0x01
     bc6:	80 31       	cpi	r24, 0x10	; 16
     bc8:	d0 f0       	brcs	.+52     	; 0xbfe <DIO_WritePin+0xb8>
     bca:	89 81       	ldd	r24, Y+1	; 0x01
     bcc:	88 31       	cpi	r24, 0x18	; 24
     bce:	b8 f4       	brcc	.+46     	; 0xbfe <DIO_WritePin+0xb8>
	{
		Set_Bit(PORTC,(PinNum-16));
     bd0:	a5 e3       	ldi	r26, 0x35	; 53
     bd2:	b0 e0       	ldi	r27, 0x00	; 0
     bd4:	e5 e3       	ldi	r30, 0x35	; 53
     bd6:	f0 e0       	ldi	r31, 0x00	; 0
     bd8:	80 81       	ld	r24, Z
     bda:	48 2f       	mov	r20, r24
     bdc:	89 81       	ldd	r24, Y+1	; 0x01
     bde:	88 2f       	mov	r24, r24
     be0:	90 e0       	ldi	r25, 0x00	; 0
     be2:	9c 01       	movw	r18, r24
     be4:	20 51       	subi	r18, 0x10	; 16
     be6:	30 40       	sbci	r19, 0x00	; 0
     be8:	81 e0       	ldi	r24, 0x01	; 1
     bea:	90 e0       	ldi	r25, 0x00	; 0
     bec:	02 2e       	mov	r0, r18
     bee:	02 c0       	rjmp	.+4      	; 0xbf4 <DIO_WritePin+0xae>
     bf0:	88 0f       	add	r24, r24
     bf2:	99 1f       	adc	r25, r25
     bf4:	0a 94       	dec	r0
     bf6:	e2 f7       	brpl	.-8      	; 0xbf0 <DIO_WritePin+0xaa>
     bf8:	84 2b       	or	r24, r20
     bfa:	8c 93       	st	X, r24
     bfc:	94 c0       	rjmp	.+296    	; 0xd26 <DIO_WritePin+0x1e0>
	}
	else if(PinNum>=PinD0&&PinNum<=PinD7)
     bfe:	89 81       	ldd	r24, Y+1	; 0x01
     c00:	88 31       	cpi	r24, 0x18	; 24
     c02:	08 f4       	brcc	.+2      	; 0xc06 <DIO_WritePin+0xc0>
     c04:	90 c0       	rjmp	.+288    	; 0xd26 <DIO_WritePin+0x1e0>
     c06:	89 81       	ldd	r24, Y+1	; 0x01
     c08:	80 32       	cpi	r24, 0x20	; 32
     c0a:	08 f0       	brcs	.+2      	; 0xc0e <DIO_WritePin+0xc8>
     c0c:	8c c0       	rjmp	.+280    	; 0xd26 <DIO_WritePin+0x1e0>
	{
		Set_Bit(PORTD,(PinNum-24));
     c0e:	a2 e3       	ldi	r26, 0x32	; 50
     c10:	b0 e0       	ldi	r27, 0x00	; 0
     c12:	e2 e3       	ldi	r30, 0x32	; 50
     c14:	f0 e0       	ldi	r31, 0x00	; 0
     c16:	80 81       	ld	r24, Z
     c18:	48 2f       	mov	r20, r24
     c1a:	89 81       	ldd	r24, Y+1	; 0x01
     c1c:	88 2f       	mov	r24, r24
     c1e:	90 e0       	ldi	r25, 0x00	; 0
     c20:	9c 01       	movw	r18, r24
     c22:	28 51       	subi	r18, 0x18	; 24
     c24:	30 40       	sbci	r19, 0x00	; 0
     c26:	81 e0       	ldi	r24, 0x01	; 1
     c28:	90 e0       	ldi	r25, 0x00	; 0
     c2a:	02 2e       	mov	r0, r18
     c2c:	02 c0       	rjmp	.+4      	; 0xc32 <DIO_WritePin+0xec>
     c2e:	88 0f       	add	r24, r24
     c30:	99 1f       	adc	r25, r25
     c32:	0a 94       	dec	r0
     c34:	e2 f7       	brpl	.-8      	; 0xc2e <DIO_WritePin+0xe8>
     c36:	84 2b       	or	r24, r20
     c38:	8c 93       	st	X, r24
     c3a:	75 c0       	rjmp	.+234    	; 0xd26 <DIO_WritePin+0x1e0>
	}
}
else if(PinValue==0)
     c3c:	8a 81       	ldd	r24, Y+2	; 0x02
     c3e:	88 23       	and	r24, r24
     c40:	09 f0       	breq	.+2      	; 0xc44 <DIO_WritePin+0xfe>
     c42:	71 c0       	rjmp	.+226    	; 0xd26 <DIO_WritePin+0x1e0>
{
	if(PinNum>=PinA0&&PinNum<=PinA7)
     c44:	89 81       	ldd	r24, Y+1	; 0x01
     c46:	88 30       	cpi	r24, 0x08	; 8
     c48:	a8 f4       	brcc	.+42     	; 0xc74 <DIO_WritePin+0x12e>
	{
		Clear_Bit(PORTA,PinNum);
     c4a:	ab e3       	ldi	r26, 0x3B	; 59
     c4c:	b0 e0       	ldi	r27, 0x00	; 0
     c4e:	eb e3       	ldi	r30, 0x3B	; 59
     c50:	f0 e0       	ldi	r31, 0x00	; 0
     c52:	80 81       	ld	r24, Z
     c54:	48 2f       	mov	r20, r24
     c56:	89 81       	ldd	r24, Y+1	; 0x01
     c58:	28 2f       	mov	r18, r24
     c5a:	30 e0       	ldi	r19, 0x00	; 0
     c5c:	81 e0       	ldi	r24, 0x01	; 1
     c5e:	90 e0       	ldi	r25, 0x00	; 0
     c60:	02 2e       	mov	r0, r18
     c62:	02 c0       	rjmp	.+4      	; 0xc68 <DIO_WritePin+0x122>
     c64:	88 0f       	add	r24, r24
     c66:	99 1f       	adc	r25, r25
     c68:	0a 94       	dec	r0
     c6a:	e2 f7       	brpl	.-8      	; 0xc64 <DIO_WritePin+0x11e>
     c6c:	80 95       	com	r24
     c6e:	84 23       	and	r24, r20
     c70:	8c 93       	st	X, r24
     c72:	59 c0       	rjmp	.+178    	; 0xd26 <DIO_WritePin+0x1e0>
	}
	else if(PinNum>=PinB0&&PinNum<=PinB7)
     c74:	89 81       	ldd	r24, Y+1	; 0x01
     c76:	88 30       	cpi	r24, 0x08	; 8
     c78:	d8 f0       	brcs	.+54     	; 0xcb0 <DIO_WritePin+0x16a>
     c7a:	89 81       	ldd	r24, Y+1	; 0x01
     c7c:	80 31       	cpi	r24, 0x10	; 16
     c7e:	c0 f4       	brcc	.+48     	; 0xcb0 <DIO_WritePin+0x16a>
	{
		Clear_Bit(PORTB,(PinNum-8));
     c80:	a8 e3       	ldi	r26, 0x38	; 56
     c82:	b0 e0       	ldi	r27, 0x00	; 0
     c84:	e8 e3       	ldi	r30, 0x38	; 56
     c86:	f0 e0       	ldi	r31, 0x00	; 0
     c88:	80 81       	ld	r24, Z
     c8a:	48 2f       	mov	r20, r24
     c8c:	89 81       	ldd	r24, Y+1	; 0x01
     c8e:	88 2f       	mov	r24, r24
     c90:	90 e0       	ldi	r25, 0x00	; 0
     c92:	9c 01       	movw	r18, r24
     c94:	28 50       	subi	r18, 0x08	; 8
     c96:	30 40       	sbci	r19, 0x00	; 0
     c98:	81 e0       	ldi	r24, 0x01	; 1
     c9a:	90 e0       	ldi	r25, 0x00	; 0
     c9c:	02 2e       	mov	r0, r18
     c9e:	02 c0       	rjmp	.+4      	; 0xca4 <DIO_WritePin+0x15e>
     ca0:	88 0f       	add	r24, r24
     ca2:	99 1f       	adc	r25, r25
     ca4:	0a 94       	dec	r0
     ca6:	e2 f7       	brpl	.-8      	; 0xca0 <DIO_WritePin+0x15a>
     ca8:	80 95       	com	r24
     caa:	84 23       	and	r24, r20
     cac:	8c 93       	st	X, r24
     cae:	3b c0       	rjmp	.+118    	; 0xd26 <DIO_WritePin+0x1e0>
	}
	else if(PinNum>=PinC0&&PinNum<=PinC7)
     cb0:	89 81       	ldd	r24, Y+1	; 0x01
     cb2:	80 31       	cpi	r24, 0x10	; 16
     cb4:	d8 f0       	brcs	.+54     	; 0xcec <DIO_WritePin+0x1a6>
     cb6:	89 81       	ldd	r24, Y+1	; 0x01
     cb8:	88 31       	cpi	r24, 0x18	; 24
     cba:	c0 f4       	brcc	.+48     	; 0xcec <DIO_WritePin+0x1a6>
	{
		Clear_Bit(PORTC,(PinNum-16));
     cbc:	a5 e3       	ldi	r26, 0x35	; 53
     cbe:	b0 e0       	ldi	r27, 0x00	; 0
     cc0:	e5 e3       	ldi	r30, 0x35	; 53
     cc2:	f0 e0       	ldi	r31, 0x00	; 0
     cc4:	80 81       	ld	r24, Z
     cc6:	48 2f       	mov	r20, r24
     cc8:	89 81       	ldd	r24, Y+1	; 0x01
     cca:	88 2f       	mov	r24, r24
     ccc:	90 e0       	ldi	r25, 0x00	; 0
     cce:	9c 01       	movw	r18, r24
     cd0:	20 51       	subi	r18, 0x10	; 16
     cd2:	30 40       	sbci	r19, 0x00	; 0
     cd4:	81 e0       	ldi	r24, 0x01	; 1
     cd6:	90 e0       	ldi	r25, 0x00	; 0
     cd8:	02 2e       	mov	r0, r18
     cda:	02 c0       	rjmp	.+4      	; 0xce0 <DIO_WritePin+0x19a>
     cdc:	88 0f       	add	r24, r24
     cde:	99 1f       	adc	r25, r25
     ce0:	0a 94       	dec	r0
     ce2:	e2 f7       	brpl	.-8      	; 0xcdc <DIO_WritePin+0x196>
     ce4:	80 95       	com	r24
     ce6:	84 23       	and	r24, r20
     ce8:	8c 93       	st	X, r24
     cea:	1d c0       	rjmp	.+58     	; 0xd26 <DIO_WritePin+0x1e0>
	}
	else if(PinNum>=PinD0&&PinNum<=PinD7)
     cec:	89 81       	ldd	r24, Y+1	; 0x01
     cee:	88 31       	cpi	r24, 0x18	; 24
     cf0:	d0 f0       	brcs	.+52     	; 0xd26 <DIO_WritePin+0x1e0>
     cf2:	89 81       	ldd	r24, Y+1	; 0x01
     cf4:	80 32       	cpi	r24, 0x20	; 32
     cf6:	b8 f4       	brcc	.+46     	; 0xd26 <DIO_WritePin+0x1e0>
	{
		Clear_Bit(PORTD,(PinNum-24));
     cf8:	a2 e3       	ldi	r26, 0x32	; 50
     cfa:	b0 e0       	ldi	r27, 0x00	; 0
     cfc:	e2 e3       	ldi	r30, 0x32	; 50
     cfe:	f0 e0       	ldi	r31, 0x00	; 0
     d00:	80 81       	ld	r24, Z
     d02:	48 2f       	mov	r20, r24
     d04:	89 81       	ldd	r24, Y+1	; 0x01
     d06:	88 2f       	mov	r24, r24
     d08:	90 e0       	ldi	r25, 0x00	; 0
     d0a:	9c 01       	movw	r18, r24
     d0c:	28 51       	subi	r18, 0x18	; 24
     d0e:	30 40       	sbci	r19, 0x00	; 0
     d10:	81 e0       	ldi	r24, 0x01	; 1
     d12:	90 e0       	ldi	r25, 0x00	; 0
     d14:	02 2e       	mov	r0, r18
     d16:	02 c0       	rjmp	.+4      	; 0xd1c <DIO_WritePin+0x1d6>
     d18:	88 0f       	add	r24, r24
     d1a:	99 1f       	adc	r25, r25
     d1c:	0a 94       	dec	r0
     d1e:	e2 f7       	brpl	.-8      	; 0xd18 <DIO_WritePin+0x1d2>
     d20:	80 95       	com	r24
     d22:	84 23       	and	r24, r20
     d24:	8c 93       	st	X, r24
	}
}
}
     d26:	0f 90       	pop	r0
     d28:	0f 90       	pop	r0
     d2a:	cf 91       	pop	r28
     d2c:	df 91       	pop	r29
     d2e:	08 95       	ret

00000d30 <DIO_ReadPin>:
uint8 DIO_ReadPin(uint8 PinNum)
{
     d30:	df 93       	push	r29
     d32:	cf 93       	push	r28
     d34:	00 d0       	rcall	.+0      	; 0xd36 <DIO_ReadPin+0x6>
     d36:	cd b7       	in	r28, 0x3d	; 61
     d38:	de b7       	in	r29, 0x3e	; 62
     d3a:	8a 83       	std	Y+2, r24	; 0x02
	uint8 Pin_Value;
	if(PinNum>=PinA0&&PinNum<=PinA7)
     d3c:	8a 81       	ldd	r24, Y+2	; 0x02
     d3e:	88 30       	cpi	r24, 0x08	; 8
     d40:	90 f4       	brcc	.+36     	; 0xd66 <DIO_ReadPin+0x36>
	{
		Pin_Value=Get_Bit(PINA,PinNum);
     d42:	e9 e3       	ldi	r30, 0x39	; 57
     d44:	f0 e0       	ldi	r31, 0x00	; 0
     d46:	80 81       	ld	r24, Z
     d48:	48 2f       	mov	r20, r24
     d4a:	8a 81       	ldd	r24, Y+2	; 0x02
     d4c:	28 2f       	mov	r18, r24
     d4e:	30 e0       	ldi	r19, 0x00	; 0
     d50:	81 e0       	ldi	r24, 0x01	; 1
     d52:	90 e0       	ldi	r25, 0x00	; 0
     d54:	02 2e       	mov	r0, r18
     d56:	02 c0       	rjmp	.+4      	; 0xd5c <DIO_ReadPin+0x2c>
     d58:	88 0f       	add	r24, r24
     d5a:	99 1f       	adc	r25, r25
     d5c:	0a 94       	dec	r0
     d5e:	e2 f7       	brpl	.-8      	; 0xd58 <DIO_ReadPin+0x28>
     d60:	84 23       	and	r24, r20
     d62:	89 83       	std	Y+1, r24	; 0x01
     d64:	50 c0       	rjmp	.+160    	; 0xe06 <DIO_ReadPin+0xd6>
	}
	else if(PinNum>=PinB0&&PinNum<=PinB7)
     d66:	8a 81       	ldd	r24, Y+2	; 0x02
     d68:	88 30       	cpi	r24, 0x08	; 8
     d6a:	c0 f0       	brcs	.+48     	; 0xd9c <DIO_ReadPin+0x6c>
     d6c:	8a 81       	ldd	r24, Y+2	; 0x02
     d6e:	80 31       	cpi	r24, 0x10	; 16
     d70:	a8 f4       	brcc	.+42     	; 0xd9c <DIO_ReadPin+0x6c>
	{
		Pin_Value=Get_Bit(PINB,(PinNum-8));
     d72:	e6 e3       	ldi	r30, 0x36	; 54
     d74:	f0 e0       	ldi	r31, 0x00	; 0
     d76:	80 81       	ld	r24, Z
     d78:	48 2f       	mov	r20, r24
     d7a:	8a 81       	ldd	r24, Y+2	; 0x02
     d7c:	88 2f       	mov	r24, r24
     d7e:	90 e0       	ldi	r25, 0x00	; 0
     d80:	9c 01       	movw	r18, r24
     d82:	28 50       	subi	r18, 0x08	; 8
     d84:	30 40       	sbci	r19, 0x00	; 0
     d86:	81 e0       	ldi	r24, 0x01	; 1
     d88:	90 e0       	ldi	r25, 0x00	; 0
     d8a:	02 2e       	mov	r0, r18
     d8c:	02 c0       	rjmp	.+4      	; 0xd92 <DIO_ReadPin+0x62>
     d8e:	88 0f       	add	r24, r24
     d90:	99 1f       	adc	r25, r25
     d92:	0a 94       	dec	r0
     d94:	e2 f7       	brpl	.-8      	; 0xd8e <DIO_ReadPin+0x5e>
     d96:	84 23       	and	r24, r20
     d98:	89 83       	std	Y+1, r24	; 0x01
     d9a:	35 c0       	rjmp	.+106    	; 0xe06 <DIO_ReadPin+0xd6>
	}
	else if(PinNum>=PinC0&&PinNum<=PinC7)
     d9c:	8a 81       	ldd	r24, Y+2	; 0x02
     d9e:	80 31       	cpi	r24, 0x10	; 16
     da0:	c0 f0       	brcs	.+48     	; 0xdd2 <DIO_ReadPin+0xa2>
     da2:	8a 81       	ldd	r24, Y+2	; 0x02
     da4:	88 31       	cpi	r24, 0x18	; 24
     da6:	a8 f4       	brcc	.+42     	; 0xdd2 <DIO_ReadPin+0xa2>
	{
		Pin_Value=Get_Bit(PINC,(PinNum-16));
     da8:	e3 e3       	ldi	r30, 0x33	; 51
     daa:	f0 e0       	ldi	r31, 0x00	; 0
     dac:	80 81       	ld	r24, Z
     dae:	48 2f       	mov	r20, r24
     db0:	8a 81       	ldd	r24, Y+2	; 0x02
     db2:	88 2f       	mov	r24, r24
     db4:	90 e0       	ldi	r25, 0x00	; 0
     db6:	9c 01       	movw	r18, r24
     db8:	20 51       	subi	r18, 0x10	; 16
     dba:	30 40       	sbci	r19, 0x00	; 0
     dbc:	81 e0       	ldi	r24, 0x01	; 1
     dbe:	90 e0       	ldi	r25, 0x00	; 0
     dc0:	02 2e       	mov	r0, r18
     dc2:	02 c0       	rjmp	.+4      	; 0xdc8 <DIO_ReadPin+0x98>
     dc4:	88 0f       	add	r24, r24
     dc6:	99 1f       	adc	r25, r25
     dc8:	0a 94       	dec	r0
     dca:	e2 f7       	brpl	.-8      	; 0xdc4 <DIO_ReadPin+0x94>
     dcc:	84 23       	and	r24, r20
     dce:	89 83       	std	Y+1, r24	; 0x01
     dd0:	1a c0       	rjmp	.+52     	; 0xe06 <DIO_ReadPin+0xd6>
	}
	else if(PinNum>=PinD0&&PinNum<=PinD7)
     dd2:	8a 81       	ldd	r24, Y+2	; 0x02
     dd4:	88 31       	cpi	r24, 0x18	; 24
     dd6:	b8 f0       	brcs	.+46     	; 0xe06 <DIO_ReadPin+0xd6>
     dd8:	8a 81       	ldd	r24, Y+2	; 0x02
     dda:	80 32       	cpi	r24, 0x20	; 32
     ddc:	a0 f4       	brcc	.+40     	; 0xe06 <DIO_ReadPin+0xd6>
	{
		Pin_Value=Get_Bit(PIND,(PinNum-24));
     dde:	e0 e3       	ldi	r30, 0x30	; 48
     de0:	f0 e0       	ldi	r31, 0x00	; 0
     de2:	80 81       	ld	r24, Z
     de4:	48 2f       	mov	r20, r24
     de6:	8a 81       	ldd	r24, Y+2	; 0x02
     de8:	88 2f       	mov	r24, r24
     dea:	90 e0       	ldi	r25, 0x00	; 0
     dec:	9c 01       	movw	r18, r24
     dee:	28 51       	subi	r18, 0x18	; 24
     df0:	30 40       	sbci	r19, 0x00	; 0
     df2:	81 e0       	ldi	r24, 0x01	; 1
     df4:	90 e0       	ldi	r25, 0x00	; 0
     df6:	02 2e       	mov	r0, r18
     df8:	02 c0       	rjmp	.+4      	; 0xdfe <DIO_ReadPin+0xce>
     dfa:	88 0f       	add	r24, r24
     dfc:	99 1f       	adc	r25, r25
     dfe:	0a 94       	dec	r0
     e00:	e2 f7       	brpl	.-8      	; 0xdfa <DIO_ReadPin+0xca>
     e02:	84 23       	and	r24, r20
     e04:	89 83       	std	Y+1, r24	; 0x01
	}
	return Pin_Value;
     e06:	89 81       	ldd	r24, Y+1	; 0x01
}
     e08:	0f 90       	pop	r0
     e0a:	0f 90       	pop	r0
     e0c:	cf 91       	pop	r28
     e0e:	df 91       	pop	r29
     e10:	08 95       	ret

00000e12 <DIO_SetPinDirection>:
void DIO_SetPinDirection(uint8 PinNum,uint8 PinDirection)
{
     e12:	df 93       	push	r29
     e14:	cf 93       	push	r28
     e16:	00 d0       	rcall	.+0      	; 0xe18 <DIO_SetPinDirection+0x6>
     e18:	cd b7       	in	r28, 0x3d	; 61
     e1a:	de b7       	in	r29, 0x3e	; 62
     e1c:	89 83       	std	Y+1, r24	; 0x01
     e1e:	6a 83       	std	Y+2, r22	; 0x02
	if(PinDirection==1)
     e20:	8a 81       	ldd	r24, Y+2	; 0x02
     e22:	81 30       	cpi	r24, 0x01	; 1
     e24:	09 f0       	breq	.+2      	; 0xe28 <DIO_SetPinDirection+0x16>
     e26:	70 c0       	rjmp	.+224    	; 0xf08 <DIO_SetPinDirection+0xf6>
	{
		if(PinNum>=PinA0&&PinNum<=PinA7)
     e28:	89 81       	ldd	r24, Y+1	; 0x01
     e2a:	88 30       	cpi	r24, 0x08	; 8
     e2c:	a0 f4       	brcc	.+40     	; 0xe56 <DIO_SetPinDirection+0x44>
		{
			Set_Bit(DDRA,PinNum);
     e2e:	aa e3       	ldi	r26, 0x3A	; 58
     e30:	b0 e0       	ldi	r27, 0x00	; 0
     e32:	ea e3       	ldi	r30, 0x3A	; 58
     e34:	f0 e0       	ldi	r31, 0x00	; 0
     e36:	80 81       	ld	r24, Z
     e38:	48 2f       	mov	r20, r24
     e3a:	89 81       	ldd	r24, Y+1	; 0x01
     e3c:	28 2f       	mov	r18, r24
     e3e:	30 e0       	ldi	r19, 0x00	; 0
     e40:	81 e0       	ldi	r24, 0x01	; 1
     e42:	90 e0       	ldi	r25, 0x00	; 0
     e44:	02 2e       	mov	r0, r18
     e46:	02 c0       	rjmp	.+4      	; 0xe4c <DIO_SetPinDirection+0x3a>
     e48:	88 0f       	add	r24, r24
     e4a:	99 1f       	adc	r25, r25
     e4c:	0a 94       	dec	r0
     e4e:	e2 f7       	brpl	.-8      	; 0xe48 <DIO_SetPinDirection+0x36>
     e50:	84 2b       	or	r24, r20
     e52:	8c 93       	st	X, r24
     e54:	ce c0       	rjmp	.+412    	; 0xff2 <DIO_SetPinDirection+0x1e0>
		}
		else if(PinNum>=PinB0&&PinNum<=PinB7)
     e56:	89 81       	ldd	r24, Y+1	; 0x01
     e58:	88 30       	cpi	r24, 0x08	; 8
     e5a:	d0 f0       	brcs	.+52     	; 0xe90 <DIO_SetPinDirection+0x7e>
     e5c:	89 81       	ldd	r24, Y+1	; 0x01
     e5e:	80 31       	cpi	r24, 0x10	; 16
     e60:	b8 f4       	brcc	.+46     	; 0xe90 <DIO_SetPinDirection+0x7e>
		{
			Set_Bit(DDRB,(PinNum-8));
     e62:	a7 e3       	ldi	r26, 0x37	; 55
     e64:	b0 e0       	ldi	r27, 0x00	; 0
     e66:	e7 e3       	ldi	r30, 0x37	; 55
     e68:	f0 e0       	ldi	r31, 0x00	; 0
     e6a:	80 81       	ld	r24, Z
     e6c:	48 2f       	mov	r20, r24
     e6e:	89 81       	ldd	r24, Y+1	; 0x01
     e70:	88 2f       	mov	r24, r24
     e72:	90 e0       	ldi	r25, 0x00	; 0
     e74:	9c 01       	movw	r18, r24
     e76:	28 50       	subi	r18, 0x08	; 8
     e78:	30 40       	sbci	r19, 0x00	; 0
     e7a:	81 e0       	ldi	r24, 0x01	; 1
     e7c:	90 e0       	ldi	r25, 0x00	; 0
     e7e:	02 2e       	mov	r0, r18
     e80:	02 c0       	rjmp	.+4      	; 0xe86 <DIO_SetPinDirection+0x74>
     e82:	88 0f       	add	r24, r24
     e84:	99 1f       	adc	r25, r25
     e86:	0a 94       	dec	r0
     e88:	e2 f7       	brpl	.-8      	; 0xe82 <DIO_SetPinDirection+0x70>
     e8a:	84 2b       	or	r24, r20
     e8c:	8c 93       	st	X, r24
     e8e:	b1 c0       	rjmp	.+354    	; 0xff2 <DIO_SetPinDirection+0x1e0>
		}
		else if(PinNum>=PinC0&&PinNum<=PinC7)
     e90:	89 81       	ldd	r24, Y+1	; 0x01
     e92:	80 31       	cpi	r24, 0x10	; 16
     e94:	d0 f0       	brcs	.+52     	; 0xeca <DIO_SetPinDirection+0xb8>
     e96:	89 81       	ldd	r24, Y+1	; 0x01
     e98:	88 31       	cpi	r24, 0x18	; 24
     e9a:	b8 f4       	brcc	.+46     	; 0xeca <DIO_SetPinDirection+0xb8>
		{
			Set_Bit(DDRC,(PinNum-16));
     e9c:	a4 e3       	ldi	r26, 0x34	; 52
     e9e:	b0 e0       	ldi	r27, 0x00	; 0
     ea0:	e4 e3       	ldi	r30, 0x34	; 52
     ea2:	f0 e0       	ldi	r31, 0x00	; 0
     ea4:	80 81       	ld	r24, Z
     ea6:	48 2f       	mov	r20, r24
     ea8:	89 81       	ldd	r24, Y+1	; 0x01
     eaa:	88 2f       	mov	r24, r24
     eac:	90 e0       	ldi	r25, 0x00	; 0
     eae:	9c 01       	movw	r18, r24
     eb0:	20 51       	subi	r18, 0x10	; 16
     eb2:	30 40       	sbci	r19, 0x00	; 0
     eb4:	81 e0       	ldi	r24, 0x01	; 1
     eb6:	90 e0       	ldi	r25, 0x00	; 0
     eb8:	02 2e       	mov	r0, r18
     eba:	02 c0       	rjmp	.+4      	; 0xec0 <DIO_SetPinDirection+0xae>
     ebc:	88 0f       	add	r24, r24
     ebe:	99 1f       	adc	r25, r25
     ec0:	0a 94       	dec	r0
     ec2:	e2 f7       	brpl	.-8      	; 0xebc <DIO_SetPinDirection+0xaa>
     ec4:	84 2b       	or	r24, r20
     ec6:	8c 93       	st	X, r24
     ec8:	94 c0       	rjmp	.+296    	; 0xff2 <DIO_SetPinDirection+0x1e0>
		}
		else if(PinNum>=PinD0&&PinNum<=PinD7)
     eca:	89 81       	ldd	r24, Y+1	; 0x01
     ecc:	88 31       	cpi	r24, 0x18	; 24
     ece:	08 f4       	brcc	.+2      	; 0xed2 <DIO_SetPinDirection+0xc0>
     ed0:	90 c0       	rjmp	.+288    	; 0xff2 <DIO_SetPinDirection+0x1e0>
     ed2:	89 81       	ldd	r24, Y+1	; 0x01
     ed4:	80 32       	cpi	r24, 0x20	; 32
     ed6:	08 f0       	brcs	.+2      	; 0xeda <DIO_SetPinDirection+0xc8>
     ed8:	8c c0       	rjmp	.+280    	; 0xff2 <DIO_SetPinDirection+0x1e0>
		{
			Set_Bit(DDRC,(PinNum-24));
     eda:	a4 e3       	ldi	r26, 0x34	; 52
     edc:	b0 e0       	ldi	r27, 0x00	; 0
     ede:	e4 e3       	ldi	r30, 0x34	; 52
     ee0:	f0 e0       	ldi	r31, 0x00	; 0
     ee2:	80 81       	ld	r24, Z
     ee4:	48 2f       	mov	r20, r24
     ee6:	89 81       	ldd	r24, Y+1	; 0x01
     ee8:	88 2f       	mov	r24, r24
     eea:	90 e0       	ldi	r25, 0x00	; 0
     eec:	9c 01       	movw	r18, r24
     eee:	28 51       	subi	r18, 0x18	; 24
     ef0:	30 40       	sbci	r19, 0x00	; 0
     ef2:	81 e0       	ldi	r24, 0x01	; 1
     ef4:	90 e0       	ldi	r25, 0x00	; 0
     ef6:	02 2e       	mov	r0, r18
     ef8:	02 c0       	rjmp	.+4      	; 0xefe <DIO_SetPinDirection+0xec>
     efa:	88 0f       	add	r24, r24
     efc:	99 1f       	adc	r25, r25
     efe:	0a 94       	dec	r0
     f00:	e2 f7       	brpl	.-8      	; 0xefa <DIO_SetPinDirection+0xe8>
     f02:	84 2b       	or	r24, r20
     f04:	8c 93       	st	X, r24
     f06:	75 c0       	rjmp	.+234    	; 0xff2 <DIO_SetPinDirection+0x1e0>
		}
	}
	else if(PinDirection==0)
     f08:	8a 81       	ldd	r24, Y+2	; 0x02
     f0a:	88 23       	and	r24, r24
     f0c:	09 f0       	breq	.+2      	; 0xf10 <DIO_SetPinDirection+0xfe>
     f0e:	71 c0       	rjmp	.+226    	; 0xff2 <DIO_SetPinDirection+0x1e0>
	{
		if(PinNum>=PinA0&&PinNum<=PinA7)
     f10:	89 81       	ldd	r24, Y+1	; 0x01
     f12:	88 30       	cpi	r24, 0x08	; 8
     f14:	a8 f4       	brcc	.+42     	; 0xf40 <DIO_SetPinDirection+0x12e>
		{
			Clear_Bit(PORTA,PinNum);
     f16:	ab e3       	ldi	r26, 0x3B	; 59
     f18:	b0 e0       	ldi	r27, 0x00	; 0
     f1a:	eb e3       	ldi	r30, 0x3B	; 59
     f1c:	f0 e0       	ldi	r31, 0x00	; 0
     f1e:	80 81       	ld	r24, Z
     f20:	48 2f       	mov	r20, r24
     f22:	89 81       	ldd	r24, Y+1	; 0x01
     f24:	28 2f       	mov	r18, r24
     f26:	30 e0       	ldi	r19, 0x00	; 0
     f28:	81 e0       	ldi	r24, 0x01	; 1
     f2a:	90 e0       	ldi	r25, 0x00	; 0
     f2c:	02 2e       	mov	r0, r18
     f2e:	02 c0       	rjmp	.+4      	; 0xf34 <DIO_SetPinDirection+0x122>
     f30:	88 0f       	add	r24, r24
     f32:	99 1f       	adc	r25, r25
     f34:	0a 94       	dec	r0
     f36:	e2 f7       	brpl	.-8      	; 0xf30 <DIO_SetPinDirection+0x11e>
     f38:	80 95       	com	r24
     f3a:	84 23       	and	r24, r20
     f3c:	8c 93       	st	X, r24
     f3e:	59 c0       	rjmp	.+178    	; 0xff2 <DIO_SetPinDirection+0x1e0>
		}
		else if(PinNum>=PinB0&&PinNum<=PinB7)
     f40:	89 81       	ldd	r24, Y+1	; 0x01
     f42:	88 30       	cpi	r24, 0x08	; 8
     f44:	d8 f0       	brcs	.+54     	; 0xf7c <DIO_SetPinDirection+0x16a>
     f46:	89 81       	ldd	r24, Y+1	; 0x01
     f48:	80 31       	cpi	r24, 0x10	; 16
     f4a:	c0 f4       	brcc	.+48     	; 0xf7c <DIO_SetPinDirection+0x16a>
		{
			Clear_Bit(DDRB,(PinNum-8));
     f4c:	a7 e3       	ldi	r26, 0x37	; 55
     f4e:	b0 e0       	ldi	r27, 0x00	; 0
     f50:	e7 e3       	ldi	r30, 0x37	; 55
     f52:	f0 e0       	ldi	r31, 0x00	; 0
     f54:	80 81       	ld	r24, Z
     f56:	48 2f       	mov	r20, r24
     f58:	89 81       	ldd	r24, Y+1	; 0x01
     f5a:	88 2f       	mov	r24, r24
     f5c:	90 e0       	ldi	r25, 0x00	; 0
     f5e:	9c 01       	movw	r18, r24
     f60:	28 50       	subi	r18, 0x08	; 8
     f62:	30 40       	sbci	r19, 0x00	; 0
     f64:	81 e0       	ldi	r24, 0x01	; 1
     f66:	90 e0       	ldi	r25, 0x00	; 0
     f68:	02 2e       	mov	r0, r18
     f6a:	02 c0       	rjmp	.+4      	; 0xf70 <DIO_SetPinDirection+0x15e>
     f6c:	88 0f       	add	r24, r24
     f6e:	99 1f       	adc	r25, r25
     f70:	0a 94       	dec	r0
     f72:	e2 f7       	brpl	.-8      	; 0xf6c <DIO_SetPinDirection+0x15a>
     f74:	80 95       	com	r24
     f76:	84 23       	and	r24, r20
     f78:	8c 93       	st	X, r24
     f7a:	3b c0       	rjmp	.+118    	; 0xff2 <DIO_SetPinDirection+0x1e0>
		}
		else if(PinNum>=PinC0&&PinNum<=PinC7)
     f7c:	89 81       	ldd	r24, Y+1	; 0x01
     f7e:	80 31       	cpi	r24, 0x10	; 16
     f80:	d8 f0       	brcs	.+54     	; 0xfb8 <DIO_SetPinDirection+0x1a6>
     f82:	89 81       	ldd	r24, Y+1	; 0x01
     f84:	88 31       	cpi	r24, 0x18	; 24
     f86:	c0 f4       	brcc	.+48     	; 0xfb8 <DIO_SetPinDirection+0x1a6>
		{
			Clear_Bit(DDRC,(PinNum-16));
     f88:	a4 e3       	ldi	r26, 0x34	; 52
     f8a:	b0 e0       	ldi	r27, 0x00	; 0
     f8c:	e4 e3       	ldi	r30, 0x34	; 52
     f8e:	f0 e0       	ldi	r31, 0x00	; 0
     f90:	80 81       	ld	r24, Z
     f92:	48 2f       	mov	r20, r24
     f94:	89 81       	ldd	r24, Y+1	; 0x01
     f96:	88 2f       	mov	r24, r24
     f98:	90 e0       	ldi	r25, 0x00	; 0
     f9a:	9c 01       	movw	r18, r24
     f9c:	20 51       	subi	r18, 0x10	; 16
     f9e:	30 40       	sbci	r19, 0x00	; 0
     fa0:	81 e0       	ldi	r24, 0x01	; 1
     fa2:	90 e0       	ldi	r25, 0x00	; 0
     fa4:	02 2e       	mov	r0, r18
     fa6:	02 c0       	rjmp	.+4      	; 0xfac <DIO_SetPinDirection+0x19a>
     fa8:	88 0f       	add	r24, r24
     faa:	99 1f       	adc	r25, r25
     fac:	0a 94       	dec	r0
     fae:	e2 f7       	brpl	.-8      	; 0xfa8 <DIO_SetPinDirection+0x196>
     fb0:	80 95       	com	r24
     fb2:	84 23       	and	r24, r20
     fb4:	8c 93       	st	X, r24
     fb6:	1d c0       	rjmp	.+58     	; 0xff2 <DIO_SetPinDirection+0x1e0>
		}
		else if(PinNum>=PinD0&&PinNum<=PinD7)
     fb8:	89 81       	ldd	r24, Y+1	; 0x01
     fba:	88 31       	cpi	r24, 0x18	; 24
     fbc:	d0 f0       	brcs	.+52     	; 0xff2 <DIO_SetPinDirection+0x1e0>
     fbe:	89 81       	ldd	r24, Y+1	; 0x01
     fc0:	80 32       	cpi	r24, 0x20	; 32
     fc2:	b8 f4       	brcc	.+46     	; 0xff2 <DIO_SetPinDirection+0x1e0>
		{
			Clear_Bit(DDRD,(PinNum-24));
     fc4:	a1 e3       	ldi	r26, 0x31	; 49
     fc6:	b0 e0       	ldi	r27, 0x00	; 0
     fc8:	e1 e3       	ldi	r30, 0x31	; 49
     fca:	f0 e0       	ldi	r31, 0x00	; 0
     fcc:	80 81       	ld	r24, Z
     fce:	48 2f       	mov	r20, r24
     fd0:	89 81       	ldd	r24, Y+1	; 0x01
     fd2:	88 2f       	mov	r24, r24
     fd4:	90 e0       	ldi	r25, 0x00	; 0
     fd6:	9c 01       	movw	r18, r24
     fd8:	28 51       	subi	r18, 0x18	; 24
     fda:	30 40       	sbci	r19, 0x00	; 0
     fdc:	81 e0       	ldi	r24, 0x01	; 1
     fde:	90 e0       	ldi	r25, 0x00	; 0
     fe0:	02 2e       	mov	r0, r18
     fe2:	02 c0       	rjmp	.+4      	; 0xfe8 <DIO_SetPinDirection+0x1d6>
     fe4:	88 0f       	add	r24, r24
     fe6:	99 1f       	adc	r25, r25
     fe8:	0a 94       	dec	r0
     fea:	e2 f7       	brpl	.-8      	; 0xfe4 <DIO_SetPinDirection+0x1d2>
     fec:	80 95       	com	r24
     fee:	84 23       	and	r24, r20
     ff0:	8c 93       	st	X, r24
		}
	}
}
     ff2:	0f 90       	pop	r0
     ff4:	0f 90       	pop	r0
     ff6:	cf 91       	pop	r28
     ff8:	df 91       	pop	r29
     ffa:	08 95       	ret

00000ffc <LCD_INIT>:
#include "LCD.h"



void LCD_INIT(void)
{
     ffc:	df 93       	push	r29
     ffe:	cf 93       	push	r28
    1000:	cd b7       	in	r28, 0x3d	; 61
    1002:	de b7       	in	r29, 0x3e	; 62
	LCD_sendCommand(LCD_4_BIT_2_LINES_COMMAND);
	LCD_sendCommand(CURSOR_OFF);
	LCD_Clear();

#elif defined HIGHER_BITS
	DATA_DDR = 0xF0;
    1004:	ea e3       	ldi	r30, 0x3A	; 58
    1006:	f0 e0       	ldi	r31, 0x00	; 0
    1008:	80 ef       	ldi	r24, 0xF0	; 240
    100a:	80 83       	st	Z, r24
	Set_Bit(CONTROL_DDR,RS);
    100c:	aa e3       	ldi	r26, 0x3A	; 58
    100e:	b0 e0       	ldi	r27, 0x00	; 0
    1010:	ea e3       	ldi	r30, 0x3A	; 58
    1012:	f0 e0       	ldi	r31, 0x00	; 0
    1014:	80 81       	ld	r24, Z
    1016:	82 60       	ori	r24, 0x02	; 2
    1018:	8c 93       	st	X, r24
	Set_Bit(CONTROL_DDR,RW);
    101a:	aa e3       	ldi	r26, 0x3A	; 58
    101c:	b0 e0       	ldi	r27, 0x00	; 0
    101e:	ea e3       	ldi	r30, 0x3A	; 58
    1020:	f0 e0       	ldi	r31, 0x00	; 0
    1022:	80 81       	ld	r24, Z
    1024:	84 60       	ori	r24, 0x04	; 4
    1026:	8c 93       	st	X, r24
	Set_Bit(CONTROL_DDR,E);
    1028:	aa e3       	ldi	r26, 0x3A	; 58
    102a:	b0 e0       	ldi	r27, 0x00	; 0
    102c:	ea e3       	ldi	r30, 0x3A	; 58
    102e:	f0 e0       	ldi	r31, 0x00	; 0
    1030:	80 81       	ld	r24, Z
    1032:	88 60       	ori	r24, 0x08	; 8
    1034:	8c 93       	st	X, r24
	LCD_sendCommand(LCD_4_BIT_MODE);
    1036:	82 e0       	ldi	r24, 0x02	; 2
    1038:	0e 94 29 08 	call	0x1052	; 0x1052 <LCD_sendCommand>
	LCD_sendCommand(LCD_4_BIT_2_LINES_COMMAND);
    103c:	88 e2       	ldi	r24, 0x28	; 40
    103e:	0e 94 29 08 	call	0x1052	; 0x1052 <LCD_sendCommand>
	LCD_sendCommand(CURSOR_OFF);
    1042:	8c e0       	ldi	r24, 0x0C	; 12
    1044:	0e 94 29 08 	call	0x1052	; 0x1052 <LCD_sendCommand>
	LCD_Clear();
    1048:	0e 94 24 09 	call	0x1248	; 0x1248 <LCD_Clear>

#endif

#endif
}
    104c:	cf 91       	pop	r28
    104e:	df 91       	pop	r29
    1050:	08 95       	ret

00001052 <LCD_sendCommand>:


void LCD_sendCommand(const uint8 Command)
{
    1052:	df 93       	push	r29
    1054:	cf 93       	push	r28
    1056:	0f 92       	push	r0
    1058:	cd b7       	in	r28, 0x3d	; 61
    105a:	de b7       	in	r29, 0x3e	; 62
    105c:	89 83       	std	Y+1, r24	; 0x01
	Clear_Bit(CONTROL_PORT,E);
	vTaskDelay(1);;


#elif defined FOUR_BIT_MODE
	Clear_Bit(CONTROL_PORT,RS);
    105e:	ab e3       	ldi	r26, 0x3B	; 59
    1060:	b0 e0       	ldi	r27, 0x00	; 0
    1062:	eb e3       	ldi	r30, 0x3B	; 59
    1064:	f0 e0       	ldi	r31, 0x00	; 0
    1066:	80 81       	ld	r24, Z
    1068:	8d 7f       	andi	r24, 0xFD	; 253
    106a:	8c 93       	st	X, r24
	Clear_Bit(CONTROL_PORT,RW);
    106c:	ab e3       	ldi	r26, 0x3B	; 59
    106e:	b0 e0       	ldi	r27, 0x00	; 0
    1070:	eb e3       	ldi	r30, 0x3B	; 59
    1072:	f0 e0       	ldi	r31, 0x00	; 0
    1074:	80 81       	ld	r24, Z
    1076:	8b 7f       	andi	r24, 0xFB	; 251
    1078:	8c 93       	st	X, r24
	vTaskDelay(2);
    107a:	82 e0       	ldi	r24, 0x02	; 2
    107c:	90 e0       	ldi	r25, 0x00	; 0
    107e:	0e 94 e1 27 	call	0x4fc2	; 0x4fc2 <vTaskDelay>
	Set_Bit(CONTROL_PORT,E);
    1082:	ab e3       	ldi	r26, 0x3B	; 59
    1084:	b0 e0       	ldi	r27, 0x00	; 0
    1086:	eb e3       	ldi	r30, 0x3B	; 59
    1088:	f0 e0       	ldi	r31, 0x00	; 0
    108a:	80 81       	ld	r24, Z
    108c:	88 60       	ori	r24, 0x08	; 8
    108e:	8c 93       	st	X, r24
	vTaskDelay(2);
    1090:	82 e0       	ldi	r24, 0x02	; 2
    1092:	90 e0       	ldi	r25, 0x00	; 0
    1094:	0e 94 e1 27 	call	0x4fc2	; 0x4fc2 <vTaskDelay>
#ifdef LOWER_BITS
	DATA_PORT = (DATA_PORT & 0xF0) | ((0xF0 & Command)>>4);
#elif defined HIGHER_BITS
	DATA_PORT = (DATA_PORT & 0x0F) | (0xF0 & Command);
    1098:	ab e3       	ldi	r26, 0x3B	; 59
    109a:	b0 e0       	ldi	r27, 0x00	; 0
    109c:	eb e3       	ldi	r30, 0x3B	; 59
    109e:	f0 e0       	ldi	r31, 0x00	; 0
    10a0:	80 81       	ld	r24, Z
    10a2:	98 2f       	mov	r25, r24
    10a4:	9f 70       	andi	r25, 0x0F	; 15
    10a6:	89 81       	ldd	r24, Y+1	; 0x01
    10a8:	80 7f       	andi	r24, 0xF0	; 240
    10aa:	89 2b       	or	r24, r25
    10ac:	8c 93       	st	X, r24
#endif
	vTaskDelay(2);
    10ae:	82 e0       	ldi	r24, 0x02	; 2
    10b0:	90 e0       	ldi	r25, 0x00	; 0
    10b2:	0e 94 e1 27 	call	0x4fc2	; 0x4fc2 <vTaskDelay>
	Clear_Bit(CONTROL_PORT,E);
    10b6:	ab e3       	ldi	r26, 0x3B	; 59
    10b8:	b0 e0       	ldi	r27, 0x00	; 0
    10ba:	eb e3       	ldi	r30, 0x3B	; 59
    10bc:	f0 e0       	ldi	r31, 0x00	; 0
    10be:	80 81       	ld	r24, Z
    10c0:	87 7f       	andi	r24, 0xF7	; 247
    10c2:	8c 93       	st	X, r24
	vTaskDelay(2);
    10c4:	82 e0       	ldi	r24, 0x02	; 2
    10c6:	90 e0       	ldi	r25, 0x00	; 0
    10c8:	0e 94 e1 27 	call	0x4fc2	; 0x4fc2 <vTaskDelay>
	Set_Bit(CONTROL_PORT,E);
    10cc:	ab e3       	ldi	r26, 0x3B	; 59
    10ce:	b0 e0       	ldi	r27, 0x00	; 0
    10d0:	eb e3       	ldi	r30, 0x3B	; 59
    10d2:	f0 e0       	ldi	r31, 0x00	; 0
    10d4:	80 81       	ld	r24, Z
    10d6:	88 60       	ori	r24, 0x08	; 8
    10d8:	8c 93       	st	X, r24
	vTaskDelay(2);
    10da:	82 e0       	ldi	r24, 0x02	; 2
    10dc:	90 e0       	ldi	r25, 0x00	; 0
    10de:	0e 94 e1 27 	call	0x4fc2	; 0x4fc2 <vTaskDelay>
#ifdef LOWER_BITS
	DATA_PORT = (DATA_PORT & 0xF0) | (0x0F & Command);
#elif defined HIGHER_BITS
	DATA_PORT = (DATA_PORT & 0x0F) | ((0x0F & Command)<<4);
    10e2:	ab e3       	ldi	r26, 0x3B	; 59
    10e4:	b0 e0       	ldi	r27, 0x00	; 0
    10e6:	eb e3       	ldi	r30, 0x3B	; 59
    10e8:	f0 e0       	ldi	r31, 0x00	; 0
    10ea:	80 81       	ld	r24, Z
    10ec:	28 2f       	mov	r18, r24
    10ee:	2f 70       	andi	r18, 0x0F	; 15
    10f0:	89 81       	ldd	r24, Y+1	; 0x01
    10f2:	88 2f       	mov	r24, r24
    10f4:	90 e0       	ldi	r25, 0x00	; 0
    10f6:	82 95       	swap	r24
    10f8:	92 95       	swap	r25
    10fa:	90 7f       	andi	r25, 0xF0	; 240
    10fc:	98 27       	eor	r25, r24
    10fe:	80 7f       	andi	r24, 0xF0	; 240
    1100:	98 27       	eor	r25, r24
    1102:	82 2b       	or	r24, r18
    1104:	8c 93       	st	X, r24
#endif
	Clear_Bit(CONTROL_PORT,E);
    1106:	ab e3       	ldi	r26, 0x3B	; 59
    1108:	b0 e0       	ldi	r27, 0x00	; 0
    110a:	eb e3       	ldi	r30, 0x3B	; 59
    110c:	f0 e0       	ldi	r31, 0x00	; 0
    110e:	80 81       	ld	r24, Z
    1110:	87 7f       	andi	r24, 0xF7	; 247
    1112:	8c 93       	st	X, r24
	vTaskDelay(2);
    1114:	82 e0       	ldi	r24, 0x02	; 2
    1116:	90 e0       	ldi	r25, 0x00	; 0
    1118:	0e 94 e1 27 	call	0x4fc2	; 0x4fc2 <vTaskDelay>

#endif
}
    111c:	0f 90       	pop	r0
    111e:	cf 91       	pop	r28
    1120:	df 91       	pop	r29
    1122:	08 95       	ret

00001124 <LCD_sendChar>:


void LCD_sendChar(const char Char)
{
    1124:	df 93       	push	r29
    1126:	cf 93       	push	r28
    1128:	0f 92       	push	r0
    112a:	cd b7       	in	r28, 0x3d	; 61
    112c:	de b7       	in	r29, 0x3e	; 62
    112e:	89 83       	std	Y+1, r24	; 0x01
	Clear_Bit(CONTROL_PORT,E);
	vTaskDelay(1);;


#elif defined FOUR_BIT_MODE
	Set_Bit(CONTROL_PORT,RS);
    1130:	ab e3       	ldi	r26, 0x3B	; 59
    1132:	b0 e0       	ldi	r27, 0x00	; 0
    1134:	eb e3       	ldi	r30, 0x3B	; 59
    1136:	f0 e0       	ldi	r31, 0x00	; 0
    1138:	80 81       	ld	r24, Z
    113a:	82 60       	ori	r24, 0x02	; 2
    113c:	8c 93       	st	X, r24
	Clear_Bit(CONTROL_PORT,RW);
    113e:	ab e3       	ldi	r26, 0x3B	; 59
    1140:	b0 e0       	ldi	r27, 0x00	; 0
    1142:	eb e3       	ldi	r30, 0x3B	; 59
    1144:	f0 e0       	ldi	r31, 0x00	; 0
    1146:	80 81       	ld	r24, Z
    1148:	8b 7f       	andi	r24, 0xFB	; 251
    114a:	8c 93       	st	X, r24
	vTaskDelay(2);
    114c:	82 e0       	ldi	r24, 0x02	; 2
    114e:	90 e0       	ldi	r25, 0x00	; 0
    1150:	0e 94 e1 27 	call	0x4fc2	; 0x4fc2 <vTaskDelay>
	Set_Bit(CONTROL_PORT,E);
    1154:	ab e3       	ldi	r26, 0x3B	; 59
    1156:	b0 e0       	ldi	r27, 0x00	; 0
    1158:	eb e3       	ldi	r30, 0x3B	; 59
    115a:	f0 e0       	ldi	r31, 0x00	; 0
    115c:	80 81       	ld	r24, Z
    115e:	88 60       	ori	r24, 0x08	; 8
    1160:	8c 93       	st	X, r24
	vTaskDelay(2);
    1162:	82 e0       	ldi	r24, 0x02	; 2
    1164:	90 e0       	ldi	r25, 0x00	; 0
    1166:	0e 94 e1 27 	call	0x4fc2	; 0x4fc2 <vTaskDelay>
#ifdef LOWER_BITS
	DATA_PORT = (DATA_PORT & 0xF0) | ((0xF0 & Char) >> 4);
#elif defined HIGHER_BITS
	DATA_PORT = (DATA_PORT & 0x0F) | (0xF0 & Char);
    116a:	ab e3       	ldi	r26, 0x3B	; 59
    116c:	b0 e0       	ldi	r27, 0x00	; 0
    116e:	eb e3       	ldi	r30, 0x3B	; 59
    1170:	f0 e0       	ldi	r31, 0x00	; 0
    1172:	80 81       	ld	r24, Z
    1174:	98 2f       	mov	r25, r24
    1176:	9f 70       	andi	r25, 0x0F	; 15
    1178:	89 81       	ldd	r24, Y+1	; 0x01
    117a:	80 7f       	andi	r24, 0xF0	; 240
    117c:	89 2b       	or	r24, r25
    117e:	8c 93       	st	X, r24
#endif
	vTaskDelay(2);
    1180:	82 e0       	ldi	r24, 0x02	; 2
    1182:	90 e0       	ldi	r25, 0x00	; 0
    1184:	0e 94 e1 27 	call	0x4fc2	; 0x4fc2 <vTaskDelay>
	Clear_Bit(CONTROL_PORT,E);
    1188:	ab e3       	ldi	r26, 0x3B	; 59
    118a:	b0 e0       	ldi	r27, 0x00	; 0
    118c:	eb e3       	ldi	r30, 0x3B	; 59
    118e:	f0 e0       	ldi	r31, 0x00	; 0
    1190:	80 81       	ld	r24, Z
    1192:	87 7f       	andi	r24, 0xF7	; 247
    1194:	8c 93       	st	X, r24
	vTaskDelay(2);
    1196:	82 e0       	ldi	r24, 0x02	; 2
    1198:	90 e0       	ldi	r25, 0x00	; 0
    119a:	0e 94 e1 27 	call	0x4fc2	; 0x4fc2 <vTaskDelay>
	Set_Bit(CONTROL_PORT,E);
    119e:	ab e3       	ldi	r26, 0x3B	; 59
    11a0:	b0 e0       	ldi	r27, 0x00	; 0
    11a2:	eb e3       	ldi	r30, 0x3B	; 59
    11a4:	f0 e0       	ldi	r31, 0x00	; 0
    11a6:	80 81       	ld	r24, Z
    11a8:	88 60       	ori	r24, 0x08	; 8
    11aa:	8c 93       	st	X, r24
	vTaskDelay(2);
    11ac:	82 e0       	ldi	r24, 0x02	; 2
    11ae:	90 e0       	ldi	r25, 0x00	; 0
    11b0:	0e 94 e1 27 	call	0x4fc2	; 0x4fc2 <vTaskDelay>
#ifdef LOWER_BITS
	DATA_PORT = (DATA_PORT & 0xF0) | (0x0F & Char);
#elif defined HIGHER_BITS
	DATA_PORT = (DATA_PORT & 0x0F) | ((0x0F & Char) << 4);
    11b4:	ab e3       	ldi	r26, 0x3B	; 59
    11b6:	b0 e0       	ldi	r27, 0x00	; 0
    11b8:	eb e3       	ldi	r30, 0x3B	; 59
    11ba:	f0 e0       	ldi	r31, 0x00	; 0
    11bc:	80 81       	ld	r24, Z
    11be:	28 2f       	mov	r18, r24
    11c0:	2f 70       	andi	r18, 0x0F	; 15
    11c2:	89 81       	ldd	r24, Y+1	; 0x01
    11c4:	88 2f       	mov	r24, r24
    11c6:	90 e0       	ldi	r25, 0x00	; 0
    11c8:	82 95       	swap	r24
    11ca:	92 95       	swap	r25
    11cc:	90 7f       	andi	r25, 0xF0	; 240
    11ce:	98 27       	eor	r25, r24
    11d0:	80 7f       	andi	r24, 0xF0	; 240
    11d2:	98 27       	eor	r25, r24
    11d4:	82 2b       	or	r24, r18
    11d6:	8c 93       	st	X, r24
#endif
	Clear_Bit(CONTROL_PORT,E);
    11d8:	ab e3       	ldi	r26, 0x3B	; 59
    11da:	b0 e0       	ldi	r27, 0x00	; 0
    11dc:	eb e3       	ldi	r30, 0x3B	; 59
    11de:	f0 e0       	ldi	r31, 0x00	; 0
    11e0:	80 81       	ld	r24, Z
    11e2:	87 7f       	andi	r24, 0xF7	; 247
    11e4:	8c 93       	st	X, r24
	vTaskDelay(2);
    11e6:	82 e0       	ldi	r24, 0x02	; 2
    11e8:	90 e0       	ldi	r25, 0x00	; 0
    11ea:	0e 94 e1 27 	call	0x4fc2	; 0x4fc2 <vTaskDelay>

#endif

}
    11ee:	0f 90       	pop	r0
    11f0:	cf 91       	pop	r28
    11f2:	df 91       	pop	r29
    11f4:	08 95       	ret

000011f6 <LCD_sendString>:


void LCD_sendString(const char *str)
{
    11f6:	df 93       	push	r29
    11f8:	cf 93       	push	r28
    11fa:	00 d0       	rcall	.+0      	; 0x11fc <LCD_sendString+0x6>
    11fc:	0f 92       	push	r0
    11fe:	cd b7       	in	r28, 0x3d	; 61
    1200:	de b7       	in	r29, 0x3e	; 62
    1202:	9b 83       	std	Y+3, r25	; 0x03
    1204:	8a 83       	std	Y+2, r24	; 0x02
	uint8 i =0;
    1206:	19 82       	std	Y+1, r1	; 0x01
    1208:	0e c0       	rjmp	.+28     	; 0x1226 <LCD_sendString+0x30>
	while(str[i]!= '\0')
	{
		LCD_sendChar(str[i]);
    120a:	89 81       	ldd	r24, Y+1	; 0x01
    120c:	28 2f       	mov	r18, r24
    120e:	30 e0       	ldi	r19, 0x00	; 0
    1210:	8a 81       	ldd	r24, Y+2	; 0x02
    1212:	9b 81       	ldd	r25, Y+3	; 0x03
    1214:	fc 01       	movw	r30, r24
    1216:	e2 0f       	add	r30, r18
    1218:	f3 1f       	adc	r31, r19
    121a:	80 81       	ld	r24, Z
    121c:	0e 94 92 08 	call	0x1124	; 0x1124 <LCD_sendChar>
		i++;
    1220:	89 81       	ldd	r24, Y+1	; 0x01
    1222:	8f 5f       	subi	r24, 0xFF	; 255
    1224:	89 83       	std	Y+1, r24	; 0x01


void LCD_sendString(const char *str)
{
	uint8 i =0;
	while(str[i]!= '\0')
    1226:	89 81       	ldd	r24, Y+1	; 0x01
    1228:	28 2f       	mov	r18, r24
    122a:	30 e0       	ldi	r19, 0x00	; 0
    122c:	8a 81       	ldd	r24, Y+2	; 0x02
    122e:	9b 81       	ldd	r25, Y+3	; 0x03
    1230:	fc 01       	movw	r30, r24
    1232:	e2 0f       	add	r30, r18
    1234:	f3 1f       	adc	r31, r19
    1236:	80 81       	ld	r24, Z
    1238:	88 23       	and	r24, r24
    123a:	39 f7       	brne	.-50     	; 0x120a <LCD_sendString+0x14>
	{
		LCD_sendChar(str[i]);
		i++;
	}
}
    123c:	0f 90       	pop	r0
    123e:	0f 90       	pop	r0
    1240:	0f 90       	pop	r0
    1242:	cf 91       	pop	r28
    1244:	df 91       	pop	r29
    1246:	08 95       	ret

00001248 <LCD_Clear>:


void LCD_Clear(void)
{
    1248:	df 93       	push	r29
    124a:	cf 93       	push	r28
    124c:	cd b7       	in	r28, 0x3d	; 61
    124e:	de b7       	in	r29, 0x3e	; 62
	LCD_sendCommand(LCD_CLEAR); 
    1250:	81 e0       	ldi	r24, 0x01	; 1
    1252:	0e 94 29 08 	call	0x1052	; 0x1052 <LCD_sendCommand>
}
    1256:	cf 91       	pop	r28
    1258:	df 91       	pop	r29
    125a:	08 95       	ret

0000125c <LCD_IntToStr>:


void LCD_IntToStr(const uint16 data)
{
    125c:	df 93       	push	r29
    125e:	cf 93       	push	r28
    1260:	cd b7       	in	r28, 0x3d	; 61
    1262:	de b7       	in	r29, 0x3e	; 62
    1264:	62 97       	sbiw	r28, 0x12	; 18
    1266:	0f b6       	in	r0, 0x3f	; 63
    1268:	f8 94       	cli
    126a:	de bf       	out	0x3e, r29	; 62
    126c:	0f be       	out	0x3f, r0	; 63
    126e:	cd bf       	out	0x3d, r28	; 61
    1270:	9a 8b       	std	Y+18, r25	; 0x12
    1272:	89 8b       	std	Y+17, r24	; 0x11
	uint8 buff[16]; /* String to hold the ascii result */
	itoa(data,buff,10); /* 10 for decimal */
    1274:	89 89       	ldd	r24, Y+17	; 0x11
    1276:	9a 89       	ldd	r25, Y+18	; 0x12
    1278:	9e 01       	movw	r18, r28
    127a:	2f 5f       	subi	r18, 0xFF	; 255
    127c:	3f 4f       	sbci	r19, 0xFF	; 255
    127e:	b9 01       	movw	r22, r18
    1280:	4a e0       	ldi	r20, 0x0A	; 10
    1282:	50 e0       	ldi	r21, 0x00	; 0
    1284:	0e 94 23 33 	call	0x6646	; 0x6646 <itoa>
	LCD_sendString(buff);
    1288:	ce 01       	movw	r24, r28
    128a:	01 96       	adiw	r24, 0x01	; 1
    128c:	0e 94 fb 08 	call	0x11f6	; 0x11f6 <LCD_sendString>
}
    1290:	62 96       	adiw	r28, 0x12	; 18
    1292:	0f b6       	in	r0, 0x3f	; 63
    1294:	f8 94       	cli
    1296:	de bf       	out	0x3e, r29	; 62
    1298:	0f be       	out	0x3f, r0	; 63
    129a:	cd bf       	out	0x3d, r28	; 61
    129c:	cf 91       	pop	r28
    129e:	df 91       	pop	r29
    12a0:	08 95       	ret

000012a2 <LCD_goToRowColumn>:


void LCD_goToRowColumn(uint8 row,uint8 col)
{
    12a2:	df 93       	push	r29
    12a4:	cf 93       	push	r28
    12a6:	00 d0       	rcall	.+0      	; 0x12a8 <LCD_goToRowColumn+0x6>
    12a8:	00 d0       	rcall	.+0      	; 0x12aa <LCD_goToRowColumn+0x8>
    12aa:	0f 92       	push	r0
    12ac:	cd b7       	in	r28, 0x3d	; 61
    12ae:	de b7       	in	r29, 0x3e	; 62
    12b0:	8a 83       	std	Y+2, r24	; 0x02
    12b2:	6b 83       	std	Y+3, r22	; 0x03
	uint8 Address;

	/* first of all calculate the required address */
	switch(row)
    12b4:	8a 81       	ldd	r24, Y+2	; 0x02
    12b6:	28 2f       	mov	r18, r24
    12b8:	30 e0       	ldi	r19, 0x00	; 0
    12ba:	3d 83       	std	Y+5, r19	; 0x05
    12bc:	2c 83       	std	Y+4, r18	; 0x04
    12be:	8c 81       	ldd	r24, Y+4	; 0x04
    12c0:	9d 81       	ldd	r25, Y+5	; 0x05
    12c2:	81 30       	cpi	r24, 0x01	; 1
    12c4:	91 05       	cpc	r25, r1
    12c6:	c1 f0       	breq	.+48     	; 0x12f8 <LCD_goToRowColumn+0x56>
    12c8:	2c 81       	ldd	r18, Y+4	; 0x04
    12ca:	3d 81       	ldd	r19, Y+5	; 0x05
    12cc:	22 30       	cpi	r18, 0x02	; 2
    12ce:	31 05       	cpc	r19, r1
    12d0:	2c f4       	brge	.+10     	; 0x12dc <LCD_goToRowColumn+0x3a>
    12d2:	8c 81       	ldd	r24, Y+4	; 0x04
    12d4:	9d 81       	ldd	r25, Y+5	; 0x05
    12d6:	00 97       	sbiw	r24, 0x00	; 0
    12d8:	61 f0       	breq	.+24     	; 0x12f2 <LCD_goToRowColumn+0x50>
    12da:	19 c0       	rjmp	.+50     	; 0x130e <LCD_goToRowColumn+0x6c>
    12dc:	2c 81       	ldd	r18, Y+4	; 0x04
    12de:	3d 81       	ldd	r19, Y+5	; 0x05
    12e0:	22 30       	cpi	r18, 0x02	; 2
    12e2:	31 05       	cpc	r19, r1
    12e4:	69 f0       	breq	.+26     	; 0x1300 <LCD_goToRowColumn+0x5e>
    12e6:	8c 81       	ldd	r24, Y+4	; 0x04
    12e8:	9d 81       	ldd	r25, Y+5	; 0x05
    12ea:	83 30       	cpi	r24, 0x03	; 3
    12ec:	91 05       	cpc	r25, r1
    12ee:	61 f0       	breq	.+24     	; 0x1308 <LCD_goToRowColumn+0x66>
    12f0:	0e c0       	rjmp	.+28     	; 0x130e <LCD_goToRowColumn+0x6c>
	{
	case 0:
		Address=col;
    12f2:	8b 81       	ldd	r24, Y+3	; 0x03
    12f4:	89 83       	std	Y+1, r24	; 0x01
    12f6:	0b c0       	rjmp	.+22     	; 0x130e <LCD_goToRowColumn+0x6c>
		break;
	case 1:
		Address=col+0x40;
    12f8:	8b 81       	ldd	r24, Y+3	; 0x03
    12fa:	80 5c       	subi	r24, 0xC0	; 192
    12fc:	89 83       	std	Y+1, r24	; 0x01
    12fe:	07 c0       	rjmp	.+14     	; 0x130e <LCD_goToRowColumn+0x6c>
		break;
	case 2:
		Address=col+0x10;
    1300:	8b 81       	ldd	r24, Y+3	; 0x03
    1302:	80 5f       	subi	r24, 0xF0	; 240
    1304:	89 83       	std	Y+1, r24	; 0x01
    1306:	03 c0       	rjmp	.+6      	; 0x130e <LCD_goToRowColumn+0x6c>
		break;
	case 3:
		Address=col+0x50;
    1308:	8b 81       	ldd	r24, Y+3	; 0x03
    130a:	80 5b       	subi	r24, 0xB0	; 176
    130c:	89 83       	std	Y+1, r24	; 0x01
		break;
	}
	/* to write to a specific address in the LCD
	 * we need to apply the corresponding command 0b10000000+Address */
	LCD_sendCommand(Address | SET_CURSOR_LOCATION);
    130e:	89 81       	ldd	r24, Y+1	; 0x01
    1310:	80 68       	ori	r24, 0x80	; 128
    1312:	0e 94 29 08 	call	0x1052	; 0x1052 <LCD_sendCommand>
}
    1316:	0f 90       	pop	r0
    1318:	0f 90       	pop	r0
    131a:	0f 90       	pop	r0
    131c:	0f 90       	pop	r0
    131e:	0f 90       	pop	r0
    1320:	cf 91       	pop	r28
    1322:	df 91       	pop	r29
    1324:	08 95       	ret

00001326 <LCD_displayStringRowColumn>:

void LCD_displayStringRowColumn(uint8 row,uint8 col,const uint8 *Str)
{
    1326:	df 93       	push	r29
    1328:	cf 93       	push	r28
    132a:	00 d0       	rcall	.+0      	; 0x132c <LCD_displayStringRowColumn+0x6>
    132c:	00 d0       	rcall	.+0      	; 0x132e <LCD_displayStringRowColumn+0x8>
    132e:	cd b7       	in	r28, 0x3d	; 61
    1330:	de b7       	in	r29, 0x3e	; 62
    1332:	89 83       	std	Y+1, r24	; 0x01
    1334:	6a 83       	std	Y+2, r22	; 0x02
    1336:	5c 83       	std	Y+4, r21	; 0x04
    1338:	4b 83       	std	Y+3, r20	; 0x03
	LCD_goToRowColumn(row,col); /* go to to the required LCD position */
    133a:	89 81       	ldd	r24, Y+1	; 0x01
    133c:	6a 81       	ldd	r22, Y+2	; 0x02
    133e:	0e 94 51 09 	call	0x12a2	; 0x12a2 <LCD_goToRowColumn>
	LCD_sendString(Str); /* display the string */
    1342:	8b 81       	ldd	r24, Y+3	; 0x03
    1344:	9c 81       	ldd	r25, Y+4	; 0x04
    1346:	0e 94 fb 08 	call	0x11f6	; 0x11f6 <LCD_sendString>
}
    134a:	0f 90       	pop	r0
    134c:	0f 90       	pop	r0
    134e:	0f 90       	pop	r0
    1350:	0f 90       	pop	r0
    1352:	cf 91       	pop	r28
    1354:	df 91       	pop	r29
    1356:	08 95       	ret

00001358 <BUTTON_Init>:
 */
#include "FreeRTOS.h"
#include "task.h"
#include "button.h"
void BUTTON_Init(uint8 button_num)
{
    1358:	df 93       	push	r29
    135a:	cf 93       	push	r28
    135c:	0f 92       	push	r0
    135e:	cd b7       	in	r28, 0x3d	; 61
    1360:	de b7       	in	r29, 0x3e	; 62
    1362:	89 83       	std	Y+1, r24	; 0x01
	if(button_num==1)
    1364:	89 81       	ldd	r24, Y+1	; 0x01
    1366:	81 30       	cpi	r24, 0x01	; 1
    1368:	49 f4       	brne	.+18     	; 0x137c <BUTTON_Init+0x24>
	{
	DIO_SetPinDirection(PinA0,INPUT);
    136a:	80 e0       	ldi	r24, 0x00	; 0
    136c:	60 e0       	ldi	r22, 0x00	; 0
    136e:	0e 94 09 07 	call	0xe12	; 0xe12 <DIO_SetPinDirection>
	DIO_WritePin(PinA0,HIGH);
    1372:	80 e0       	ldi	r24, 0x00	; 0
    1374:	61 e0       	ldi	r22, 0x01	; 1
    1376:	0e 94 a3 05 	call	0xb46	; 0xb46 <DIO_WritePin>
    137a:	0b c0       	rjmp	.+22     	; 0x1392 <BUTTON_Init+0x3a>
	}
	else if(button_num==2)
    137c:	89 81       	ldd	r24, Y+1	; 0x01
    137e:	82 30       	cpi	r24, 0x02	; 2
    1380:	41 f4       	brne	.+16     	; 0x1392 <BUTTON_Init+0x3a>
	{
	DIO_SetPinDirection(PinA1,INPUT);
    1382:	81 e0       	ldi	r24, 0x01	; 1
    1384:	60 e0       	ldi	r22, 0x00	; 0
    1386:	0e 94 09 07 	call	0xe12	; 0xe12 <DIO_SetPinDirection>
	DIO_WritePin(PinA1,HIGH);
    138a:	81 e0       	ldi	r24, 0x01	; 1
    138c:	61 e0       	ldi	r22, 0x01	; 1
    138e:	0e 94 a3 05 	call	0xb46	; 0xb46 <DIO_WritePin>
	}
}
    1392:	0f 90       	pop	r0
    1394:	cf 91       	pop	r28
    1396:	df 91       	pop	r29
    1398:	08 95       	ret

0000139a <BUTTON_GitButtonState>:
uint8 BUTTON_GitButtonState(uint8 button_num)
{
    139a:	df 93       	push	r29
    139c:	cf 93       	push	r28
    139e:	00 d0       	rcall	.+0      	; 0x13a0 <BUTTON_GitButtonState+0x6>
    13a0:	0f 92       	push	r0
    13a2:	cd b7       	in	r28, 0x3d	; 61
    13a4:	de b7       	in	r29, 0x3e	; 62
    13a6:	89 83       	std	Y+1, r24	; 0x01
	if(button_num==1)
    13a8:	89 81       	ldd	r24, Y+1	; 0x01
    13aa:	81 30       	cpi	r24, 0x01	; 1
    13ac:	29 f4       	brne	.+10     	; 0x13b8 <BUTTON_GitButtonState+0x1e>
	{
	return DIO_ReadPin(PinA0);
    13ae:	80 e0       	ldi	r24, 0x00	; 0
    13b0:	0e 94 98 06 	call	0xd30	; 0xd30 <DIO_ReadPin>
    13b4:	8a 83       	std	Y+2, r24	; 0x02
    13b6:	09 c0       	rjmp	.+18     	; 0x13ca <BUTTON_GitButtonState+0x30>
	}
	else if(button_num==2)
    13b8:	89 81       	ldd	r24, Y+1	; 0x01
    13ba:	82 30       	cpi	r24, 0x02	; 2
    13bc:	29 f4       	brne	.+10     	; 0x13c8 <BUTTON_GitButtonState+0x2e>
	{
	return DIO_ReadPin(PinA1);
    13be:	81 e0       	ldi	r24, 0x01	; 1
    13c0:	0e 94 98 06 	call	0xd30	; 0xd30 <DIO_ReadPin>
    13c4:	8a 83       	std	Y+2, r24	; 0x02
    13c6:	01 c0       	rjmp	.+2      	; 0x13ca <BUTTON_GitButtonState+0x30>
    13c8:	02 c0       	rjmp	.+4      	; 0x13ce <BUTTON_GitButtonState+0x34>
	}
}
    13ca:	8a 81       	ldd	r24, Y+2	; 0x02
    13cc:	8b 83       	std	Y+3, r24	; 0x03
    13ce:	8b 81       	ldd	r24, Y+3	; 0x03
    13d0:	0f 90       	pop	r0
    13d2:	0f 90       	pop	r0
    13d4:	0f 90       	pop	r0
    13d6:	cf 91       	pop	r28
    13d8:	df 91       	pop	r29
    13da:	08 95       	ret

000013dc <xEventGroupCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	EventGroupHandle_t xEventGroupCreate( void )
	{
    13dc:	df 93       	push	r29
    13de:	cf 93       	push	r28
    13e0:	00 d0       	rcall	.+0      	; 0x13e2 <xEventGroupCreate+0x6>
    13e2:	cd b7       	in	r28, 0x3d	; 61
    13e4:	de b7       	in	r29, 0x3e	; 62
		TickType_t alignment requirements the cast is safe.  In other cases,
		where the natural word size of the architecture is less than
		sizeof( TickType_t ), the TickType_t variables will be accessed in two
		or more reads operations, and the alignment requirements is only that
		of each individual read. */
		pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) ); /*lint !e9087 !e9079 see comment above. */
    13e6:	8b e0       	ldi	r24, 0x0B	; 11
    13e8:	90 e0       	ldi	r25, 0x00	; 0
    13ea:	0e 94 33 0d 	call	0x1a66	; 0x1a66 <pvPortMalloc>
    13ee:	9a 83       	std	Y+2, r25	; 0x02
    13f0:	89 83       	std	Y+1, r24	; 0x01

		if( pxEventBits != NULL )
    13f2:	89 81       	ldd	r24, Y+1	; 0x01
    13f4:	9a 81       	ldd	r25, Y+2	; 0x02
    13f6:	00 97       	sbiw	r24, 0x00	; 0
    13f8:	49 f0       	breq	.+18     	; 0x140c <xEventGroupCreate+0x30>
		{
			pxEventBits->uxEventBits = 0;
    13fa:	e9 81       	ldd	r30, Y+1	; 0x01
    13fc:	fa 81       	ldd	r31, Y+2	; 0x02
    13fe:	11 82       	std	Z+1, r1	; 0x01
    1400:	10 82       	st	Z, r1
			vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
    1402:	89 81       	ldd	r24, Y+1	; 0x01
    1404:	9a 81       	ldd	r25, Y+2	; 0x02
    1406:	02 96       	adiw	r24, 0x02	; 2
    1408:	0e 94 29 11 	call	0x2252	; 0x2252 <vListInitialise>
		else
		{
			traceEVENT_GROUP_CREATE_FAILED(); /*lint !e9063 Else branch only exists to allow tracing and does not generate code if trace macros are not defined. */
		}

		return pxEventBits;
    140c:	89 81       	ldd	r24, Y+1	; 0x01
    140e:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    1410:	0f 90       	pop	r0
    1412:	0f 90       	pop	r0
    1414:	cf 91       	pop	r28
    1416:	df 91       	pop	r29
    1418:	08 95       	ret

0000141a <xEventGroupSync>:

#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait )
{
    141a:	df 93       	push	r29
    141c:	cf 93       	push	r28
    141e:	cd b7       	in	r28, 0x3d	; 61
    1420:	de b7       	in	r29, 0x3e	; 62
    1422:	60 97       	sbiw	r28, 0x10	; 16
    1424:	0f b6       	in	r0, 0x3f	; 63
    1426:	f8 94       	cli
    1428:	de bf       	out	0x3e, r29	; 62
    142a:	0f be       	out	0x3f, r0	; 63
    142c:	cd bf       	out	0x3d, r28	; 61
    142e:	9a 87       	std	Y+10, r25	; 0x0a
    1430:	89 87       	std	Y+9, r24	; 0x09
    1432:	7c 87       	std	Y+12, r23	; 0x0c
    1434:	6b 87       	std	Y+11, r22	; 0x0b
    1436:	5e 87       	std	Y+14, r21	; 0x0e
    1438:	4d 87       	std	Y+13, r20	; 0x0d
    143a:	38 8b       	std	Y+16, r19	; 0x10
    143c:	2f 87       	std	Y+15, r18	; 0x0f
EventBits_t uxOriginalBitValue, uxReturn;
EventGroup_t *pxEventBits = xEventGroup;
    143e:	89 85       	ldd	r24, Y+9	; 0x09
    1440:	9a 85       	ldd	r25, Y+10	; 0x0a
    1442:	9c 83       	std	Y+4, r25	; 0x04
    1444:	8b 83       	std	Y+3, r24	; 0x03
BaseType_t xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
    1446:	19 82       	std	Y+1, r1	; 0x01
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
    1448:	0e 94 ae 29 	call	0x535c	; 0x535c <vTaskSuspendAll>
	{
		uxOriginalBitValue = pxEventBits->uxEventBits;
    144c:	eb 81       	ldd	r30, Y+3	; 0x03
    144e:	fc 81       	ldd	r31, Y+4	; 0x04
    1450:	80 81       	ld	r24, Z
    1452:	91 81       	ldd	r25, Z+1	; 0x01
    1454:	98 87       	std	Y+8, r25	; 0x08
    1456:	8f 83       	std	Y+7, r24	; 0x07

		( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
    1458:	89 85       	ldd	r24, Y+9	; 0x09
    145a:	9a 85       	ldd	r25, Y+10	; 0x0a
    145c:	2b 85       	ldd	r18, Y+11	; 0x0b
    145e:	3c 85       	ldd	r19, Y+12	; 0x0c
    1460:	b9 01       	movw	r22, r18
    1462:	0e 94 e4 0b 	call	0x17c8	; 0x17c8 <xEventGroupSetBits>

		if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
    1466:	2f 81       	ldd	r18, Y+7	; 0x07
    1468:	38 85       	ldd	r19, Y+8	; 0x08
    146a:	8b 85       	ldd	r24, Y+11	; 0x0b
    146c:	9c 85       	ldd	r25, Y+12	; 0x0c
    146e:	28 2b       	or	r18, r24
    1470:	39 2b       	or	r19, r25
    1472:	8d 85       	ldd	r24, Y+13	; 0x0d
    1474:	9e 85       	ldd	r25, Y+14	; 0x0e
    1476:	28 23       	and	r18, r24
    1478:	39 23       	and	r19, r25
    147a:	8d 85       	ldd	r24, Y+13	; 0x0d
    147c:	9e 85       	ldd	r25, Y+14	; 0x0e
    147e:	28 17       	cp	r18, r24
    1480:	39 07       	cpc	r19, r25
    1482:	c9 f4       	brne	.+50     	; 0x14b6 <xEventGroupSync+0x9c>
		{
			/* All the rendezvous bits are now set - no need to block. */
			uxReturn = ( uxOriginalBitValue | uxBitsToSet );
    1484:	2f 81       	ldd	r18, Y+7	; 0x07
    1486:	38 85       	ldd	r19, Y+8	; 0x08
    1488:	8b 85       	ldd	r24, Y+11	; 0x0b
    148a:	9c 85       	ldd	r25, Y+12	; 0x0c
    148c:	82 2b       	or	r24, r18
    148e:	93 2b       	or	r25, r19
    1490:	9e 83       	std	Y+6, r25	; 0x06
    1492:	8d 83       	std	Y+5, r24	; 0x05

			/* Rendezvous always clear the bits.  They will have been cleared
			already unless this is the only task in the rendezvous. */
			pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    1494:	eb 81       	ldd	r30, Y+3	; 0x03
    1496:	fc 81       	ldd	r31, Y+4	; 0x04
    1498:	20 81       	ld	r18, Z
    149a:	31 81       	ldd	r19, Z+1	; 0x01
    149c:	8d 85       	ldd	r24, Y+13	; 0x0d
    149e:	9e 85       	ldd	r25, Y+14	; 0x0e
    14a0:	80 95       	com	r24
    14a2:	90 95       	com	r25
    14a4:	82 23       	and	r24, r18
    14a6:	93 23       	and	r25, r19
    14a8:	eb 81       	ldd	r30, Y+3	; 0x03
    14aa:	fc 81       	ldd	r31, Y+4	; 0x04
    14ac:	91 83       	std	Z+1, r25	; 0x01
    14ae:	80 83       	st	Z, r24

			xTicksToWait = 0;
    14b0:	18 8a       	std	Y+16, r1	; 0x10
    14b2:	1f 86       	std	Y+15, r1	; 0x0f
    14b4:	1e c0       	rjmp	.+60     	; 0x14f2 <xEventGroupSync+0xd8>
		}
		else
		{
			if( xTicksToWait != ( TickType_t ) 0 )
    14b6:	8f 85       	ldd	r24, Y+15	; 0x0f
    14b8:	98 89       	ldd	r25, Y+16	; 0x10
    14ba:	00 97       	sbiw	r24, 0x00	; 0
    14bc:	91 f0       	breq	.+36     	; 0x14e2 <xEventGroupSync+0xc8>
				traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );

				/* Store the bits that the calling task is waiting for in the
				task's event list item so the kernel knows when a match is
				found.  Then enter the blocked state. */
				vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
    14be:	8b 81       	ldd	r24, Y+3	; 0x03
    14c0:	9c 81       	ldd	r25, Y+4	; 0x04
    14c2:	bc 01       	movw	r22, r24
    14c4:	6e 5f       	subi	r22, 0xFE	; 254
    14c6:	7f 4f       	sbci	r23, 0xFF	; 255
    14c8:	8d 85       	ldd	r24, Y+13	; 0x0d
    14ca:	9e 85       	ldd	r25, Y+14	; 0x0e
    14cc:	9c 01       	movw	r18, r24
    14ce:	35 60       	ori	r19, 0x05	; 5
    14d0:	4f 85       	ldd	r20, Y+15	; 0x0f
    14d2:	58 89       	ldd	r21, Y+16	; 0x10
    14d4:	cb 01       	movw	r24, r22
    14d6:	b9 01       	movw	r22, r18
    14d8:	0e 94 1e 2c 	call	0x583c	; 0x583c <vTaskPlaceOnUnorderedEventList>

				/* This assignment is obsolete as uxReturn will get set after
				the task unblocks, but some compilers mistakenly generate a
				warning about uxReturn being returned without being set if the
				assignment is omitted. */
				uxReturn = 0;
    14dc:	1e 82       	std	Y+6, r1	; 0x06
    14de:	1d 82       	std	Y+5, r1	; 0x05
    14e0:	08 c0       	rjmp	.+16     	; 0x14f2 <xEventGroupSync+0xd8>
			}
			else
			{
				/* The rendezvous bits were not set, but no block time was
				specified - just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
    14e2:	eb 81       	ldd	r30, Y+3	; 0x03
    14e4:	fc 81       	ldd	r31, Y+4	; 0x04
    14e6:	80 81       	ld	r24, Z
    14e8:	91 81       	ldd	r25, Z+1	; 0x01
    14ea:	9e 83       	std	Y+6, r25	; 0x06
    14ec:	8d 83       	std	Y+5, r24	; 0x05
				xTimeoutOccurred = pdTRUE;
    14ee:	81 e0       	ldi	r24, 0x01	; 1
    14f0:	89 83       	std	Y+1, r24	; 0x01
			}
		}
	}
	xAlreadyYielded = xTaskResumeAll();
    14f2:	0e 94 ba 29 	call	0x5374	; 0x5374 <xTaskResumeAll>
    14f6:	8a 83       	std	Y+2, r24	; 0x02

	if( xTicksToWait != ( TickType_t ) 0 )
    14f8:	8f 85       	ldd	r24, Y+15	; 0x0f
    14fa:	98 89       	ldd	r25, Y+16	; 0x10
    14fc:	00 97       	sbiw	r24, 0x00	; 0
    14fe:	09 f4       	brne	.+2      	; 0x1502 <xEventGroupSync+0xe8>
    1500:	3a c0       	rjmp	.+116    	; 0x1576 <xEventGroupSync+0x15c>
	{
		if( xAlreadyYielded == pdFALSE )
    1502:	8a 81       	ldd	r24, Y+2	; 0x02
    1504:	88 23       	and	r24, r24
    1506:	11 f4       	brne	.+4      	; 0x150c <xEventGroupSync+0xf2>
		{
			portYIELD_WITHIN_API();
    1508:	0e 94 d8 15 	call	0x2bb0	; 0x2bb0 <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
    150c:	0e 94 91 2e 	call	0x5d22	; 0x5d22 <uxTaskResetEventItemValue>
    1510:	9e 83       	std	Y+6, r25	; 0x06
    1512:	8d 83       	std	Y+5, r24	; 0x05

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    1514:	8d 81       	ldd	r24, Y+5	; 0x05
    1516:	9e 81       	ldd	r25, Y+6	; 0x06
    1518:	80 70       	andi	r24, 0x00	; 0
    151a:	92 70       	andi	r25, 0x02	; 2
    151c:	00 97       	sbiw	r24, 0x00	; 0
    151e:	31 f5       	brne	.+76     	; 0x156c <xEventGroupSync+0x152>
		{
			/* The task timed out, just return the current event bit value. */
			taskENTER_CRITICAL();
    1520:	0f b6       	in	r0, 0x3f	; 63
    1522:	f8 94       	cli
    1524:	0f 92       	push	r0
			{
				uxReturn = pxEventBits->uxEventBits;
    1526:	eb 81       	ldd	r30, Y+3	; 0x03
    1528:	fc 81       	ldd	r31, Y+4	; 0x04
    152a:	80 81       	ld	r24, Z
    152c:	91 81       	ldd	r25, Z+1	; 0x01
    152e:	9e 83       	std	Y+6, r25	; 0x06
    1530:	8d 83       	std	Y+5, r24	; 0x05

				/* Although the task got here because it timed out before the
				bits it was waiting for were set, it is possible that since it
				unblocked another task has set the bits.  If this is the case
				then it needs to clear the bits before exiting. */
				if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
    1532:	2d 81       	ldd	r18, Y+5	; 0x05
    1534:	3e 81       	ldd	r19, Y+6	; 0x06
    1536:	8d 85       	ldd	r24, Y+13	; 0x0d
    1538:	9e 85       	ldd	r25, Y+14	; 0x0e
    153a:	28 23       	and	r18, r24
    153c:	39 23       	and	r19, r25
    153e:	8d 85       	ldd	r24, Y+13	; 0x0d
    1540:	9e 85       	ldd	r25, Y+14	; 0x0e
    1542:	28 17       	cp	r18, r24
    1544:	39 07       	cpc	r19, r25
    1546:	71 f4       	brne	.+28     	; 0x1564 <xEventGroupSync+0x14a>
				{
					pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    1548:	eb 81       	ldd	r30, Y+3	; 0x03
    154a:	fc 81       	ldd	r31, Y+4	; 0x04
    154c:	20 81       	ld	r18, Z
    154e:	31 81       	ldd	r19, Z+1	; 0x01
    1550:	8d 85       	ldd	r24, Y+13	; 0x0d
    1552:	9e 85       	ldd	r25, Y+14	; 0x0e
    1554:	80 95       	com	r24
    1556:	90 95       	com	r25
    1558:	82 23       	and	r24, r18
    155a:	93 23       	and	r25, r19
    155c:	eb 81       	ldd	r30, Y+3	; 0x03
    155e:	fc 81       	ldd	r31, Y+4	; 0x04
    1560:	91 83       	std	Z+1, r25	; 0x01
    1562:	80 83       	st	Z, r24
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
    1564:	0f 90       	pop	r0
    1566:	0f be       	out	0x3f, r0	; 63

			xTimeoutOccurred = pdTRUE;
    1568:	81 e0       	ldi	r24, 0x01	; 1
    156a:	89 83       	std	Y+1, r24	; 0x01
			/* The task unblocked because the bits were set. */
		}

		/* Control bits might be set as the task had blocked should not be
		returned. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    156c:	8d 81       	ldd	r24, Y+5	; 0x05
    156e:	9e 81       	ldd	r25, Y+6	; 0x06
    1570:	90 70       	andi	r25, 0x00	; 0
    1572:	9e 83       	std	Y+6, r25	; 0x06
    1574:	8d 83       	std	Y+5, r24	; 0x05
	traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );

	/* Prevent compiler warnings when trace macros are not used. */
	( void ) xTimeoutOccurred;

	return uxReturn;
    1576:	8d 81       	ldd	r24, Y+5	; 0x05
    1578:	9e 81       	ldd	r25, Y+6	; 0x06
}
    157a:	60 96       	adiw	r28, 0x10	; 16
    157c:	0f b6       	in	r0, 0x3f	; 63
    157e:	f8 94       	cli
    1580:	de bf       	out	0x3e, r29	; 62
    1582:	0f be       	out	0x3f, r0	; 63
    1584:	cd bf       	out	0x3d, r28	; 61
    1586:	cf 91       	pop	r28
    1588:	df 91       	pop	r29
    158a:	08 95       	ret

0000158c <xEventGroupWaitBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
{
    158c:	0f 93       	push	r16
    158e:	1f 93       	push	r17
    1590:	df 93       	push	r29
    1592:	cf 93       	push	r28
    1594:	cd b7       	in	r28, 0x3d	; 61
    1596:	de b7       	in	r29, 0x3e	; 62
    1598:	63 97       	sbiw	r28, 0x13	; 19
    159a:	0f b6       	in	r0, 0x3f	; 63
    159c:	f8 94       	cli
    159e:	de bf       	out	0x3e, r29	; 62
    15a0:	0f be       	out	0x3f, r0	; 63
    15a2:	cd bf       	out	0x3d, r28	; 61
    15a4:	9d 87       	std	Y+13, r25	; 0x0d
    15a6:	8c 87       	std	Y+12, r24	; 0x0c
    15a8:	7f 87       	std	Y+15, r23	; 0x0f
    15aa:	6e 87       	std	Y+14, r22	; 0x0e
    15ac:	48 8b       	std	Y+16, r20	; 0x10
    15ae:	29 8b       	std	Y+17, r18	; 0x11
    15b0:	1b 8b       	std	Y+19, r17	; 0x13
    15b2:	0a 8b       	std	Y+18, r16	; 0x12
EventGroup_t *pxEventBits = xEventGroup;
    15b4:	8c 85       	ldd	r24, Y+12	; 0x0c
    15b6:	9d 85       	ldd	r25, Y+13	; 0x0d
    15b8:	9b 87       	std	Y+11, r25	; 0x0b
    15ba:	8a 87       	std	Y+10, r24	; 0x0a
EventBits_t uxReturn, uxControlBits = 0;
    15bc:	1f 82       	std	Y+7, r1	; 0x07
    15be:	1e 82       	std	Y+6, r1	; 0x06
BaseType_t xWaitConditionMet, xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
    15c0:	1b 82       	std	Y+3, r1	; 0x03
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
    15c2:	0e 94 ae 29 	call	0x535c	; 0x535c <vTaskSuspendAll>
	{
		const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
    15c6:	ea 85       	ldd	r30, Y+10	; 0x0a
    15c8:	fb 85       	ldd	r31, Y+11	; 0x0b
    15ca:	80 81       	ld	r24, Z
    15cc:	91 81       	ldd	r25, Z+1	; 0x01
    15ce:	9a 83       	std	Y+2, r25	; 0x02
    15d0:	89 83       	std	Y+1, r24	; 0x01

		/* Check to see if the wait condition is already met or not. */
		xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
    15d2:	89 81       	ldd	r24, Y+1	; 0x01
    15d4:	9a 81       	ldd	r25, Y+2	; 0x02
    15d6:	2e 85       	ldd	r18, Y+14	; 0x0e
    15d8:	3f 85       	ldd	r19, Y+15	; 0x0f
    15da:	b9 01       	movw	r22, r18
    15dc:	49 89       	ldd	r20, Y+17	; 0x11
    15de:	0e 94 01 0d 	call	0x1a02	; 0x1a02 <prvTestWaitCondition>
    15e2:	8d 83       	std	Y+5, r24	; 0x05

		if( xWaitConditionMet != pdFALSE )
    15e4:	8d 81       	ldd	r24, Y+5	; 0x05
    15e6:	88 23       	and	r24, r24
    15e8:	c1 f0       	breq	.+48     	; 0x161a <xEventGroupWaitBits+0x8e>
		{
			/* The wait condition has already been met so there is no need to
			block. */
			uxReturn = uxCurrentEventBits;
    15ea:	89 81       	ldd	r24, Y+1	; 0x01
    15ec:	9a 81       	ldd	r25, Y+2	; 0x02
    15ee:	99 87       	std	Y+9, r25	; 0x09
    15f0:	88 87       	std	Y+8, r24	; 0x08
			xTicksToWait = ( TickType_t ) 0;
    15f2:	1b 8a       	std	Y+19, r1	; 0x13
    15f4:	1a 8a       	std	Y+18, r1	; 0x12

			/* Clear the wait bits if requested to do so. */
			if( xClearOnExit != pdFALSE )
    15f6:	88 89       	ldd	r24, Y+16	; 0x10
    15f8:	88 23       	and	r24, r24
    15fa:	e9 f1       	breq	.+122    	; 0x1676 <xEventGroupWaitBits+0xea>
			{
				pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    15fc:	ea 85       	ldd	r30, Y+10	; 0x0a
    15fe:	fb 85       	ldd	r31, Y+11	; 0x0b
    1600:	20 81       	ld	r18, Z
    1602:	31 81       	ldd	r19, Z+1	; 0x01
    1604:	8e 85       	ldd	r24, Y+14	; 0x0e
    1606:	9f 85       	ldd	r25, Y+15	; 0x0f
    1608:	80 95       	com	r24
    160a:	90 95       	com	r25
    160c:	82 23       	and	r24, r18
    160e:	93 23       	and	r25, r19
    1610:	ea 85       	ldd	r30, Y+10	; 0x0a
    1612:	fb 85       	ldd	r31, Y+11	; 0x0b
    1614:	91 83       	std	Z+1, r25	; 0x01
    1616:	80 83       	st	Z, r24
    1618:	2e c0       	rjmp	.+92     	; 0x1676 <xEventGroupWaitBits+0xea>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		else if( xTicksToWait == ( TickType_t ) 0 )
    161a:	8a 89       	ldd	r24, Y+18	; 0x12
    161c:	9b 89       	ldd	r25, Y+19	; 0x13
    161e:	00 97       	sbiw	r24, 0x00	; 0
    1620:	39 f4       	brne	.+14     	; 0x1630 <xEventGroupWaitBits+0xa4>
		{
			/* The wait condition has not been met, but no block time was
			specified, so just return the current value. */
			uxReturn = uxCurrentEventBits;
    1622:	89 81       	ldd	r24, Y+1	; 0x01
    1624:	9a 81       	ldd	r25, Y+2	; 0x02
    1626:	99 87       	std	Y+9, r25	; 0x09
    1628:	88 87       	std	Y+8, r24	; 0x08
			xTimeoutOccurred = pdTRUE;
    162a:	81 e0       	ldi	r24, 0x01	; 1
    162c:	8b 83       	std	Y+3, r24	; 0x03
    162e:	23 c0       	rjmp	.+70     	; 0x1676 <xEventGroupWaitBits+0xea>
		{
			/* The task is going to block to wait for its required bits to be
			set.  uxControlBits are used to remember the specified behaviour of
			this call to xEventGroupWaitBits() - for use when the event bits
			unblock the task. */
			if( xClearOnExit != pdFALSE )
    1630:	88 89       	ldd	r24, Y+16	; 0x10
    1632:	88 23       	and	r24, r24
    1634:	29 f0       	breq	.+10     	; 0x1640 <xEventGroupWaitBits+0xb4>
			{
				uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
    1636:	8e 81       	ldd	r24, Y+6	; 0x06
    1638:	9f 81       	ldd	r25, Y+7	; 0x07
    163a:	91 60       	ori	r25, 0x01	; 1
    163c:	9f 83       	std	Y+7, r25	; 0x07
    163e:	8e 83       	std	Y+6, r24	; 0x06
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( xWaitForAllBits != pdFALSE )
    1640:	89 89       	ldd	r24, Y+17	; 0x11
    1642:	88 23       	and	r24, r24
    1644:	29 f0       	breq	.+10     	; 0x1650 <xEventGroupWaitBits+0xc4>
			{
				uxControlBits |= eventWAIT_FOR_ALL_BITS;
    1646:	8e 81       	ldd	r24, Y+6	; 0x06
    1648:	9f 81       	ldd	r25, Y+7	; 0x07
    164a:	94 60       	ori	r25, 0x04	; 4
    164c:	9f 83       	std	Y+7, r25	; 0x07
    164e:	8e 83       	std	Y+6, r24	; 0x06
			}

			/* Store the bits that the calling task is waiting for in the
			task's event list item so the kernel knows when a match is
			found.  Then enter the blocked state. */
			vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
    1650:	8a 85       	ldd	r24, Y+10	; 0x0a
    1652:	9b 85       	ldd	r25, Y+11	; 0x0b
    1654:	bc 01       	movw	r22, r24
    1656:	6e 5f       	subi	r22, 0xFE	; 254
    1658:	7f 4f       	sbci	r23, 0xFF	; 255
    165a:	2e 85       	ldd	r18, Y+14	; 0x0e
    165c:	3f 85       	ldd	r19, Y+15	; 0x0f
    165e:	8e 81       	ldd	r24, Y+6	; 0x06
    1660:	9f 81       	ldd	r25, Y+7	; 0x07
    1662:	28 2b       	or	r18, r24
    1664:	39 2b       	or	r19, r25
    1666:	4a 89       	ldd	r20, Y+18	; 0x12
    1668:	5b 89       	ldd	r21, Y+19	; 0x13
    166a:	cb 01       	movw	r24, r22
    166c:	b9 01       	movw	r22, r18
    166e:	0e 94 1e 2c 	call	0x583c	; 0x583c <vTaskPlaceOnUnorderedEventList>

			/* This is obsolete as it will get set after the task unblocks, but
			some compilers mistakenly generate a warning about the variable
			being returned without being set if it is not done. */
			uxReturn = 0;
    1672:	19 86       	std	Y+9, r1	; 0x09
    1674:	18 86       	std	Y+8, r1	; 0x08

			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
		}
	}
	xAlreadyYielded = xTaskResumeAll();
    1676:	0e 94 ba 29 	call	0x5374	; 0x5374 <xTaskResumeAll>
    167a:	8c 83       	std	Y+4, r24	; 0x04

	if( xTicksToWait != ( TickType_t ) 0 )
    167c:	8a 89       	ldd	r24, Y+18	; 0x12
    167e:	9b 89       	ldd	r25, Y+19	; 0x13
    1680:	00 97       	sbiw	r24, 0x00	; 0
    1682:	09 f4       	brne	.+2      	; 0x1686 <xEventGroupWaitBits+0xfa>
    1684:	3c c0       	rjmp	.+120    	; 0x16fe <xEventGroupWaitBits+0x172>
	{
		if( xAlreadyYielded == pdFALSE )
    1686:	8c 81       	ldd	r24, Y+4	; 0x04
    1688:	88 23       	and	r24, r24
    168a:	11 f4       	brne	.+4      	; 0x1690 <xEventGroupWaitBits+0x104>
		{
			portYIELD_WITHIN_API();
    168c:	0e 94 d8 15 	call	0x2bb0	; 0x2bb0 <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
    1690:	0e 94 91 2e 	call	0x5d22	; 0x5d22 <uxTaskResetEventItemValue>
    1694:	99 87       	std	Y+9, r25	; 0x09
    1696:	88 87       	std	Y+8, r24	; 0x08

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    1698:	88 85       	ldd	r24, Y+8	; 0x08
    169a:	99 85       	ldd	r25, Y+9	; 0x09
    169c:	80 70       	andi	r24, 0x00	; 0
    169e:	92 70       	andi	r25, 0x02	; 2
    16a0:	00 97       	sbiw	r24, 0x00	; 0
    16a2:	41 f5       	brne	.+80     	; 0x16f4 <xEventGroupWaitBits+0x168>
		{
			taskENTER_CRITICAL();
    16a4:	0f b6       	in	r0, 0x3f	; 63
    16a6:	f8 94       	cli
    16a8:	0f 92       	push	r0
			{
				/* The task timed out, just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
    16aa:	ea 85       	ldd	r30, Y+10	; 0x0a
    16ac:	fb 85       	ldd	r31, Y+11	; 0x0b
    16ae:	80 81       	ld	r24, Z
    16b0:	91 81       	ldd	r25, Z+1	; 0x01
    16b2:	99 87       	std	Y+9, r25	; 0x09
    16b4:	88 87       	std	Y+8, r24	; 0x08

				/* It is possible that the event bits were updated between this
				task leaving the Blocked state and running again. */
				if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
    16b6:	88 85       	ldd	r24, Y+8	; 0x08
    16b8:	99 85       	ldd	r25, Y+9	; 0x09
    16ba:	2e 85       	ldd	r18, Y+14	; 0x0e
    16bc:	3f 85       	ldd	r19, Y+15	; 0x0f
    16be:	b9 01       	movw	r22, r18
    16c0:	49 89       	ldd	r20, Y+17	; 0x11
    16c2:	0e 94 01 0d 	call	0x1a02	; 0x1a02 <prvTestWaitCondition>
    16c6:	88 23       	and	r24, r24
    16c8:	89 f0       	breq	.+34     	; 0x16ec <xEventGroupWaitBits+0x160>
				{
					if( xClearOnExit != pdFALSE )
    16ca:	88 89       	ldd	r24, Y+16	; 0x10
    16cc:	88 23       	and	r24, r24
    16ce:	71 f0       	breq	.+28     	; 0x16ec <xEventGroupWaitBits+0x160>
					{
						pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    16d0:	ea 85       	ldd	r30, Y+10	; 0x0a
    16d2:	fb 85       	ldd	r31, Y+11	; 0x0b
    16d4:	20 81       	ld	r18, Z
    16d6:	31 81       	ldd	r19, Z+1	; 0x01
    16d8:	8e 85       	ldd	r24, Y+14	; 0x0e
    16da:	9f 85       	ldd	r25, Y+15	; 0x0f
    16dc:	80 95       	com	r24
    16de:	90 95       	com	r25
    16e0:	82 23       	and	r24, r18
    16e2:	93 23       	and	r25, r19
    16e4:	ea 85       	ldd	r30, Y+10	; 0x0a
    16e6:	fb 85       	ldd	r31, Y+11	; 0x0b
    16e8:	91 83       	std	Z+1, r25	; 0x01
    16ea:	80 83       	st	Z, r24
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				xTimeoutOccurred = pdTRUE;
    16ec:	81 e0       	ldi	r24, 0x01	; 1
    16ee:	8b 83       	std	Y+3, r24	; 0x03
			}
			taskEXIT_CRITICAL();
    16f0:	0f 90       	pop	r0
    16f2:	0f be       	out	0x3f, r0	; 63
		{
			/* The task unblocked because the bits were set. */
		}

		/* The task blocked so control bits may have been set. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    16f4:	88 85       	ldd	r24, Y+8	; 0x08
    16f6:	99 85       	ldd	r25, Y+9	; 0x09
    16f8:	90 70       	andi	r25, 0x00	; 0
    16fa:	99 87       	std	Y+9, r25	; 0x09
    16fc:	88 87       	std	Y+8, r24	; 0x08
	traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );

	/* Prevent compiler warnings when trace macros are not used. */
	( void ) xTimeoutOccurred;

	return uxReturn;
    16fe:	88 85       	ldd	r24, Y+8	; 0x08
    1700:	99 85       	ldd	r25, Y+9	; 0x09
}
    1702:	63 96       	adiw	r28, 0x13	; 19
    1704:	0f b6       	in	r0, 0x3f	; 63
    1706:	f8 94       	cli
    1708:	de bf       	out	0x3e, r29	; 62
    170a:	0f be       	out	0x3f, r0	; 63
    170c:	cd bf       	out	0x3d, r28	; 61
    170e:	cf 91       	pop	r28
    1710:	df 91       	pop	r29
    1712:	1f 91       	pop	r17
    1714:	0f 91       	pop	r16
    1716:	08 95       	ret

00001718 <xEventGroupClearBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
{
    1718:	df 93       	push	r29
    171a:	cf 93       	push	r28
    171c:	cd b7       	in	r28, 0x3d	; 61
    171e:	de b7       	in	r29, 0x3e	; 62
    1720:	28 97       	sbiw	r28, 0x08	; 8
    1722:	0f b6       	in	r0, 0x3f	; 63
    1724:	f8 94       	cli
    1726:	de bf       	out	0x3e, r29	; 62
    1728:	0f be       	out	0x3f, r0	; 63
    172a:	cd bf       	out	0x3d, r28	; 61
    172c:	9e 83       	std	Y+6, r25	; 0x06
    172e:	8d 83       	std	Y+5, r24	; 0x05
    1730:	78 87       	std	Y+8, r23	; 0x08
    1732:	6f 83       	std	Y+7, r22	; 0x07
EventGroup_t *pxEventBits = xEventGroup;
    1734:	8d 81       	ldd	r24, Y+5	; 0x05
    1736:	9e 81       	ldd	r25, Y+6	; 0x06
    1738:	9c 83       	std	Y+4, r25	; 0x04
    173a:	8b 83       	std	Y+3, r24	; 0x03
	/* Check the user is not attempting to clear the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	taskENTER_CRITICAL();
    173c:	0f b6       	in	r0, 0x3f	; 63
    173e:	f8 94       	cli
    1740:	0f 92       	push	r0
	{
		traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

		/* The value returned is the event group value prior to the bits being
		cleared. */
		uxReturn = pxEventBits->uxEventBits;
    1742:	eb 81       	ldd	r30, Y+3	; 0x03
    1744:	fc 81       	ldd	r31, Y+4	; 0x04
    1746:	80 81       	ld	r24, Z
    1748:	91 81       	ldd	r25, Z+1	; 0x01
    174a:	9a 83       	std	Y+2, r25	; 0x02
    174c:	89 83       	std	Y+1, r24	; 0x01

		/* Clear the bits. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
    174e:	eb 81       	ldd	r30, Y+3	; 0x03
    1750:	fc 81       	ldd	r31, Y+4	; 0x04
    1752:	20 81       	ld	r18, Z
    1754:	31 81       	ldd	r19, Z+1	; 0x01
    1756:	8f 81       	ldd	r24, Y+7	; 0x07
    1758:	98 85       	ldd	r25, Y+8	; 0x08
    175a:	80 95       	com	r24
    175c:	90 95       	com	r25
    175e:	82 23       	and	r24, r18
    1760:	93 23       	and	r25, r19
    1762:	eb 81       	ldd	r30, Y+3	; 0x03
    1764:	fc 81       	ldd	r31, Y+4	; 0x04
    1766:	91 83       	std	Z+1, r25	; 0x01
    1768:	80 83       	st	Z, r24
	}
	taskEXIT_CRITICAL();
    176a:	0f 90       	pop	r0
    176c:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    176e:	89 81       	ldd	r24, Y+1	; 0x01
    1770:	9a 81       	ldd	r25, Y+2	; 0x02
}
    1772:	28 96       	adiw	r28, 0x08	; 8
    1774:	0f b6       	in	r0, 0x3f	; 63
    1776:	f8 94       	cli
    1778:	de bf       	out	0x3e, r29	; 62
    177a:	0f be       	out	0x3f, r0	; 63
    177c:	cd bf       	out	0x3d, r28	; 61
    177e:	cf 91       	pop	r28
    1780:	df 91       	pop	r29
    1782:	08 95       	ret

00001784 <xEventGroupGetBitsFromISR>:

#endif
/*-----------------------------------------------------------*/

EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
{
    1784:	df 93       	push	r29
    1786:	cf 93       	push	r28
    1788:	cd b7       	in	r28, 0x3d	; 61
    178a:	de b7       	in	r29, 0x3e	; 62
    178c:	27 97       	sbiw	r28, 0x07	; 7
    178e:	0f b6       	in	r0, 0x3f	; 63
    1790:	f8 94       	cli
    1792:	de bf       	out	0x3e, r29	; 62
    1794:	0f be       	out	0x3f, r0	; 63
    1796:	cd bf       	out	0x3d, r28	; 61
    1798:	9f 83       	std	Y+7, r25	; 0x07
    179a:	8e 83       	std	Y+6, r24	; 0x06
UBaseType_t uxSavedInterruptStatus;
EventGroup_t const * const pxEventBits = xEventGroup;
    179c:	8e 81       	ldd	r24, Y+6	; 0x06
    179e:	9f 81       	ldd	r25, Y+7	; 0x07
    17a0:	9c 83       	std	Y+4, r25	; 0x04
    17a2:	8b 83       	std	Y+3, r24	; 0x03
EventBits_t uxReturn;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    17a4:	1d 82       	std	Y+5, r1	; 0x05
	{
		uxReturn = pxEventBits->uxEventBits;
    17a6:	eb 81       	ldd	r30, Y+3	; 0x03
    17a8:	fc 81       	ldd	r31, Y+4	; 0x04
    17aa:	80 81       	ld	r24, Z
    17ac:	91 81       	ldd	r25, Z+1	; 0x01
    17ae:	9a 83       	std	Y+2, r25	; 0x02
    17b0:	89 83       	std	Y+1, r24	; 0x01
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return uxReturn;
    17b2:	89 81       	ldd	r24, Y+1	; 0x01
    17b4:	9a 81       	ldd	r25, Y+2	; 0x02
} /*lint !e818 EventGroupHandle_t is a typedef used in other functions to so can't be pointer to const. */
    17b6:	27 96       	adiw	r28, 0x07	; 7
    17b8:	0f b6       	in	r0, 0x3f	; 63
    17ba:	f8 94       	cli
    17bc:	de bf       	out	0x3e, r29	; 62
    17be:	0f be       	out	0x3f, r0	; 63
    17c0:	cd bf       	out	0x3d, r28	; 61
    17c2:	cf 91       	pop	r28
    17c4:	df 91       	pop	r29
    17c6:	08 95       	ret

000017c8 <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
    17c8:	df 93       	push	r29
    17ca:	cf 93       	push	r28
    17cc:	cd b7       	in	r28, 0x3d	; 61
    17ce:	de b7       	in	r29, 0x3e	; 62
    17d0:	65 97       	sbiw	r28, 0x15	; 21
    17d2:	0f b6       	in	r0, 0x3f	; 63
    17d4:	f8 94       	cli
    17d6:	de bf       	out	0x3e, r29	; 62
    17d8:	0f be       	out	0x3f, r0	; 63
    17da:	cd bf       	out	0x3d, r28	; 61
    17dc:	9b 8b       	std	Y+19, r25	; 0x13
    17de:	8a 8b       	std	Y+18, r24	; 0x12
    17e0:	7d 8b       	std	Y+21, r23	; 0x15
    17e2:	6c 8b       	std	Y+20, r22	; 0x14
ListItem_t *pxListItem, *pxNext;
ListItem_t const *pxListEnd;
List_t const * pxList;
EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
    17e4:	19 86       	std	Y+9, r1	; 0x09
    17e6:	18 86       	std	Y+8, r1	; 0x08
EventGroup_t *pxEventBits = xEventGroup;
    17e8:	8a 89       	ldd	r24, Y+18	; 0x12
    17ea:	9b 89       	ldd	r25, Y+19	; 0x13
    17ec:	9b 83       	std	Y+3, r25	; 0x03
    17ee:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xMatchFound = pdFALSE;
    17f0:	19 82       	std	Y+1, r1	; 0x01
	/* Check the user is not attempting to set the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	pxList = &( pxEventBits->xTasksWaitingForBits );
    17f2:	8a 81       	ldd	r24, Y+2	; 0x02
    17f4:	9b 81       	ldd	r25, Y+3	; 0x03
    17f6:	02 96       	adiw	r24, 0x02	; 2
    17f8:	9b 87       	std	Y+11, r25	; 0x0b
    17fa:	8a 87       	std	Y+10, r24	; 0x0a
	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    17fc:	8a 85       	ldd	r24, Y+10	; 0x0a
    17fe:	9b 85       	ldd	r25, Y+11	; 0x0b
    1800:	03 96       	adiw	r24, 0x03	; 3
    1802:	9d 87       	std	Y+13, r25	; 0x0d
    1804:	8c 87       	std	Y+12, r24	; 0x0c
	vTaskSuspendAll();
    1806:	0e 94 ae 29 	call	0x535c	; 0x535c <vTaskSuspendAll>
	{
		traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

		pxListItem = listGET_HEAD_ENTRY( pxList );
    180a:	ea 85       	ldd	r30, Y+10	; 0x0a
    180c:	fb 85       	ldd	r31, Y+11	; 0x0b
    180e:	85 81       	ldd	r24, Z+5	; 0x05
    1810:	96 81       	ldd	r25, Z+6	; 0x06
    1812:	99 8b       	std	Y+17, r25	; 0x11
    1814:	88 8b       	std	Y+16, r24	; 0x10

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;
    1816:	ea 81       	ldd	r30, Y+2	; 0x02
    1818:	fb 81       	ldd	r31, Y+3	; 0x03
    181a:	20 81       	ld	r18, Z
    181c:	31 81       	ldd	r19, Z+1	; 0x01
    181e:	8c 89       	ldd	r24, Y+20	; 0x14
    1820:	9d 89       	ldd	r25, Y+21	; 0x15
    1822:	82 2b       	or	r24, r18
    1824:	93 2b       	or	r25, r19
    1826:	ea 81       	ldd	r30, Y+2	; 0x02
    1828:	fb 81       	ldd	r31, Y+3	; 0x03
    182a:	91 83       	std	Z+1, r25	; 0x01
    182c:	80 83       	st	Z, r24
    182e:	59 c0       	rjmp	.+178    	; 0x18e2 <xEventGroupSetBits+0x11a>

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
		{
			pxNext = listGET_NEXT( pxListItem );
    1830:	e8 89       	ldd	r30, Y+16	; 0x10
    1832:	f9 89       	ldd	r31, Y+17	; 0x11
    1834:	82 81       	ldd	r24, Z+2	; 0x02
    1836:	93 81       	ldd	r25, Z+3	; 0x03
    1838:	9f 87       	std	Y+15, r25	; 0x0f
    183a:	8e 87       	std	Y+14, r24	; 0x0e
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
    183c:	e8 89       	ldd	r30, Y+16	; 0x10
    183e:	f9 89       	ldd	r31, Y+17	; 0x11
    1840:	80 81       	ld	r24, Z
    1842:	91 81       	ldd	r25, Z+1	; 0x01
    1844:	9f 83       	std	Y+7, r25	; 0x07
    1846:	8e 83       	std	Y+6, r24	; 0x06
			xMatchFound = pdFALSE;
    1848:	19 82       	std	Y+1, r1	; 0x01

			/* Split the bits waited for from the control bits. */
			uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
    184a:	8e 81       	ldd	r24, Y+6	; 0x06
    184c:	9f 81       	ldd	r25, Y+7	; 0x07
    184e:	80 70       	andi	r24, 0x00	; 0
    1850:	9d 83       	std	Y+5, r25	; 0x05
    1852:	8c 83       	std	Y+4, r24	; 0x04
			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
    1854:	8e 81       	ldd	r24, Y+6	; 0x06
    1856:	9f 81       	ldd	r25, Y+7	; 0x07
    1858:	90 70       	andi	r25, 0x00	; 0
    185a:	9f 83       	std	Y+7, r25	; 0x07
    185c:	8e 83       	std	Y+6, r24	; 0x06

			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
    185e:	8c 81       	ldd	r24, Y+4	; 0x04
    1860:	9d 81       	ldd	r25, Y+5	; 0x05
    1862:	80 70       	andi	r24, 0x00	; 0
    1864:	94 70       	andi	r25, 0x04	; 4
    1866:	00 97       	sbiw	r24, 0x00	; 0
    1868:	69 f4       	brne	.+26     	; 0x1884 <xEventGroupSetBits+0xbc>
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
    186a:	ea 81       	ldd	r30, Y+2	; 0x02
    186c:	fb 81       	ldd	r31, Y+3	; 0x03
    186e:	20 81       	ld	r18, Z
    1870:	31 81       	ldd	r19, Z+1	; 0x01
    1872:	8e 81       	ldd	r24, Y+6	; 0x06
    1874:	9f 81       	ldd	r25, Y+7	; 0x07
    1876:	82 23       	and	r24, r18
    1878:	93 23       	and	r25, r19
    187a:	00 97       	sbiw	r24, 0x00	; 0
    187c:	91 f0       	breq	.+36     	; 0x18a2 <xEventGroupSetBits+0xda>
				{
					xMatchFound = pdTRUE;
    187e:	81 e0       	ldi	r24, 0x01	; 1
    1880:	89 83       	std	Y+1, r24	; 0x01
    1882:	0f c0       	rjmp	.+30     	; 0x18a2 <xEventGroupSetBits+0xda>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
    1884:	ea 81       	ldd	r30, Y+2	; 0x02
    1886:	fb 81       	ldd	r31, Y+3	; 0x03
    1888:	20 81       	ld	r18, Z
    188a:	31 81       	ldd	r19, Z+1	; 0x01
    188c:	8e 81       	ldd	r24, Y+6	; 0x06
    188e:	9f 81       	ldd	r25, Y+7	; 0x07
    1890:	28 23       	and	r18, r24
    1892:	39 23       	and	r19, r25
    1894:	8e 81       	ldd	r24, Y+6	; 0x06
    1896:	9f 81       	ldd	r25, Y+7	; 0x07
    1898:	28 17       	cp	r18, r24
    189a:	39 07       	cpc	r19, r25
    189c:	11 f4       	brne	.+4      	; 0x18a2 <xEventGroupSetBits+0xda>
			{
				/* All bits are set. */
				xMatchFound = pdTRUE;
    189e:	81 e0       	ldi	r24, 0x01	; 1
    18a0:	89 83       	std	Y+1, r24	; 0x01
			else
			{
				/* Need all bits to be set, but not all the bits were set. */
			}

			if( xMatchFound != pdFALSE )
    18a2:	89 81       	ldd	r24, Y+1	; 0x01
    18a4:	88 23       	and	r24, r24
    18a6:	c9 f0       	breq	.+50     	; 0x18da <xEventGroupSetBits+0x112>
			{
				/* The bits match.  Should the bits be cleared on exit? */
				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
    18a8:	8c 81       	ldd	r24, Y+4	; 0x04
    18aa:	9d 81       	ldd	r25, Y+5	; 0x05
    18ac:	80 70       	andi	r24, 0x00	; 0
    18ae:	91 70       	andi	r25, 0x01	; 1
    18b0:	00 97       	sbiw	r24, 0x00	; 0
    18b2:	41 f0       	breq	.+16     	; 0x18c4 <xEventGroupSetBits+0xfc>
				{
					uxBitsToClear |= uxBitsWaitedFor;
    18b4:	88 85       	ldd	r24, Y+8	; 0x08
    18b6:	99 85       	ldd	r25, Y+9	; 0x09
    18b8:	2e 81       	ldd	r18, Y+6	; 0x06
    18ba:	3f 81       	ldd	r19, Y+7	; 0x07
    18bc:	82 2b       	or	r24, r18
    18be:	93 2b       	or	r25, r19
    18c0:	99 87       	std	Y+9, r25	; 0x09
    18c2:	88 87       	std	Y+8, r24	; 0x08
				/* Store the actual event flag value in the task's event list
				item before removing the task from the event list.  The
				eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
				that is was unblocked due to its required bits matching, rather
				than because it timed out. */
				vTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
    18c4:	ea 81       	ldd	r30, Y+2	; 0x02
    18c6:	fb 81       	ldd	r31, Y+3	; 0x03
    18c8:	80 81       	ld	r24, Z
    18ca:	91 81       	ldd	r25, Z+1	; 0x01
    18cc:	9c 01       	movw	r18, r24
    18ce:	32 60       	ori	r19, 0x02	; 2
    18d0:	88 89       	ldd	r24, Y+16	; 0x10
    18d2:	99 89       	ldd	r25, Y+17	; 0x11
    18d4:	b9 01       	movw	r22, r18
    18d6:	0e 94 b9 2c 	call	0x5972	; 0x5972 <vTaskRemoveFromUnorderedEventList>
			}

			/* Move onto the next list item.  Note pxListItem->pxNext is not
			used here as the list item may have been removed from the event list
			and inserted into the ready/pending reading list. */
			pxListItem = pxNext;
    18da:	8e 85       	ldd	r24, Y+14	; 0x0e
    18dc:	9f 85       	ldd	r25, Y+15	; 0x0f
    18de:	99 8b       	std	Y+17, r25	; 0x11
    18e0:	88 8b       	std	Y+16, r24	; 0x10

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
    18e2:	28 89       	ldd	r18, Y+16	; 0x10
    18e4:	39 89       	ldd	r19, Y+17	; 0x11
    18e6:	8c 85       	ldd	r24, Y+12	; 0x0c
    18e8:	9d 85       	ldd	r25, Y+13	; 0x0d
    18ea:	28 17       	cp	r18, r24
    18ec:	39 07       	cpc	r19, r25
    18ee:	09 f0       	breq	.+2      	; 0x18f2 <xEventGroupSetBits+0x12a>
    18f0:	9f cf       	rjmp	.-194    	; 0x1830 <xEventGroupSetBits+0x68>
			pxListItem = pxNext;
		}

		/* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
		bit was set in the control word. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
    18f2:	ea 81       	ldd	r30, Y+2	; 0x02
    18f4:	fb 81       	ldd	r31, Y+3	; 0x03
    18f6:	20 81       	ld	r18, Z
    18f8:	31 81       	ldd	r19, Z+1	; 0x01
    18fa:	88 85       	ldd	r24, Y+8	; 0x08
    18fc:	99 85       	ldd	r25, Y+9	; 0x09
    18fe:	80 95       	com	r24
    1900:	90 95       	com	r25
    1902:	82 23       	and	r24, r18
    1904:	93 23       	and	r25, r19
    1906:	ea 81       	ldd	r30, Y+2	; 0x02
    1908:	fb 81       	ldd	r31, Y+3	; 0x03
    190a:	91 83       	std	Z+1, r25	; 0x01
    190c:	80 83       	st	Z, r24
	}
	( void ) xTaskResumeAll();
    190e:	0e 94 ba 29 	call	0x5374	; 0x5374 <xTaskResumeAll>

	return pxEventBits->uxEventBits;
    1912:	ea 81       	ldd	r30, Y+2	; 0x02
    1914:	fb 81       	ldd	r31, Y+3	; 0x03
    1916:	80 81       	ld	r24, Z
    1918:	91 81       	ldd	r25, Z+1	; 0x01
}
    191a:	65 96       	adiw	r28, 0x15	; 21
    191c:	0f b6       	in	r0, 0x3f	; 63
    191e:	f8 94       	cli
    1920:	de bf       	out	0x3e, r29	; 62
    1922:	0f be       	out	0x3f, r0	; 63
    1924:	cd bf       	out	0x3d, r28	; 61
    1926:	cf 91       	pop	r28
    1928:	df 91       	pop	r29
    192a:	08 95       	ret

0000192c <vEventGroupDelete>:
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
    192c:	df 93       	push	r29
    192e:	cf 93       	push	r28
    1930:	00 d0       	rcall	.+0      	; 0x1932 <vEventGroupDelete+0x6>
    1932:	00 d0       	rcall	.+0      	; 0x1934 <vEventGroupDelete+0x8>
    1934:	00 d0       	rcall	.+0      	; 0x1936 <vEventGroupDelete+0xa>
    1936:	cd b7       	in	r28, 0x3d	; 61
    1938:	de b7       	in	r29, 0x3e	; 62
    193a:	9e 83       	std	Y+6, r25	; 0x06
    193c:	8d 83       	std	Y+5, r24	; 0x05
EventGroup_t *pxEventBits = xEventGroup;
    193e:	8d 81       	ldd	r24, Y+5	; 0x05
    1940:	9e 81       	ldd	r25, Y+6	; 0x06
    1942:	9c 83       	std	Y+4, r25	; 0x04
    1944:	8b 83       	std	Y+3, r24	; 0x03
const List_t *pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
    1946:	8b 81       	ldd	r24, Y+3	; 0x03
    1948:	9c 81       	ldd	r25, Y+4	; 0x04
    194a:	02 96       	adiw	r24, 0x02	; 2
    194c:	9a 83       	std	Y+2, r25	; 0x02
    194e:	89 83       	std	Y+1, r24	; 0x01

	vTaskSuspendAll();
    1950:	0e 94 ae 29 	call	0x535c	; 0x535c <vTaskSuspendAll>
    1954:	08 c0       	rjmp	.+16     	; 0x1966 <vEventGroupDelete+0x3a>
		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
		{
			/* Unblock the task, returning 0 as the event list is being deleted
			and cannot therefore have any bits set. */
			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
			vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
    1956:	e9 81       	ldd	r30, Y+1	; 0x01
    1958:	fa 81       	ldd	r31, Y+2	; 0x02
    195a:	85 81       	ldd	r24, Z+5	; 0x05
    195c:	96 81       	ldd	r25, Z+6	; 0x06
    195e:	60 e0       	ldi	r22, 0x00	; 0
    1960:	72 e0       	ldi	r23, 0x02	; 2
    1962:	0e 94 b9 2c 	call	0x5972	; 0x5972 <vTaskRemoveFromUnorderedEventList>

	vTaskSuspendAll();
	{
		traceEVENT_GROUP_DELETE( xEventGroup );

		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
    1966:	e9 81       	ldd	r30, Y+1	; 0x01
    1968:	fa 81       	ldd	r31, Y+2	; 0x02
    196a:	80 81       	ld	r24, Z
    196c:	88 23       	and	r24, r24
    196e:	99 f7       	brne	.-26     	; 0x1956 <vEventGroupDelete+0x2a>

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
		{
			/* The event group can only have been allocated dynamically - free
			it again. */
			vPortFree( pxEventBits );
    1970:	8b 81       	ldd	r24, Y+3	; 0x03
    1972:	9c 81       	ldd	r25, Y+4	; 0x04
    1974:	0e 94 89 0d 	call	0x1b12	; 0x1b12 <vPortFree>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
	( void ) xTaskResumeAll();
    1978:	0e 94 ba 29 	call	0x5374	; 0x5374 <xTaskResumeAll>
}
    197c:	26 96       	adiw	r28, 0x06	; 6
    197e:	0f b6       	in	r0, 0x3f	; 63
    1980:	f8 94       	cli
    1982:	de bf       	out	0x3e, r29	; 62
    1984:	0f be       	out	0x3f, r0	; 63
    1986:	cd bf       	out	0x3d, r28	; 61
    1988:	cf 91       	pop	r28
    198a:	df 91       	pop	r29
    198c:	08 95       	ret

0000198e <vEventGroupSetBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'set bits' command that was pended from
an interrupt. */
void vEventGroupSetBitsCallback( void *pvEventGroup, const uint32_t ulBitsToSet )
{
    198e:	df 93       	push	r29
    1990:	cf 93       	push	r28
    1992:	00 d0       	rcall	.+0      	; 0x1994 <vEventGroupSetBitsCallback+0x6>
    1994:	00 d0       	rcall	.+0      	; 0x1996 <vEventGroupSetBitsCallback+0x8>
    1996:	00 d0       	rcall	.+0      	; 0x1998 <vEventGroupSetBitsCallback+0xa>
    1998:	cd b7       	in	r28, 0x3d	; 61
    199a:	de b7       	in	r29, 0x3e	; 62
    199c:	9a 83       	std	Y+2, r25	; 0x02
    199e:	89 83       	std	Y+1, r24	; 0x01
    19a0:	4b 83       	std	Y+3, r20	; 0x03
    19a2:	5c 83       	std	Y+4, r21	; 0x04
    19a4:	6d 83       	std	Y+5, r22	; 0x05
    19a6:	7e 83       	std	Y+6, r23	; 0x06
	( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
    19a8:	89 81       	ldd	r24, Y+1	; 0x01
    19aa:	9a 81       	ldd	r25, Y+2	; 0x02
    19ac:	2b 81       	ldd	r18, Y+3	; 0x03
    19ae:	3c 81       	ldd	r19, Y+4	; 0x04
    19b0:	b9 01       	movw	r22, r18
    19b2:	0e 94 e4 0b 	call	0x17c8	; 0x17c8 <xEventGroupSetBits>
}
    19b6:	26 96       	adiw	r28, 0x06	; 6
    19b8:	0f b6       	in	r0, 0x3f	; 63
    19ba:	f8 94       	cli
    19bc:	de bf       	out	0x3e, r29	; 62
    19be:	0f be       	out	0x3f, r0	; 63
    19c0:	cd bf       	out	0x3d, r28	; 61
    19c2:	cf 91       	pop	r28
    19c4:	df 91       	pop	r29
    19c6:	08 95       	ret

000019c8 <vEventGroupClearBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'clear bits' command that was pended from
an interrupt. */
void vEventGroupClearBitsCallback( void *pvEventGroup, const uint32_t ulBitsToClear )
{
    19c8:	df 93       	push	r29
    19ca:	cf 93       	push	r28
    19cc:	00 d0       	rcall	.+0      	; 0x19ce <vEventGroupClearBitsCallback+0x6>
    19ce:	00 d0       	rcall	.+0      	; 0x19d0 <vEventGroupClearBitsCallback+0x8>
    19d0:	00 d0       	rcall	.+0      	; 0x19d2 <vEventGroupClearBitsCallback+0xa>
    19d2:	cd b7       	in	r28, 0x3d	; 61
    19d4:	de b7       	in	r29, 0x3e	; 62
    19d6:	9a 83       	std	Y+2, r25	; 0x02
    19d8:	89 83       	std	Y+1, r24	; 0x01
    19da:	4b 83       	std	Y+3, r20	; 0x03
    19dc:	5c 83       	std	Y+4, r21	; 0x04
    19de:	6d 83       	std	Y+5, r22	; 0x05
    19e0:	7e 83       	std	Y+6, r23	; 0x06
	( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
    19e2:	89 81       	ldd	r24, Y+1	; 0x01
    19e4:	9a 81       	ldd	r25, Y+2	; 0x02
    19e6:	2b 81       	ldd	r18, Y+3	; 0x03
    19e8:	3c 81       	ldd	r19, Y+4	; 0x04
    19ea:	b9 01       	movw	r22, r18
    19ec:	0e 94 8c 0b 	call	0x1718	; 0x1718 <xEventGroupClearBits>
}
    19f0:	26 96       	adiw	r28, 0x06	; 6
    19f2:	0f b6       	in	r0, 0x3f	; 63
    19f4:	f8 94       	cli
    19f6:	de bf       	out	0x3e, r29	; 62
    19f8:	0f be       	out	0x3f, r0	; 63
    19fa:	cd bf       	out	0x3d, r28	; 61
    19fc:	cf 91       	pop	r28
    19fe:	df 91       	pop	r29
    1a00:	08 95       	ret

00001a02 <prvTestWaitCondition>:
/*-----------------------------------------------------------*/

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
{
    1a02:	df 93       	push	r29
    1a04:	cf 93       	push	r28
    1a06:	00 d0       	rcall	.+0      	; 0x1a08 <prvTestWaitCondition+0x6>
    1a08:	00 d0       	rcall	.+0      	; 0x1a0a <prvTestWaitCondition+0x8>
    1a0a:	00 d0       	rcall	.+0      	; 0x1a0c <prvTestWaitCondition+0xa>
    1a0c:	cd b7       	in	r28, 0x3d	; 61
    1a0e:	de b7       	in	r29, 0x3e	; 62
    1a10:	9b 83       	std	Y+3, r25	; 0x03
    1a12:	8a 83       	std	Y+2, r24	; 0x02
    1a14:	7d 83       	std	Y+5, r23	; 0x05
    1a16:	6c 83       	std	Y+4, r22	; 0x04
    1a18:	4e 83       	std	Y+6, r20	; 0x06
BaseType_t xWaitConditionMet = pdFALSE;
    1a1a:	19 82       	std	Y+1, r1	; 0x01

	if( xWaitForAllBits == pdFALSE )
    1a1c:	8e 81       	ldd	r24, Y+6	; 0x06
    1a1e:	88 23       	and	r24, r24
    1a20:	59 f4       	brne	.+22     	; 0x1a38 <prvTestWaitCondition+0x36>
	{
		/* Task only has to wait for one bit within uxBitsToWaitFor to be
		set.  Is one already set? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
    1a22:	8a 81       	ldd	r24, Y+2	; 0x02
    1a24:	9b 81       	ldd	r25, Y+3	; 0x03
    1a26:	2c 81       	ldd	r18, Y+4	; 0x04
    1a28:	3d 81       	ldd	r19, Y+5	; 0x05
    1a2a:	82 23       	and	r24, r18
    1a2c:	93 23       	and	r25, r19
    1a2e:	00 97       	sbiw	r24, 0x00	; 0
    1a30:	81 f0       	breq	.+32     	; 0x1a52 <prvTestWaitCondition+0x50>
		{
			xWaitConditionMet = pdTRUE;
    1a32:	81 e0       	ldi	r24, 0x01	; 1
    1a34:	89 83       	std	Y+1, r24	; 0x01
    1a36:	0d c0       	rjmp	.+26     	; 0x1a52 <prvTestWaitCondition+0x50>
	}
	else
	{
		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
		Are they set already? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
    1a38:	2a 81       	ldd	r18, Y+2	; 0x02
    1a3a:	3b 81       	ldd	r19, Y+3	; 0x03
    1a3c:	8c 81       	ldd	r24, Y+4	; 0x04
    1a3e:	9d 81       	ldd	r25, Y+5	; 0x05
    1a40:	28 23       	and	r18, r24
    1a42:	39 23       	and	r19, r25
    1a44:	8c 81       	ldd	r24, Y+4	; 0x04
    1a46:	9d 81       	ldd	r25, Y+5	; 0x05
    1a48:	28 17       	cp	r18, r24
    1a4a:	39 07       	cpc	r19, r25
    1a4c:	11 f4       	brne	.+4      	; 0x1a52 <prvTestWaitCondition+0x50>
		{
			xWaitConditionMet = pdTRUE;
    1a4e:	81 e0       	ldi	r24, 0x01	; 1
    1a50:	89 83       	std	Y+1, r24	; 0x01
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xWaitConditionMet;
    1a52:	89 81       	ldd	r24, Y+1	; 0x01
}
    1a54:	26 96       	adiw	r28, 0x06	; 6
    1a56:	0f b6       	in	r0, 0x3f	; 63
    1a58:	f8 94       	cli
    1a5a:	de bf       	out	0x3e, r29	; 62
    1a5c:	0f be       	out	0x3f, r0	; 63
    1a5e:	cd bf       	out	0x3d, r28	; 61
    1a60:	cf 91       	pop	r28
    1a62:	df 91       	pop	r29
    1a64:	08 95       	ret

00001a66 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    1a66:	df 93       	push	r29
    1a68:	cf 93       	push	r28
    1a6a:	00 d0       	rcall	.+0      	; 0x1a6c <pvPortMalloc+0x6>
    1a6c:	00 d0       	rcall	.+0      	; 0x1a6e <pvPortMalloc+0x8>
    1a6e:	cd b7       	in	r28, 0x3d	; 61
    1a70:	de b7       	in	r29, 0x3e	; 62
    1a72:	9c 83       	std	Y+4, r25	; 0x04
    1a74:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL;
    1a76:	1a 82       	std	Y+2, r1	; 0x02
    1a78:	19 82       	std	Y+1, r1	; 0x01
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
    1a7a:	0e 94 ae 29 	call	0x535c	; 0x535c <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
    1a7e:	80 91 bc 00 	lds	r24, 0x00BC
    1a82:	90 91 bd 00 	lds	r25, 0x00BD
    1a86:	00 97       	sbiw	r24, 0x00	; 0
    1a88:	31 f4       	brne	.+12     	; 0x1a96 <pvPortMalloc+0x30>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
    1a8a:	8f eb       	ldi	r24, 0xBF	; 191
    1a8c:	90 e0       	ldi	r25, 0x00	; 0
    1a8e:	90 93 bd 00 	sts	0x00BD, r25
    1a92:	80 93 bc 00 	sts	0x00BC, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    1a96:	80 91 ba 00 	lds	r24, 0x00BA
    1a9a:	90 91 bb 00 	lds	r25, 0x00BB
    1a9e:	2b 81       	ldd	r18, Y+3	; 0x03
    1aa0:	3c 81       	ldd	r19, Y+4	; 0x04
    1aa2:	82 0f       	add	r24, r18
    1aa4:	93 1f       	adc	r25, r19
    1aa6:	25 e0       	ldi	r18, 0x05	; 5
    1aa8:	8b 3d       	cpi	r24, 0xDB	; 219
    1aaa:	92 07       	cpc	r25, r18
    1aac:	38 f5       	brcc	.+78     	; 0x1afc <pvPortMalloc+0x96>
    1aae:	20 91 ba 00 	lds	r18, 0x00BA
    1ab2:	30 91 bb 00 	lds	r19, 0x00BB
    1ab6:	8b 81       	ldd	r24, Y+3	; 0x03
    1ab8:	9c 81       	ldd	r25, Y+4	; 0x04
    1aba:	28 0f       	add	r18, r24
    1abc:	39 1f       	adc	r19, r25
    1abe:	80 91 ba 00 	lds	r24, 0x00BA
    1ac2:	90 91 bb 00 	lds	r25, 0x00BB
    1ac6:	82 17       	cp	r24, r18
    1ac8:	93 07       	cpc	r25, r19
    1aca:	c0 f4       	brcc	.+48     	; 0x1afc <pvPortMalloc+0x96>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
    1acc:	20 91 bc 00 	lds	r18, 0x00BC
    1ad0:	30 91 bd 00 	lds	r19, 0x00BD
    1ad4:	80 91 ba 00 	lds	r24, 0x00BA
    1ad8:	90 91 bb 00 	lds	r25, 0x00BB
    1adc:	82 0f       	add	r24, r18
    1ade:	93 1f       	adc	r25, r19
    1ae0:	9a 83       	std	Y+2, r25	; 0x02
    1ae2:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;
    1ae4:	20 91 ba 00 	lds	r18, 0x00BA
    1ae8:	30 91 bb 00 	lds	r19, 0x00BB
    1aec:	8b 81       	ldd	r24, Y+3	; 0x03
    1aee:	9c 81       	ldd	r25, Y+4	; 0x04
    1af0:	82 0f       	add	r24, r18
    1af2:	93 1f       	adc	r25, r19
    1af4:	90 93 bb 00 	sts	0x00BB, r25
    1af8:	80 93 ba 00 	sts	0x00BA, r24
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    1afc:	0e 94 ba 29 	call	0x5374	; 0x5374 <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
    1b00:	89 81       	ldd	r24, Y+1	; 0x01
    1b02:	9a 81       	ldd	r25, Y+2	; 0x02
}
    1b04:	0f 90       	pop	r0
    1b06:	0f 90       	pop	r0
    1b08:	0f 90       	pop	r0
    1b0a:	0f 90       	pop	r0
    1b0c:	cf 91       	pop	r28
    1b0e:	df 91       	pop	r29
    1b10:	08 95       	ret

00001b12 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    1b12:	df 93       	push	r29
    1b14:	cf 93       	push	r28
    1b16:	00 d0       	rcall	.+0      	; 0x1b18 <vPortFree+0x6>
    1b18:	cd b7       	in	r28, 0x3d	; 61
    1b1a:	de b7       	in	r29, 0x3e	; 62
    1b1c:	9a 83       	std	Y+2, r25	; 0x02
    1b1e:	89 83       	std	Y+1, r24	; 0x01
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
}
    1b20:	0f 90       	pop	r0
    1b22:	0f 90       	pop	r0
    1b24:	cf 91       	pop	r28
    1b26:	df 91       	pop	r29
    1b28:	08 95       	ret

00001b2a <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    1b2a:	df 93       	push	r29
    1b2c:	cf 93       	push	r28
    1b2e:	cd b7       	in	r28, 0x3d	; 61
    1b30:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    1b32:	10 92 bb 00 	sts	0x00BB, r1
    1b36:	10 92 ba 00 	sts	0x00BA, r1
}
    1b3a:	cf 91       	pop	r28
    1b3c:	df 91       	pop	r29
    1b3e:	08 95       	ret

00001b40 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    1b40:	df 93       	push	r29
    1b42:	cf 93       	push	r28
    1b44:	cd b7       	in	r28, 0x3d	; 61
    1b46:	de b7       	in	r29, 0x3e	; 62
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
    1b48:	20 91 ba 00 	lds	r18, 0x00BA
    1b4c:	30 91 bb 00 	lds	r19, 0x00BB
    1b50:	8b ed       	ldi	r24, 0xDB	; 219
    1b52:	95 e0       	ldi	r25, 0x05	; 5
    1b54:	82 1b       	sub	r24, r18
    1b56:	93 0b       	sbc	r25, r19
}
    1b58:	cf 91       	pop	r28
    1b5a:	df 91       	pop	r29
    1b5c:	08 95       	ret

00001b5e <KeyPad_init>:

/*******************************************************************************
 *                      Functions Definitions                                  *
 *******************************************************************************/
void KeyPad_init(void)
{
    1b5e:	df 93       	push	r29
    1b60:	cf 93       	push	r28
    1b62:	cd b7       	in	r28, 0x3d	; 61
    1b64:	de b7       	in	r29, 0x3e	; 62
	KEYPAD_PORT_DIR = (0b11100000u);
    1b66:	e4 e3       	ldi	r30, 0x34	; 52
    1b68:	f0 e0       	ldi	r31, 0x00	; 0
    1b6a:	80 ee       	ldi	r24, 0xE0	; 224
    1b6c:	80 83       	st	Z, r24
	KEYPAD_PORT_OUT = (~(0b11100000u));
    1b6e:	e5 e3       	ldi	r30, 0x35	; 53
    1b70:	f0 e0       	ldi	r31, 0x00	; 0
    1b72:	8f e1       	ldi	r24, 0x1F	; 31
    1b74:	80 83       	st	Z, r24
}
    1b76:	cf 91       	pop	r28
    1b78:	df 91       	pop	r29
    1b7a:	08 95       	ret

00001b7c <KeyPad_getPressedKey>:



uint8 KeyPad_getPressedKey(void)
{
    1b7c:	df 93       	push	r29
    1b7e:	cf 93       	push	r28
    1b80:	0f 92       	push	r0
    1b82:	cd b7       	in	r28, 0x3d	; 61
    1b84:	de b7       	in	r29, 0x3e	; 62
	for(col=0;col<N_col;col++) /* loop for columns */
    1b86:	10 92 10 07 	sts	0x0710, r1
    1b8a:	56 c0       	rjmp	.+172    	; 0x1c38 <KeyPad_getPressedKey+0xbc>
	{
		/*
		 * each time only one of the column pins will be output and
		 * the rest will be input pins include the row pins
		 */
		KEYPAD_PORT_DIR = (0b00100000<<col);
    1b8c:	e4 e3       	ldi	r30, 0x34	; 52
    1b8e:	f0 e0       	ldi	r31, 0x00	; 0
    1b90:	80 91 10 07 	lds	r24, 0x0710
    1b94:	28 2f       	mov	r18, r24
    1b96:	30 e0       	ldi	r19, 0x00	; 0
    1b98:	80 e2       	ldi	r24, 0x20	; 32
    1b9a:	90 e0       	ldi	r25, 0x00	; 0
    1b9c:	02 c0       	rjmp	.+4      	; 0x1ba2 <KeyPad_getPressedKey+0x26>
    1b9e:	88 0f       	add	r24, r24
    1ba0:	99 1f       	adc	r25, r25
    1ba2:	2a 95       	dec	r18
    1ba4:	e2 f7       	brpl	.-8      	; 0x1b9e <KeyPad_getPressedKey+0x22>
    1ba6:	80 83       	st	Z, r24

		/*
		 * clear the output pin column in this trace and enable the internal
		 * pull up resistors for the rows pins
		 */
		KEYPAD_PORT_OUT = (~(0b00100000<<col));
    1ba8:	e5 e3       	ldi	r30, 0x35	; 53
    1baa:	f0 e0       	ldi	r31, 0x00	; 0
    1bac:	80 91 10 07 	lds	r24, 0x0710
    1bb0:	28 2f       	mov	r18, r24
    1bb2:	30 e0       	ldi	r19, 0x00	; 0
    1bb4:	80 e2       	ldi	r24, 0x20	; 32
    1bb6:	90 e0       	ldi	r25, 0x00	; 0
    1bb8:	02 2e       	mov	r0, r18
    1bba:	02 c0       	rjmp	.+4      	; 0x1bc0 <KeyPad_getPressedKey+0x44>
    1bbc:	88 0f       	add	r24, r24
    1bbe:	99 1f       	adc	r25, r25
    1bc0:	0a 94       	dec	r0
    1bc2:	e2 f7       	brpl	.-8      	; 0x1bbc <KeyPad_getPressedKey+0x40>
    1bc4:	80 95       	com	r24
    1bc6:	80 83       	st	Z, r24
		for(row=2;row<5;row++) /* loop for rows */
    1bc8:	82 e0       	ldi	r24, 0x02	; 2
    1bca:	80 93 11 07 	sts	0x0711, r24
    1bce:	2b c0       	rjmp	.+86     	; 0x1c26 <KeyPad_getPressedKey+0xaa>
		{
			if(Get_Bit(KEYPAD_PORT_IN,row)==0) /* if the switch is press in this row */
    1bd0:	e3 e3       	ldi	r30, 0x33	; 51
    1bd2:	f0 e0       	ldi	r31, 0x00	; 0
    1bd4:	80 81       	ld	r24, Z
    1bd6:	28 2f       	mov	r18, r24
    1bd8:	30 e0       	ldi	r19, 0x00	; 0
    1bda:	80 91 11 07 	lds	r24, 0x0711
    1bde:	88 2f       	mov	r24, r24
    1be0:	90 e0       	ldi	r25, 0x00	; 0
    1be2:	a9 01       	movw	r20, r18
    1be4:	02 c0       	rjmp	.+4      	; 0x1bea <KeyPad_getPressedKey+0x6e>
    1be6:	55 95       	asr	r21
    1be8:	47 95       	ror	r20
    1bea:	8a 95       	dec	r24
    1bec:	e2 f7       	brpl	.-8      	; 0x1be6 <KeyPad_getPressedKey+0x6a>
    1bee:	ca 01       	movw	r24, r20
    1bf0:	81 70       	andi	r24, 0x01	; 1
    1bf2:	90 70       	andi	r25, 0x00	; 0
    1bf4:	00 97       	sbiw	r24, 0x00	; 0
    1bf6:	91 f4       	brne	.+36     	; 0x1c1c <KeyPad_getPressedKey+0xa0>
				return KeyPad_4x3_adjustKeyNumber((row*N_col)+col+1);
#elif (N_col == 4 && N_row == 4)
				return KeyPad_4x4_adjustKeyNumber((row*N_col)+col+1);
#elif (N_col == 3 && N_row == 3)
				//while(Get_Bit(KEYPAD_PORT_IN,row)==0);
				return KeyPad_3x3_adjustKeyNumber(3*(row-2)+col+1);
    1bf8:	80 91 11 07 	lds	r24, 0x0711
    1bfc:	28 2f       	mov	r18, r24
    1bfe:	30 e0       	ldi	r19, 0x00	; 0
    1c00:	c9 01       	movw	r24, r18
    1c02:	88 0f       	add	r24, r24
    1c04:	99 1f       	adc	r25, r25
    1c06:	82 0f       	add	r24, r18
    1c08:	93 1f       	adc	r25, r19
    1c0a:	98 2f       	mov	r25, r24
    1c0c:	80 91 10 07 	lds	r24, 0x0710
    1c10:	89 0f       	add	r24, r25
    1c12:	85 50       	subi	r24, 0x05	; 5
    1c14:	0e 94 28 0e 	call	0x1c50	; 0x1c50 <KeyPad_3x3_adjustKeyNumber>
    1c18:	89 83       	std	Y+1, r24	; 0x01
    1c1a:	15 c0       	rjmp	.+42     	; 0x1c46 <KeyPad_getPressedKey+0xca>
		/*
		 * clear the output pin column in this trace and enable the internal
		 * pull up resistors for the rows pins
		 */
		KEYPAD_PORT_OUT = (~(0b00100000<<col));
		for(row=2;row<5;row++) /* loop for rows */
    1c1c:	80 91 11 07 	lds	r24, 0x0711
    1c20:	8f 5f       	subi	r24, 0xFF	; 255
    1c22:	80 93 11 07 	sts	0x0711, r24
    1c26:	80 91 11 07 	lds	r24, 0x0711
    1c2a:	85 30       	cpi	r24, 0x05	; 5
    1c2c:	88 f2       	brcs	.-94     	; 0x1bd0 <KeyPad_getPressedKey+0x54>



uint8 KeyPad_getPressedKey(void)
{
	for(col=0;col<N_col;col++) /* loop for columns */
    1c2e:	80 91 10 07 	lds	r24, 0x0710
    1c32:	8f 5f       	subi	r24, 0xFF	; 255
    1c34:	80 93 10 07 	sts	0x0710, r24
    1c38:	80 91 10 07 	lds	r24, 0x0710
    1c3c:	83 30       	cpi	r24, 0x03	; 3
    1c3e:	08 f4       	brcc	.+2      	; 0x1c42 <KeyPad_getPressedKey+0xc6>
    1c40:	a5 cf       	rjmp	.-182    	; 0x1b8c <KeyPad_getPressedKey+0x10>
				return KeyPad_3x3_adjustKeyNumber(3*(row-2)+col+1);
#endif
			}
		}
	}
	return 'a';
    1c42:	51 e6       	ldi	r21, 0x61	; 97
    1c44:	59 83       	std	Y+1, r21	; 0x01
    1c46:	89 81       	ldd	r24, Y+1	; 0x01
}
    1c48:	0f 90       	pop	r0
    1c4a:	cf 91       	pop	r28
    1c4c:	df 91       	pop	r29
    1c4e:	08 95       	ret

00001c50 <KeyPad_3x3_adjustKeyNumber>:
	}
}
#elif (N_row == 3 && N_col == 3)

static uint8 KeyPad_3x3_adjustKeyNumber(uint8 button_number)
{
    1c50:	df 93       	push	r29
    1c52:	cf 93       	push	r28
    1c54:	00 d0       	rcall	.+0      	; 0x1c56 <KeyPad_3x3_adjustKeyNumber+0x6>
    1c56:	00 d0       	rcall	.+0      	; 0x1c58 <KeyPad_3x3_adjustKeyNumber+0x8>
    1c58:	cd b7       	in	r28, 0x3d	; 61
    1c5a:	de b7       	in	r29, 0x3e	; 62
    1c5c:	89 83       	std	Y+1, r24	; 0x01
	switch(button_number)
    1c5e:	89 81       	ldd	r24, Y+1	; 0x01
    1c60:	28 2f       	mov	r18, r24
    1c62:	30 e0       	ldi	r19, 0x00	; 0
    1c64:	3c 83       	std	Y+4, r19	; 0x04
    1c66:	2b 83       	std	Y+3, r18	; 0x03
    1c68:	8b 81       	ldd	r24, Y+3	; 0x03
    1c6a:	9c 81       	ldd	r25, Y+4	; 0x04
    1c6c:	85 30       	cpi	r24, 0x05	; 5
    1c6e:	91 05       	cpc	r25, r1
    1c70:	09 f4       	brne	.+2      	; 0x1c74 <KeyPad_3x3_adjustKeyNumber+0x24>
    1c72:	41 c0       	rjmp	.+130    	; 0x1cf6 <KeyPad_3x3_adjustKeyNumber+0xa6>
    1c74:	2b 81       	ldd	r18, Y+3	; 0x03
    1c76:	3c 81       	ldd	r19, Y+4	; 0x04
    1c78:	26 30       	cpi	r18, 0x06	; 6
    1c7a:	31 05       	cpc	r19, r1
    1c7c:	dc f4       	brge	.+54     	; 0x1cb4 <KeyPad_3x3_adjustKeyNumber+0x64>
    1c7e:	8b 81       	ldd	r24, Y+3	; 0x03
    1c80:	9c 81       	ldd	r25, Y+4	; 0x04
    1c82:	82 30       	cpi	r24, 0x02	; 2
    1c84:	91 05       	cpc	r25, r1
    1c86:	71 f1       	breq	.+92     	; 0x1ce4 <KeyPad_3x3_adjustKeyNumber+0x94>
    1c88:	2b 81       	ldd	r18, Y+3	; 0x03
    1c8a:	3c 81       	ldd	r19, Y+4	; 0x04
    1c8c:	23 30       	cpi	r18, 0x03	; 3
    1c8e:	31 05       	cpc	r19, r1
    1c90:	34 f4       	brge	.+12     	; 0x1c9e <KeyPad_3x3_adjustKeyNumber+0x4e>
    1c92:	8b 81       	ldd	r24, Y+3	; 0x03
    1c94:	9c 81       	ldd	r25, Y+4	; 0x04
    1c96:	81 30       	cpi	r24, 0x01	; 1
    1c98:	91 05       	cpc	r25, r1
    1c9a:	09 f1       	breq	.+66     	; 0x1cde <KeyPad_3x3_adjustKeyNumber+0x8e>
    1c9c:	3b c0       	rjmp	.+118    	; 0x1d14 <KeyPad_3x3_adjustKeyNumber+0xc4>
    1c9e:	2b 81       	ldd	r18, Y+3	; 0x03
    1ca0:	3c 81       	ldd	r19, Y+4	; 0x04
    1ca2:	23 30       	cpi	r18, 0x03	; 3
    1ca4:	31 05       	cpc	r19, r1
    1ca6:	09 f1       	breq	.+66     	; 0x1cea <KeyPad_3x3_adjustKeyNumber+0x9a>
    1ca8:	8b 81       	ldd	r24, Y+3	; 0x03
    1caa:	9c 81       	ldd	r25, Y+4	; 0x04
    1cac:	84 30       	cpi	r24, 0x04	; 4
    1cae:	91 05       	cpc	r25, r1
    1cb0:	f9 f0       	breq	.+62     	; 0x1cf0 <KeyPad_3x3_adjustKeyNumber+0xa0>
    1cb2:	30 c0       	rjmp	.+96     	; 0x1d14 <KeyPad_3x3_adjustKeyNumber+0xc4>
    1cb4:	2b 81       	ldd	r18, Y+3	; 0x03
    1cb6:	3c 81       	ldd	r19, Y+4	; 0x04
    1cb8:	27 30       	cpi	r18, 0x07	; 7
    1cba:	31 05       	cpc	r19, r1
    1cbc:	11 f1       	breq	.+68     	; 0x1d02 <KeyPad_3x3_adjustKeyNumber+0xb2>
    1cbe:	8b 81       	ldd	r24, Y+3	; 0x03
    1cc0:	9c 81       	ldd	r25, Y+4	; 0x04
    1cc2:	87 30       	cpi	r24, 0x07	; 7
    1cc4:	91 05       	cpc	r25, r1
    1cc6:	d4 f0       	brlt	.+52     	; 0x1cfc <KeyPad_3x3_adjustKeyNumber+0xac>
    1cc8:	2b 81       	ldd	r18, Y+3	; 0x03
    1cca:	3c 81       	ldd	r19, Y+4	; 0x04
    1ccc:	28 30       	cpi	r18, 0x08	; 8
    1cce:	31 05       	cpc	r19, r1
    1cd0:	d9 f0       	breq	.+54     	; 0x1d08 <KeyPad_3x3_adjustKeyNumber+0xb8>
    1cd2:	8b 81       	ldd	r24, Y+3	; 0x03
    1cd4:	9c 81       	ldd	r25, Y+4	; 0x04
    1cd6:	89 30       	cpi	r24, 0x09	; 9
    1cd8:	91 05       	cpc	r25, r1
    1cda:	c9 f0       	breq	.+50     	; 0x1d0e <KeyPad_3x3_adjustKeyNumber+0xbe>
    1cdc:	1b c0       	rjmp	.+54     	; 0x1d14 <KeyPad_3x3_adjustKeyNumber+0xc4>
	{
	case 1: return 1;
    1cde:	91 e0       	ldi	r25, 0x01	; 1
    1ce0:	9a 83       	std	Y+2, r25	; 0x02
    1ce2:	1a c0       	rjmp	.+52     	; 0x1d18 <KeyPad_3x3_adjustKeyNumber+0xc8>
	break;
	case 2: return 2;
    1ce4:	22 e0       	ldi	r18, 0x02	; 2
    1ce6:	2a 83       	std	Y+2, r18	; 0x02
    1ce8:	17 c0       	rjmp	.+46     	; 0x1d18 <KeyPad_3x3_adjustKeyNumber+0xc8>
	break;
	case 3: return 3;
    1cea:	33 e0       	ldi	r19, 0x03	; 3
    1cec:	3a 83       	std	Y+2, r19	; 0x02
    1cee:	14 c0       	rjmp	.+40     	; 0x1d18 <KeyPad_3x3_adjustKeyNumber+0xc8>
	break;
	case 4: return 4; // ASCII Code of %
    1cf0:	84 e0       	ldi	r24, 0x04	; 4
    1cf2:	8a 83       	std	Y+2, r24	; 0x02
    1cf4:	11 c0       	rjmp	.+34     	; 0x1d18 <KeyPad_3x3_adjustKeyNumber+0xc8>
	break;
	case 5: return 5;
    1cf6:	95 e0       	ldi	r25, 0x05	; 5
    1cf8:	9a 83       	std	Y+2, r25	; 0x02
    1cfa:	0e c0       	rjmp	.+28     	; 0x1d18 <KeyPad_3x3_adjustKeyNumber+0xc8>
	break;
	case 6: return 6;
    1cfc:	26 e0       	ldi	r18, 0x06	; 6
    1cfe:	2a 83       	std	Y+2, r18	; 0x02
    1d00:	0b c0       	rjmp	.+22     	; 0x1d18 <KeyPad_3x3_adjustKeyNumber+0xc8>
	break;
	case 7: return 7;
    1d02:	37 e0       	ldi	r19, 0x07	; 7
    1d04:	3a 83       	std	Y+2, r19	; 0x02
    1d06:	08 c0       	rjmp	.+16     	; 0x1d18 <KeyPad_3x3_adjustKeyNumber+0xc8>
	break;
	case 8: return 8; /* ASCII Code of '*' */
    1d08:	88 e0       	ldi	r24, 0x08	; 8
    1d0a:	8a 83       	std	Y+2, r24	; 0x02
    1d0c:	05 c0       	rjmp	.+10     	; 0x1d18 <KeyPad_3x3_adjustKeyNumber+0xc8>
	break;
	case 9: return 9;
    1d0e:	99 e0       	ldi	r25, 0x09	; 9
    1d10:	9a 83       	std	Y+2, r25	; 0x02
    1d12:	02 c0       	rjmp	.+4      	; 0x1d18 <KeyPad_3x3_adjustKeyNumber+0xc8>
	break;
	default: return button_number;
    1d14:	29 81       	ldd	r18, Y+1	; 0x01
    1d16:	2a 83       	std	Y+2, r18	; 0x02
    1d18:	8a 81       	ldd	r24, Y+2	; 0x02
	}
}
    1d1a:	0f 90       	pop	r0
    1d1c:	0f 90       	pop	r0
    1d1e:	0f 90       	pop	r0
    1d20:	0f 90       	pop	r0
    1d22:	cf 91       	pop	r28
    1d24:	df 91       	pop	r29
    1d26:	08 95       	ret

00001d28 <enableTrigger>:
/////////////////////////////////////////////////////////////////////
//	lcd enable triggering function to make lcd aware about command or
//   data changes.
////////////////////////////////////////////////////////////////////
void enableTrigger(void)
{
    1d28:	df 93       	push	r29
    1d2a:	cf 93       	push	r28
    1d2c:	cd b7       	in	r28, 0x3d	; 61
    1d2e:	de b7       	in	r29, 0x3e	; 62
    1d30:	6c 97       	sbiw	r28, 0x1c	; 28
    1d32:	0f b6       	in	r0, 0x3f	; 63
    1d34:	f8 94       	cli
    1d36:	de bf       	out	0x3e, r29	; 62
    1d38:	0f be       	out	0x3f, r0	; 63
    1d3a:	cd bf       	out	0x3d, r28	; 61

	CLR_BIT(PORTB,2);
    1d3c:	a8 e3       	ldi	r26, 0x38	; 56
    1d3e:	b0 e0       	ldi	r27, 0x00	; 0
    1d40:	e8 e3       	ldi	r30, 0x38	; 56
    1d42:	f0 e0       	ldi	r31, 0x00	; 0
    1d44:	80 81       	ld	r24, Z
    1d46:	8b 7f       	andi	r24, 0xFB	; 251
    1d48:	8c 93       	st	X, r24
    1d4a:	80 e0       	ldi	r24, 0x00	; 0
    1d4c:	90 e0       	ldi	r25, 0x00	; 0
    1d4e:	a0 e8       	ldi	r26, 0x80	; 128
    1d50:	bf e3       	ldi	r27, 0x3F	; 63
    1d52:	89 8f       	std	Y+25, r24	; 0x19
    1d54:	9a 8f       	std	Y+26, r25	; 0x1a
    1d56:	ab 8f       	std	Y+27, r26	; 0x1b
    1d58:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1d5a:	69 8d       	ldd	r22, Y+25	; 0x19
    1d5c:	7a 8d       	ldd	r23, Y+26	; 0x1a
    1d5e:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1d60:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1d62:	20 e0       	ldi	r18, 0x00	; 0
    1d64:	30 e0       	ldi	r19, 0x00	; 0
    1d66:	4a ef       	ldi	r20, 0xFA	; 250
    1d68:	54 e4       	ldi	r21, 0x44	; 68
    1d6a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1d6e:	dc 01       	movw	r26, r24
    1d70:	cb 01       	movw	r24, r22
    1d72:	8d 8b       	std	Y+21, r24	; 0x15
    1d74:	9e 8b       	std	Y+22, r25	; 0x16
    1d76:	af 8b       	std	Y+23, r26	; 0x17
    1d78:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    1d7a:	6d 89       	ldd	r22, Y+21	; 0x15
    1d7c:	7e 89       	ldd	r23, Y+22	; 0x16
    1d7e:	8f 89       	ldd	r24, Y+23	; 0x17
    1d80:	98 8d       	ldd	r25, Y+24	; 0x18
    1d82:	20 e0       	ldi	r18, 0x00	; 0
    1d84:	30 e0       	ldi	r19, 0x00	; 0
    1d86:	40 e8       	ldi	r20, 0x80	; 128
    1d88:	5f e3       	ldi	r21, 0x3F	; 63
    1d8a:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    1d8e:	88 23       	and	r24, r24
    1d90:	2c f4       	brge	.+10     	; 0x1d9c <enableTrigger+0x74>
		__ticks = 1;
    1d92:	81 e0       	ldi	r24, 0x01	; 1
    1d94:	90 e0       	ldi	r25, 0x00	; 0
    1d96:	9c 8b       	std	Y+20, r25	; 0x14
    1d98:	8b 8b       	std	Y+19, r24	; 0x13
    1d9a:	3f c0       	rjmp	.+126    	; 0x1e1a <enableTrigger+0xf2>
	else if (__tmp > 65535)
    1d9c:	6d 89       	ldd	r22, Y+21	; 0x15
    1d9e:	7e 89       	ldd	r23, Y+22	; 0x16
    1da0:	8f 89       	ldd	r24, Y+23	; 0x17
    1da2:	98 8d       	ldd	r25, Y+24	; 0x18
    1da4:	20 e0       	ldi	r18, 0x00	; 0
    1da6:	3f ef       	ldi	r19, 0xFF	; 255
    1da8:	4f e7       	ldi	r20, 0x7F	; 127
    1daa:	57 e4       	ldi	r21, 0x47	; 71
    1dac:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    1db0:	18 16       	cp	r1, r24
    1db2:	4c f5       	brge	.+82     	; 0x1e06 <enableTrigger+0xde>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1db4:	69 8d       	ldd	r22, Y+25	; 0x19
    1db6:	7a 8d       	ldd	r23, Y+26	; 0x1a
    1db8:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1dba:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1dbc:	20 e0       	ldi	r18, 0x00	; 0
    1dbe:	30 e0       	ldi	r19, 0x00	; 0
    1dc0:	40 e2       	ldi	r20, 0x20	; 32
    1dc2:	51 e4       	ldi	r21, 0x41	; 65
    1dc4:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1dc8:	dc 01       	movw	r26, r24
    1dca:	cb 01       	movw	r24, r22
    1dcc:	bc 01       	movw	r22, r24
    1dce:	cd 01       	movw	r24, r26
    1dd0:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1dd4:	dc 01       	movw	r26, r24
    1dd6:	cb 01       	movw	r24, r22
    1dd8:	9c 8b       	std	Y+20, r25	; 0x14
    1dda:	8b 8b       	std	Y+19, r24	; 0x13
    1ddc:	0f c0       	rjmp	.+30     	; 0x1dfc <enableTrigger+0xd4>
    1dde:	88 ec       	ldi	r24, 0xC8	; 200
    1de0:	90 e0       	ldi	r25, 0x00	; 0
    1de2:	9a 8b       	std	Y+18, r25	; 0x12
    1de4:	89 8b       	std	Y+17, r24	; 0x11
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    1de6:	89 89       	ldd	r24, Y+17	; 0x11
    1de8:	9a 89       	ldd	r25, Y+18	; 0x12
    1dea:	01 97       	sbiw	r24, 0x01	; 1
    1dec:	f1 f7       	brne	.-4      	; 0x1dea <enableTrigger+0xc2>
    1dee:	9a 8b       	std	Y+18, r25	; 0x12
    1df0:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1df2:	8b 89       	ldd	r24, Y+19	; 0x13
    1df4:	9c 89       	ldd	r25, Y+20	; 0x14
    1df6:	01 97       	sbiw	r24, 0x01	; 1
    1df8:	9c 8b       	std	Y+20, r25	; 0x14
    1dfa:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1dfc:	8b 89       	ldd	r24, Y+19	; 0x13
    1dfe:	9c 89       	ldd	r25, Y+20	; 0x14
    1e00:	00 97       	sbiw	r24, 0x00	; 0
    1e02:	69 f7       	brne	.-38     	; 0x1dde <enableTrigger+0xb6>
    1e04:	14 c0       	rjmp	.+40     	; 0x1e2e <enableTrigger+0x106>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1e06:	6d 89       	ldd	r22, Y+21	; 0x15
    1e08:	7e 89       	ldd	r23, Y+22	; 0x16
    1e0a:	8f 89       	ldd	r24, Y+23	; 0x17
    1e0c:	98 8d       	ldd	r25, Y+24	; 0x18
    1e0e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1e12:	dc 01       	movw	r26, r24
    1e14:	cb 01       	movw	r24, r22
    1e16:	9c 8b       	std	Y+20, r25	; 0x14
    1e18:	8b 8b       	std	Y+19, r24	; 0x13
    1e1a:	8b 89       	ldd	r24, Y+19	; 0x13
    1e1c:	9c 89       	ldd	r25, Y+20	; 0x14
    1e1e:	98 8b       	std	Y+16, r25	; 0x10
    1e20:	8f 87       	std	Y+15, r24	; 0x0f
    1e22:	8f 85       	ldd	r24, Y+15	; 0x0f
    1e24:	98 89       	ldd	r25, Y+16	; 0x10
    1e26:	01 97       	sbiw	r24, 0x01	; 1
    1e28:	f1 f7       	brne	.-4      	; 0x1e26 <enableTrigger+0xfe>
    1e2a:	98 8b       	std	Y+16, r25	; 0x10
    1e2c:	8f 87       	std	Y+15, r24	; 0x0f
	
	_delay_ms(1);

	SET_BIT(PORTB,2);
    1e2e:	a8 e3       	ldi	r26, 0x38	; 56
    1e30:	b0 e0       	ldi	r27, 0x00	; 0
    1e32:	e8 e3       	ldi	r30, 0x38	; 56
    1e34:	f0 e0       	ldi	r31, 0x00	; 0
    1e36:	80 81       	ld	r24, Z
    1e38:	84 60       	ori	r24, 0x04	; 4
    1e3a:	8c 93       	st	X, r24
    1e3c:	80 e0       	ldi	r24, 0x00	; 0
    1e3e:	90 e0       	ldi	r25, 0x00	; 0
    1e40:	a0 ec       	ldi	r26, 0xC0	; 192
    1e42:	b0 e4       	ldi	r27, 0x40	; 64
    1e44:	8b 87       	std	Y+11, r24	; 0x0b
    1e46:	9c 87       	std	Y+12, r25	; 0x0c
    1e48:	ad 87       	std	Y+13, r26	; 0x0d
    1e4a:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1e4c:	6b 85       	ldd	r22, Y+11	; 0x0b
    1e4e:	7c 85       	ldd	r23, Y+12	; 0x0c
    1e50:	8d 85       	ldd	r24, Y+13	; 0x0d
    1e52:	9e 85       	ldd	r25, Y+14	; 0x0e
    1e54:	20 e0       	ldi	r18, 0x00	; 0
    1e56:	30 e0       	ldi	r19, 0x00	; 0
    1e58:	4a ef       	ldi	r20, 0xFA	; 250
    1e5a:	54 e4       	ldi	r21, 0x44	; 68
    1e5c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1e60:	dc 01       	movw	r26, r24
    1e62:	cb 01       	movw	r24, r22
    1e64:	8f 83       	std	Y+7, r24	; 0x07
    1e66:	98 87       	std	Y+8, r25	; 0x08
    1e68:	a9 87       	std	Y+9, r26	; 0x09
    1e6a:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    1e6c:	6f 81       	ldd	r22, Y+7	; 0x07
    1e6e:	78 85       	ldd	r23, Y+8	; 0x08
    1e70:	89 85       	ldd	r24, Y+9	; 0x09
    1e72:	9a 85       	ldd	r25, Y+10	; 0x0a
    1e74:	20 e0       	ldi	r18, 0x00	; 0
    1e76:	30 e0       	ldi	r19, 0x00	; 0
    1e78:	40 e8       	ldi	r20, 0x80	; 128
    1e7a:	5f e3       	ldi	r21, 0x3F	; 63
    1e7c:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    1e80:	88 23       	and	r24, r24
    1e82:	2c f4       	brge	.+10     	; 0x1e8e <enableTrigger+0x166>
		__ticks = 1;
    1e84:	81 e0       	ldi	r24, 0x01	; 1
    1e86:	90 e0       	ldi	r25, 0x00	; 0
    1e88:	9e 83       	std	Y+6, r25	; 0x06
    1e8a:	8d 83       	std	Y+5, r24	; 0x05
    1e8c:	3f c0       	rjmp	.+126    	; 0x1f0c <enableTrigger+0x1e4>
	else if (__tmp > 65535)
    1e8e:	6f 81       	ldd	r22, Y+7	; 0x07
    1e90:	78 85       	ldd	r23, Y+8	; 0x08
    1e92:	89 85       	ldd	r24, Y+9	; 0x09
    1e94:	9a 85       	ldd	r25, Y+10	; 0x0a
    1e96:	20 e0       	ldi	r18, 0x00	; 0
    1e98:	3f ef       	ldi	r19, 0xFF	; 255
    1e9a:	4f e7       	ldi	r20, 0x7F	; 127
    1e9c:	57 e4       	ldi	r21, 0x47	; 71
    1e9e:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    1ea2:	18 16       	cp	r1, r24
    1ea4:	4c f5       	brge	.+82     	; 0x1ef8 <enableTrigger+0x1d0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1ea6:	6b 85       	ldd	r22, Y+11	; 0x0b
    1ea8:	7c 85       	ldd	r23, Y+12	; 0x0c
    1eaa:	8d 85       	ldd	r24, Y+13	; 0x0d
    1eac:	9e 85       	ldd	r25, Y+14	; 0x0e
    1eae:	20 e0       	ldi	r18, 0x00	; 0
    1eb0:	30 e0       	ldi	r19, 0x00	; 0
    1eb2:	40 e2       	ldi	r20, 0x20	; 32
    1eb4:	51 e4       	ldi	r21, 0x41	; 65
    1eb6:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1eba:	dc 01       	movw	r26, r24
    1ebc:	cb 01       	movw	r24, r22
    1ebe:	bc 01       	movw	r22, r24
    1ec0:	cd 01       	movw	r24, r26
    1ec2:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1ec6:	dc 01       	movw	r26, r24
    1ec8:	cb 01       	movw	r24, r22
    1eca:	9e 83       	std	Y+6, r25	; 0x06
    1ecc:	8d 83       	std	Y+5, r24	; 0x05
    1ece:	0f c0       	rjmp	.+30     	; 0x1eee <enableTrigger+0x1c6>
    1ed0:	88 ec       	ldi	r24, 0xC8	; 200
    1ed2:	90 e0       	ldi	r25, 0x00	; 0
    1ed4:	9c 83       	std	Y+4, r25	; 0x04
    1ed6:	8b 83       	std	Y+3, r24	; 0x03
    1ed8:	8b 81       	ldd	r24, Y+3	; 0x03
    1eda:	9c 81       	ldd	r25, Y+4	; 0x04
    1edc:	01 97       	sbiw	r24, 0x01	; 1
    1ede:	f1 f7       	brne	.-4      	; 0x1edc <enableTrigger+0x1b4>
    1ee0:	9c 83       	std	Y+4, r25	; 0x04
    1ee2:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1ee4:	8d 81       	ldd	r24, Y+5	; 0x05
    1ee6:	9e 81       	ldd	r25, Y+6	; 0x06
    1ee8:	01 97       	sbiw	r24, 0x01	; 1
    1eea:	9e 83       	std	Y+6, r25	; 0x06
    1eec:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1eee:	8d 81       	ldd	r24, Y+5	; 0x05
    1ef0:	9e 81       	ldd	r25, Y+6	; 0x06
    1ef2:	00 97       	sbiw	r24, 0x00	; 0
    1ef4:	69 f7       	brne	.-38     	; 0x1ed0 <enableTrigger+0x1a8>
    1ef6:	14 c0       	rjmp	.+40     	; 0x1f20 <enableTrigger+0x1f8>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1ef8:	6f 81       	ldd	r22, Y+7	; 0x07
    1efa:	78 85       	ldd	r23, Y+8	; 0x08
    1efc:	89 85       	ldd	r24, Y+9	; 0x09
    1efe:	9a 85       	ldd	r25, Y+10	; 0x0a
    1f00:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1f04:	dc 01       	movw	r26, r24
    1f06:	cb 01       	movw	r24, r22
    1f08:	9e 83       	std	Y+6, r25	; 0x06
    1f0a:	8d 83       	std	Y+5, r24	; 0x05
    1f0c:	8d 81       	ldd	r24, Y+5	; 0x05
    1f0e:	9e 81       	ldd	r25, Y+6	; 0x06
    1f10:	9a 83       	std	Y+2, r25	; 0x02
    1f12:	89 83       	std	Y+1, r24	; 0x01
    1f14:	89 81       	ldd	r24, Y+1	; 0x01
    1f16:	9a 81       	ldd	r25, Y+2	; 0x02
    1f18:	01 97       	sbiw	r24, 0x01	; 1
    1f1a:	f1 f7       	brne	.-4      	; 0x1f18 <enableTrigger+0x1f0>
    1f1c:	9a 83       	std	Y+2, r25	; 0x02
    1f1e:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(6);


}
    1f20:	6c 96       	adiw	r28, 0x1c	; 28
    1f22:	0f b6       	in	r0, 0x3f	; 63
    1f24:	f8 94       	cli
    1f26:	de bf       	out	0x3e, r29	; 62
    1f28:	0f be       	out	0x3f, r0	; 63
    1f2a:	cd bf       	out	0x3d, r28	; 61
    1f2c:	cf 91       	pop	r28
    1f2e:	df 91       	pop	r29
    1f30:	08 95       	ret

00001f32 <lcd_init>:
///////////////////////////////////////////////////////////////////////////////////////
// LCD initialization API : set portB from pinB.4 to pinB.7 as o/p for data and commands 
//							 and pinB.0 to pinB.2 o/p for control pins 
//////////////////////////////////////////////////////////////////////////////////////
void lcd_init(void)
{
    1f32:	df 93       	push	r29
    1f34:	cf 93       	push	r28
    1f36:	cd b7       	in	r28, 0x3d	; 61
    1f38:	de b7       	in	r29, 0x3e	; 62

	DDRB=0xff; // init port B as O/P port 
    1f3a:	e7 e3       	ldi	r30, 0x37	; 55
    1f3c:	f0 e0       	ldi	r31, 0x00	; 0
    1f3e:	8f ef       	ldi	r24, 0xFF	; 255
    1f40:	80 83       	st	Z, r24
	PORTB=0x04; // activate LCD enable 
    1f42:	e8 e3       	ldi	r30, 0x38	; 56
    1f44:	f0 e0       	ldi	r31, 0x00	; 0
    1f46:	84 e0       	ldi	r24, 0x04	; 4
    1f48:	80 83       	st	Z, r24

	lcd_sendCommand(0x33); // 4-bit mode 
    1f4a:	83 e3       	ldi	r24, 0x33	; 51
    1f4c:	0e 94 b4 0f 	call	0x1f68	; 0x1f68 <lcd_sendCommand>
	lcd_sendCommand (0x32);
    1f50:	82 e3       	ldi	r24, 0x32	; 50
    1f52:	0e 94 b4 0f 	call	0x1f68	; 0x1f68 <lcd_sendCommand>
	lcd_sendCommand (0x28);
    1f56:	88 e2       	ldi	r24, 0x28	; 40
    1f58:	0e 94 b4 0f 	call	0x1f68	; 0x1f68 <lcd_sendCommand>



	lcd_sendCommand(0x0c); // turn on lcd 
    1f5c:	8c e0       	ldi	r24, 0x0C	; 12
    1f5e:	0e 94 b4 0f 	call	0x1f68	; 0x1f68 <lcd_sendCommand>

		
}
    1f62:	cf 91       	pop	r28
    1f64:	df 91       	pop	r29
    1f66:	08 95       	ret

00001f68 <lcd_sendCommand>:


void lcd_sendCommand(unsigned char cmd)
{
    1f68:	df 93       	push	r29
    1f6a:	cf 93       	push	r28
    1f6c:	00 d0       	rcall	.+0      	; 0x1f6e <lcd_sendCommand+0x6>
    1f6e:	0f 92       	push	r0
    1f70:	cd b7       	in	r28, 0x3d	; 61
    1f72:	de b7       	in	r29, 0x3e	; 62
    1f74:	8b 83       	std	Y+3, r24	; 0x03

	unsigned char high_nibble , low_nibble ; 		
	
	HIGH_NIBBLE(high_nibble,cmd);
    1f76:	8b 81       	ldd	r24, Y+3	; 0x03
    1f78:	80 7f       	andi	r24, 0xF0	; 240
    1f7a:	8a 83       	std	Y+2, r24	; 0x02
	LOW_NIBBLE(low_nibble,cmd);
    1f7c:	8b 81       	ldd	r24, Y+3	; 0x03
    1f7e:	82 95       	swap	r24
    1f80:	80 7f       	andi	r24, 0xF0	; 240
    1f82:	89 83       	std	Y+1, r24	; 0x01

	CLR_BIT(PORTB,0); // to enable command mode 
    1f84:	a8 e3       	ldi	r26, 0x38	; 56
    1f86:	b0 e0       	ldi	r27, 0x00	; 0
    1f88:	e8 e3       	ldi	r30, 0x38	; 56
    1f8a:	f0 e0       	ldi	r31, 0x00	; 0
    1f8c:	80 81       	ld	r24, Z
    1f8e:	8e 7f       	andi	r24, 0xFE	; 254
    1f90:	8c 93       	st	X, r24
	CLR_BIT(PORTB,1); // write signal to lcd 
    1f92:	a8 e3       	ldi	r26, 0x38	; 56
    1f94:	b0 e0       	ldi	r27, 0x00	; 0
    1f96:	e8 e3       	ldi	r30, 0x38	; 56
    1f98:	f0 e0       	ldi	r31, 0x00	; 0
    1f9a:	80 81       	ld	r24, Z
    1f9c:	8d 7f       	andi	r24, 0xFD	; 253
    1f9e:	8c 93       	st	X, r24

	PORTB &=0x0f;
    1fa0:	a8 e3       	ldi	r26, 0x38	; 56
    1fa2:	b0 e0       	ldi	r27, 0x00	; 0
    1fa4:	e8 e3       	ldi	r30, 0x38	; 56
    1fa6:	f0 e0       	ldi	r31, 0x00	; 0
    1fa8:	80 81       	ld	r24, Z
    1faa:	8f 70       	andi	r24, 0x0F	; 15
    1fac:	8c 93       	st	X, r24
	PORTB |=high_nibble;// to send high nibble command  
    1fae:	a8 e3       	ldi	r26, 0x38	; 56
    1fb0:	b0 e0       	ldi	r27, 0x00	; 0
    1fb2:	e8 e3       	ldi	r30, 0x38	; 56
    1fb4:	f0 e0       	ldi	r31, 0x00	; 0
    1fb6:	90 81       	ld	r25, Z
    1fb8:	8a 81       	ldd	r24, Y+2	; 0x02
    1fba:	89 2b       	or	r24, r25
    1fbc:	8c 93       	st	X, r24
	enableTrigger(); // triggre lcd enable 
    1fbe:	0e 94 94 0e 	call	0x1d28	; 0x1d28 <enableTrigger>

	PORTB &=0x0f;
    1fc2:	a8 e3       	ldi	r26, 0x38	; 56
    1fc4:	b0 e0       	ldi	r27, 0x00	; 0
    1fc6:	e8 e3       	ldi	r30, 0x38	; 56
    1fc8:	f0 e0       	ldi	r31, 0x00	; 0
    1fca:	80 81       	ld	r24, Z
    1fcc:	8f 70       	andi	r24, 0x0F	; 15
    1fce:	8c 93       	st	X, r24
	PORTB |=low_nibble; // to send low nibble command 
    1fd0:	a8 e3       	ldi	r26, 0x38	; 56
    1fd2:	b0 e0       	ldi	r27, 0x00	; 0
    1fd4:	e8 e3       	ldi	r30, 0x38	; 56
    1fd6:	f0 e0       	ldi	r31, 0x00	; 0
    1fd8:	90 81       	ld	r25, Z
    1fda:	89 81       	ldd	r24, Y+1	; 0x01
    1fdc:	89 2b       	or	r24, r25
    1fde:	8c 93       	st	X, r24
	enableTrigger();
    1fe0:	0e 94 94 0e 	call	0x1d28	; 0x1d28 <enableTrigger>

}
    1fe4:	0f 90       	pop	r0
    1fe6:	0f 90       	pop	r0
    1fe8:	0f 90       	pop	r0
    1fea:	cf 91       	pop	r28
    1fec:	df 91       	pop	r29
    1fee:	08 95       	ret

00001ff0 <lcd_displayChar>:

void lcd_displayChar (unsigned char data)
{
    1ff0:	df 93       	push	r29
    1ff2:	cf 93       	push	r28
    1ff4:	00 d0       	rcall	.+0      	; 0x1ff6 <lcd_displayChar+0x6>
    1ff6:	0f 92       	push	r0
    1ff8:	cd b7       	in	r28, 0x3d	; 61
    1ffa:	de b7       	in	r29, 0x3e	; 62
    1ffc:	8b 83       	std	Y+3, r24	; 0x03

	unsigned char high_nibble , low_nibble ;

	SET_BIT(PORTB,0); //  enable data mode 
    1ffe:	a8 e3       	ldi	r26, 0x38	; 56
    2000:	b0 e0       	ldi	r27, 0x00	; 0
    2002:	e8 e3       	ldi	r30, 0x38	; 56
    2004:	f0 e0       	ldi	r31, 0x00	; 0
    2006:	80 81       	ld	r24, Z
    2008:	81 60       	ori	r24, 0x01	; 1
    200a:	8c 93       	st	X, r24
	CLR_BIT(PORTB,1); // activate lcd write 
    200c:	a8 e3       	ldi	r26, 0x38	; 56
    200e:	b0 e0       	ldi	r27, 0x00	; 0
    2010:	e8 e3       	ldi	r30, 0x38	; 56
    2012:	f0 e0       	ldi	r31, 0x00	; 0
    2014:	80 81       	ld	r24, Z
    2016:	8d 7f       	andi	r24, 0xFD	; 253
    2018:	8c 93       	st	X, r24

	HIGH_NIBBLE(high_nibble,data); // get high nibble data 
    201a:	8b 81       	ldd	r24, Y+3	; 0x03
    201c:	80 7f       	andi	r24, 0xF0	; 240
    201e:	8a 83       	std	Y+2, r24	; 0x02
	LOW_NIBBLE(low_nibble,data); // get low nibble data 
    2020:	8b 81       	ldd	r24, Y+3	; 0x03
    2022:	82 95       	swap	r24
    2024:	80 7f       	andi	r24, 0xF0	; 240
    2026:	89 83       	std	Y+1, r24	; 0x01
	
	PORTB &= 0x0f;
    2028:	a8 e3       	ldi	r26, 0x38	; 56
    202a:	b0 e0       	ldi	r27, 0x00	; 0
    202c:	e8 e3       	ldi	r30, 0x38	; 56
    202e:	f0 e0       	ldi	r31, 0x00	; 0
    2030:	80 81       	ld	r24, Z
    2032:	8f 70       	andi	r24, 0x0F	; 15
    2034:	8c 93       	st	X, r24
	PORTB |=high_nibble;// to send high nibble data  
    2036:	a8 e3       	ldi	r26, 0x38	; 56
    2038:	b0 e0       	ldi	r27, 0x00	; 0
    203a:	e8 e3       	ldi	r30, 0x38	; 56
    203c:	f0 e0       	ldi	r31, 0x00	; 0
    203e:	90 81       	ld	r25, Z
    2040:	8a 81       	ldd	r24, Y+2	; 0x02
    2042:	89 2b       	or	r24, r25
    2044:	8c 93       	st	X, r24
	enableTrigger(); // triggre lcd enable 
    2046:	0e 94 94 0e 	call	0x1d28	; 0x1d28 <enableTrigger>
	
	PORTB &=0x0f;
    204a:	a8 e3       	ldi	r26, 0x38	; 56
    204c:	b0 e0       	ldi	r27, 0x00	; 0
    204e:	e8 e3       	ldi	r30, 0x38	; 56
    2050:	f0 e0       	ldi	r31, 0x00	; 0
    2052:	80 81       	ld	r24, Z
    2054:	8f 70       	andi	r24, 0x0F	; 15
    2056:	8c 93       	st	X, r24
	PORTB |=low_nibble; // to send low nibble data 
    2058:	a8 e3       	ldi	r26, 0x38	; 56
    205a:	b0 e0       	ldi	r27, 0x00	; 0
    205c:	e8 e3       	ldi	r30, 0x38	; 56
    205e:	f0 e0       	ldi	r31, 0x00	; 0
    2060:	90 81       	ld	r25, Z
    2062:	89 81       	ldd	r24, Y+1	; 0x01
    2064:	89 2b       	or	r24, r25
    2066:	8c 93       	st	X, r24
	enableTrigger();
    2068:	0e 94 94 0e 	call	0x1d28	; 0x1d28 <enableTrigger>
	

}
    206c:	0f 90       	pop	r0
    206e:	0f 90       	pop	r0
    2070:	0f 90       	pop	r0
    2072:	cf 91       	pop	r28
    2074:	df 91       	pop	r29
    2076:	08 95       	ret

00002078 <lcd_gotoxy>:


void lcd_gotoxy(unsigned char y , unsigned char x )
{
    2078:	df 93       	push	r29
    207a:	cf 93       	push	r28
    207c:	00 d0       	rcall	.+0      	; 0x207e <lcd_gotoxy+0x6>
    207e:	00 d0       	rcall	.+0      	; 0x2080 <lcd_gotoxy+0x8>
    2080:	0f 92       	push	r0
    2082:	cd b7       	in	r28, 0x3d	; 61
    2084:	de b7       	in	r29, 0x3e	; 62
    2086:	8a 83       	std	Y+2, r24	; 0x02
    2088:	6b 83       	std	Y+3, r22	; 0x03
	unsigned char position = 0x80;
    208a:	80 e8       	ldi	r24, 0x80	; 128
    208c:	89 83       	std	Y+1, r24	; 0x01
	 
	switch(y)
    208e:	8a 81       	ldd	r24, Y+2	; 0x02
    2090:	28 2f       	mov	r18, r24
    2092:	30 e0       	ldi	r19, 0x00	; 0
    2094:	3d 83       	std	Y+5, r19	; 0x05
    2096:	2c 83       	std	Y+4, r18	; 0x04
    2098:	8c 81       	ldd	r24, Y+4	; 0x04
    209a:	9d 81       	ldd	r25, Y+5	; 0x05
    209c:	81 30       	cpi	r24, 0x01	; 1
    209e:	91 05       	cpc	r25, r1
    20a0:	d1 f0       	breq	.+52     	; 0x20d6 <lcd_gotoxy+0x5e>
    20a2:	2c 81       	ldd	r18, Y+4	; 0x04
    20a4:	3d 81       	ldd	r19, Y+5	; 0x05
    20a6:	22 30       	cpi	r18, 0x02	; 2
    20a8:	31 05       	cpc	r19, r1
    20aa:	2c f4       	brge	.+10     	; 0x20b6 <lcd_gotoxy+0x3e>
    20ac:	8c 81       	ldd	r24, Y+4	; 0x04
    20ae:	9d 81       	ldd	r25, Y+5	; 0x05
    20b0:	00 97       	sbiw	r24, 0x00	; 0
    20b2:	61 f0       	breq	.+24     	; 0x20cc <lcd_gotoxy+0x54>
    20b4:	20 c0       	rjmp	.+64     	; 0x20f6 <lcd_gotoxy+0x7e>
    20b6:	2c 81       	ldd	r18, Y+4	; 0x04
    20b8:	3d 81       	ldd	r19, Y+5	; 0x05
    20ba:	22 30       	cpi	r18, 0x02	; 2
    20bc:	31 05       	cpc	r19, r1
    20be:	91 f0       	breq	.+36     	; 0x20e4 <lcd_gotoxy+0x6c>
    20c0:	8c 81       	ldd	r24, Y+4	; 0x04
    20c2:	9d 81       	ldd	r25, Y+5	; 0x05
    20c4:	83 30       	cpi	r24, 0x03	; 3
    20c6:	91 05       	cpc	r25, r1
    20c8:	91 f0       	breq	.+36     	; 0x20ee <lcd_gotoxy+0x76>
    20ca:	15 c0       	rjmp	.+42     	; 0x20f6 <lcd_gotoxy+0x7e>
	{
		case 0:

			position=position+x;
    20cc:	89 81       	ldd	r24, Y+1	; 0x01
    20ce:	9b 81       	ldd	r25, Y+3	; 0x03
    20d0:	89 0f       	add	r24, r25
    20d2:	89 83       	std	Y+1, r24	; 0x01
    20d4:	10 c0       	rjmp	.+32     	; 0x20f6 <lcd_gotoxy+0x7e>
					
		break;

		case 1:

			position=0xc0;
    20d6:	80 ec       	ldi	r24, 0xC0	; 192
    20d8:	89 83       	std	Y+1, r24	; 0x01
			position=position+x;
    20da:	99 81       	ldd	r25, Y+1	; 0x01
    20dc:	8b 81       	ldd	r24, Y+3	; 0x03
    20de:	89 0f       	add	r24, r25
    20e0:	89 83       	std	Y+1, r24	; 0x01
    20e2:	09 c0       	rjmp	.+18     	; 0x20f6 <lcd_gotoxy+0x7e>

		break;

		case 2:

			position=position+x;
    20e4:	89 81       	ldd	r24, Y+1	; 0x01
    20e6:	9b 81       	ldd	r25, Y+3	; 0x03
    20e8:	89 0f       	add	r24, r25
    20ea:	89 83       	std	Y+1, r24	; 0x01
    20ec:	04 c0       	rjmp	.+8      	; 0x20f6 <lcd_gotoxy+0x7e>

		break;

		case 3:
			position=position+x;
    20ee:	89 81       	ldd	r24, Y+1	; 0x01
    20f0:	9b 81       	ldd	r25, Y+3	; 0x03
    20f2:	89 0f       	add	r24, r25
    20f4:	89 83       	std	Y+1, r24	; 0x01
		break;
	
	
	}
	
	lcd_sendCommand(position); 	
    20f6:	89 81       	ldd	r24, Y+1	; 0x01
    20f8:	0e 94 b4 0f 	call	0x1f68	; 0x1f68 <lcd_sendCommand>


}
    20fc:	0f 90       	pop	r0
    20fe:	0f 90       	pop	r0
    2100:	0f 90       	pop	r0
    2102:	0f 90       	pop	r0
    2104:	0f 90       	pop	r0
    2106:	cf 91       	pop	r28
    2108:	df 91       	pop	r29
    210a:	08 95       	ret

0000210c <lcd_clrScreen>:


void lcd_clrScreen(void)
{
    210c:	df 93       	push	r29
    210e:	cf 93       	push	r28
    2110:	cd b7       	in	r28, 0x3d	; 61
    2112:	de b7       	in	r29, 0x3e	; 62

	lcd_sendCommand(0x01);
    2114:	81 e0       	ldi	r24, 0x01	; 1
    2116:	0e 94 b4 0f 	call	0x1f68	; 0x1f68 <lcd_sendCommand>


}
    211a:	cf 91       	pop	r28
    211c:	df 91       	pop	r29
    211e:	08 95       	ret

00002120 <lcd_dispString>:


void lcd_dispString(char * ptr)
{
    2120:	df 93       	push	r29
    2122:	cf 93       	push	r28
    2124:	00 d0       	rcall	.+0      	; 0x2126 <lcd_dispString+0x6>
    2126:	cd b7       	in	r28, 0x3d	; 61
    2128:	de b7       	in	r29, 0x3e	; 62
    212a:	9a 83       	std	Y+2, r25	; 0x02
    212c:	89 83       	std	Y+1, r24	; 0x01
    212e:	0a c0       	rjmp	.+20     	; 0x2144 <lcd_dispString+0x24>

	while(* ptr!= '\0')
	{
		lcd_displayChar(* ptr);
    2130:	e9 81       	ldd	r30, Y+1	; 0x01
    2132:	fa 81       	ldd	r31, Y+2	; 0x02
    2134:	80 81       	ld	r24, Z
    2136:	0e 94 f8 0f 	call	0x1ff0	; 0x1ff0 <lcd_displayChar>
		ptr++;
    213a:	89 81       	ldd	r24, Y+1	; 0x01
    213c:	9a 81       	ldd	r25, Y+2	; 0x02
    213e:	01 96       	adiw	r24, 0x01	; 1
    2140:	9a 83       	std	Y+2, r25	; 0x02
    2142:	89 83       	std	Y+1, r24	; 0x01


void lcd_dispString(char * ptr)
{

	while(* ptr!= '\0')
    2144:	e9 81       	ldd	r30, Y+1	; 0x01
    2146:	fa 81       	ldd	r31, Y+2	; 0x02
    2148:	80 81       	ld	r24, Z
    214a:	88 23       	and	r24, r24
    214c:	89 f7       	brne	.-30     	; 0x2130 <lcd_dispString+0x10>
		lcd_displayChar(* ptr);
		ptr++;
	
	}

}
    214e:	0f 90       	pop	r0
    2150:	0f 90       	pop	r0
    2152:	cf 91       	pop	r28
    2154:	df 91       	pop	r29
    2156:	08 95       	ret

00002158 <lcd_disp_string_xy>:

void lcd_disp_string_xy(char * ptr , int y , int x)
{
    2158:	df 93       	push	r29
    215a:	cf 93       	push	r28
    215c:	00 d0       	rcall	.+0      	; 0x215e <lcd_disp_string_xy+0x6>
    215e:	00 d0       	rcall	.+0      	; 0x2160 <lcd_disp_string_xy+0x8>
    2160:	00 d0       	rcall	.+0      	; 0x2162 <lcd_disp_string_xy+0xa>
    2162:	cd b7       	in	r28, 0x3d	; 61
    2164:	de b7       	in	r29, 0x3e	; 62
    2166:	9a 83       	std	Y+2, r25	; 0x02
    2168:	89 83       	std	Y+1, r24	; 0x01
    216a:	7c 83       	std	Y+4, r23	; 0x04
    216c:	6b 83       	std	Y+3, r22	; 0x03
    216e:	5e 83       	std	Y+6, r21	; 0x06
    2170:	4d 83       	std	Y+5, r20	; 0x05

	lcd_gotoxy(y,x);
    2172:	8b 81       	ldd	r24, Y+3	; 0x03
    2174:	9d 81       	ldd	r25, Y+5	; 0x05
    2176:	69 2f       	mov	r22, r25
    2178:	0e 94 3c 10 	call	0x2078	; 0x2078 <lcd_gotoxy>
	lcd_dispString(ptr);
    217c:	89 81       	ldd	r24, Y+1	; 0x01
    217e:	9a 81       	ldd	r25, Y+2	; 0x02
    2180:	0e 94 90 10 	call	0x2120	; 0x2120 <lcd_dispString>

	


}
    2184:	26 96       	adiw	r28, 0x06	; 6
    2186:	0f b6       	in	r0, 0x3f	; 63
    2188:	f8 94       	cli
    218a:	de bf       	out	0x3e, r29	; 62
    218c:	0f be       	out	0x3f, r0	; 63
    218e:	cd bf       	out	0x3d, r28	; 61
    2190:	cf 91       	pop	r28
    2192:	df 91       	pop	r29
    2194:	08 95       	ret

00002196 <LED_Init>:
 */

#include "led.h"

void LED_Init(void)
{
    2196:	df 93       	push	r29
    2198:	cf 93       	push	r28
    219a:	cd b7       	in	r28, 0x3d	; 61
    219c:	de b7       	in	r29, 0x3e	; 62
	DIO_SetPinDirection(PinA2,OUTPUT);
    219e:	82 e0       	ldi	r24, 0x02	; 2
    21a0:	61 e0       	ldi	r22, 0x01	; 1
    21a2:	0e 94 09 07 	call	0xe12	; 0xe12 <DIO_SetPinDirection>
	DIO_WritePin(PinA2,LOW);
    21a6:	82 e0       	ldi	r24, 0x02	; 2
    21a8:	60 e0       	ldi	r22, 0x00	; 0
    21aa:	0e 94 a3 05 	call	0xb46	; 0xb46 <DIO_WritePin>
	DIO_SetPinDirection(PinA3,OUTPUT);
    21ae:	83 e0       	ldi	r24, 0x03	; 3
    21b0:	61 e0       	ldi	r22, 0x01	; 1
    21b2:	0e 94 09 07 	call	0xe12	; 0xe12 <DIO_SetPinDirection>
	DIO_WritePin(PinA3,LOW);
    21b6:	83 e0       	ldi	r24, 0x03	; 3
    21b8:	60 e0       	ldi	r22, 0x00	; 0
    21ba:	0e 94 a3 05 	call	0xb46	; 0xb46 <DIO_WritePin>
}
    21be:	cf 91       	pop	r28
    21c0:	df 91       	pop	r29
    21c2:	08 95       	ret

000021c4 <LED_Toggle>:

void LED_Toggle(void)
{
    21c4:	df 93       	push	r29
    21c6:	cf 93       	push	r28
    21c8:	cd b7       	in	r28, 0x3d	; 61
    21ca:	de b7       	in	r29, 0x3e	; 62
	PORTA^=(1<<2);
    21cc:	ab e3       	ldi	r26, 0x3B	; 59
    21ce:	b0 e0       	ldi	r27, 0x00	; 0
    21d0:	eb e3       	ldi	r30, 0x3B	; 59
    21d2:	f0 e0       	ldi	r31, 0x00	; 0
    21d4:	90 81       	ld	r25, Z
    21d6:	84 e0       	ldi	r24, 0x04	; 4
    21d8:	89 27       	eor	r24, r25
    21da:	8c 93       	st	X, r24
}
    21dc:	cf 91       	pop	r28
    21de:	df 91       	pop	r29
    21e0:	08 95       	ret

000021e2 <LED_Write>:
void LED_Write(uint8 led_num,uint8 state)
{
    21e2:	df 93       	push	r29
    21e4:	cf 93       	push	r28
    21e6:	00 d0       	rcall	.+0      	; 0x21e8 <LED_Write+0x6>
    21e8:	00 d0       	rcall	.+0      	; 0x21ea <LED_Write+0x8>
    21ea:	cd b7       	in	r28, 0x3d	; 61
    21ec:	de b7       	in	r29, 0x3e	; 62
    21ee:	89 83       	std	Y+1, r24	; 0x01
    21f0:	6a 83       	std	Y+2, r22	; 0x02
	switch (led_num)
    21f2:	89 81       	ldd	r24, Y+1	; 0x01
    21f4:	28 2f       	mov	r18, r24
    21f6:	30 e0       	ldi	r19, 0x00	; 0
    21f8:	3c 83       	std	Y+4, r19	; 0x04
    21fa:	2b 83       	std	Y+3, r18	; 0x03
    21fc:	8b 81       	ldd	r24, Y+3	; 0x03
    21fe:	9c 81       	ldd	r25, Y+4	; 0x04
    2200:	81 30       	cpi	r24, 0x01	; 1
    2202:	91 05       	cpc	r25, r1
    2204:	31 f0       	breq	.+12     	; 0x2212 <LED_Write+0x30>
    2206:	2b 81       	ldd	r18, Y+3	; 0x03
    2208:	3c 81       	ldd	r19, Y+4	; 0x04
    220a:	22 30       	cpi	r18, 0x02	; 2
    220c:	31 05       	cpc	r19, r1
    220e:	71 f0       	breq	.+28     	; 0x222c <LED_Write+0x4a>
    2210:	19 c0       	rjmp	.+50     	; 0x2244 <LED_Write+0x62>
	{
	case 1:
		if(state==1)
    2212:	8a 81       	ldd	r24, Y+2	; 0x02
    2214:	81 30       	cpi	r24, 0x01	; 1
    2216:	29 f4       	brne	.+10     	; 0x2222 <LED_Write+0x40>
		{
		DIO_WritePin(PinA2,HIGH);
    2218:	82 e0       	ldi	r24, 0x02	; 2
    221a:	61 e0       	ldi	r22, 0x01	; 1
    221c:	0e 94 a3 05 	call	0xb46	; 0xb46 <DIO_WritePin>
    2220:	11 c0       	rjmp	.+34     	; 0x2244 <LED_Write+0x62>
		}
		else
		{
			DIO_WritePin(PinA2,LOW);
    2222:	82 e0       	ldi	r24, 0x02	; 2
    2224:	60 e0       	ldi	r22, 0x00	; 0
    2226:	0e 94 a3 05 	call	0xb46	; 0xb46 <DIO_WritePin>
    222a:	0c c0       	rjmp	.+24     	; 0x2244 <LED_Write+0x62>
		}
		break;
	case 2:
		if(state==1)
    222c:	8a 81       	ldd	r24, Y+2	; 0x02
    222e:	81 30       	cpi	r24, 0x01	; 1
    2230:	29 f4       	brne	.+10     	; 0x223c <LED_Write+0x5a>
		{
			DIO_WritePin(PinA3,HIGH);
    2232:	83 e0       	ldi	r24, 0x03	; 3
    2234:	61 e0       	ldi	r22, 0x01	; 1
    2236:	0e 94 a3 05 	call	0xb46	; 0xb46 <DIO_WritePin>
    223a:	04 c0       	rjmp	.+8      	; 0x2244 <LED_Write+0x62>
		}
		else
		{
			DIO_WritePin(PinA3,HIGH);
    223c:	83 e0       	ldi	r24, 0x03	; 3
    223e:	61 e0       	ldi	r22, 0x01	; 1
    2240:	0e 94 a3 05 	call	0xb46	; 0xb46 <DIO_WritePin>
		}
		break;
	}
}
    2244:	0f 90       	pop	r0
    2246:	0f 90       	pop	r0
    2248:	0f 90       	pop	r0
    224a:	0f 90       	pop	r0
    224c:	cf 91       	pop	r28
    224e:	df 91       	pop	r29
    2250:	08 95       	ret

00002252 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    2252:	df 93       	push	r29
    2254:	cf 93       	push	r28
    2256:	00 d0       	rcall	.+0      	; 0x2258 <vListInitialise+0x6>
    2258:	cd b7       	in	r28, 0x3d	; 61
    225a:	de b7       	in	r29, 0x3e	; 62
    225c:	9a 83       	std	Y+2, r25	; 0x02
    225e:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2260:	89 81       	ldd	r24, Y+1	; 0x01
    2262:	9a 81       	ldd	r25, Y+2	; 0x02
    2264:	03 96       	adiw	r24, 0x03	; 3
    2266:	e9 81       	ldd	r30, Y+1	; 0x01
    2268:	fa 81       	ldd	r31, Y+2	; 0x02
    226a:	92 83       	std	Z+2, r25	; 0x02
    226c:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    226e:	e9 81       	ldd	r30, Y+1	; 0x01
    2270:	fa 81       	ldd	r31, Y+2	; 0x02
    2272:	8f ef       	ldi	r24, 0xFF	; 255
    2274:	9f ef       	ldi	r25, 0xFF	; 255
    2276:	94 83       	std	Z+4, r25	; 0x04
    2278:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    227a:	89 81       	ldd	r24, Y+1	; 0x01
    227c:	9a 81       	ldd	r25, Y+2	; 0x02
    227e:	03 96       	adiw	r24, 0x03	; 3
    2280:	e9 81       	ldd	r30, Y+1	; 0x01
    2282:	fa 81       	ldd	r31, Y+2	; 0x02
    2284:	96 83       	std	Z+6, r25	; 0x06
    2286:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2288:	89 81       	ldd	r24, Y+1	; 0x01
    228a:	9a 81       	ldd	r25, Y+2	; 0x02
    228c:	03 96       	adiw	r24, 0x03	; 3
    228e:	e9 81       	ldd	r30, Y+1	; 0x01
    2290:	fa 81       	ldd	r31, Y+2	; 0x02
    2292:	90 87       	std	Z+8, r25	; 0x08
    2294:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    2296:	e9 81       	ldd	r30, Y+1	; 0x01
    2298:	fa 81       	ldd	r31, Y+2	; 0x02
    229a:	10 82       	st	Z, r1

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
    229c:	0f 90       	pop	r0
    229e:	0f 90       	pop	r0
    22a0:	cf 91       	pop	r28
    22a2:	df 91       	pop	r29
    22a4:	08 95       	ret

000022a6 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    22a6:	df 93       	push	r29
    22a8:	cf 93       	push	r28
    22aa:	00 d0       	rcall	.+0      	; 0x22ac <vListInitialiseItem+0x6>
    22ac:	cd b7       	in	r28, 0x3d	; 61
    22ae:	de b7       	in	r29, 0x3e	; 62
    22b0:	9a 83       	std	Y+2, r25	; 0x02
    22b2:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
    22b4:	e9 81       	ldd	r30, Y+1	; 0x01
    22b6:	fa 81       	ldd	r31, Y+2	; 0x02
    22b8:	11 86       	std	Z+9, r1	; 0x09
    22ba:	10 86       	std	Z+8, r1	; 0x08

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
    22bc:	0f 90       	pop	r0
    22be:	0f 90       	pop	r0
    22c0:	cf 91       	pop	r28
    22c2:	df 91       	pop	r29
    22c4:	08 95       	ret

000022c6 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    22c6:	df 93       	push	r29
    22c8:	cf 93       	push	r28
    22ca:	00 d0       	rcall	.+0      	; 0x22cc <vListInsertEnd+0x6>
    22cc:	00 d0       	rcall	.+0      	; 0x22ce <vListInsertEnd+0x8>
    22ce:	00 d0       	rcall	.+0      	; 0x22d0 <vListInsertEnd+0xa>
    22d0:	cd b7       	in	r28, 0x3d	; 61
    22d2:	de b7       	in	r29, 0x3e	; 62
    22d4:	9c 83       	std	Y+4, r25	; 0x04
    22d6:	8b 83       	std	Y+3, r24	; 0x03
    22d8:	7e 83       	std	Y+6, r23	; 0x06
    22da:	6d 83       	std	Y+5, r22	; 0x05
ListItem_t * const pxIndex = pxList->pxIndex;
    22dc:	eb 81       	ldd	r30, Y+3	; 0x03
    22de:	fc 81       	ldd	r31, Y+4	; 0x04
    22e0:	81 81       	ldd	r24, Z+1	; 0x01
    22e2:	92 81       	ldd	r25, Z+2	; 0x02
    22e4:	9a 83       	std	Y+2, r25	; 0x02
    22e6:	89 83       	std	Y+1, r24	; 0x01
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    22e8:	ed 81       	ldd	r30, Y+5	; 0x05
    22ea:	fe 81       	ldd	r31, Y+6	; 0x06
    22ec:	89 81       	ldd	r24, Y+1	; 0x01
    22ee:	9a 81       	ldd	r25, Y+2	; 0x02
    22f0:	93 83       	std	Z+3, r25	; 0x03
    22f2:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    22f4:	e9 81       	ldd	r30, Y+1	; 0x01
    22f6:	fa 81       	ldd	r31, Y+2	; 0x02
    22f8:	84 81       	ldd	r24, Z+4	; 0x04
    22fa:	95 81       	ldd	r25, Z+5	; 0x05
    22fc:	ed 81       	ldd	r30, Y+5	; 0x05
    22fe:	fe 81       	ldd	r31, Y+6	; 0x06
    2300:	95 83       	std	Z+5, r25	; 0x05
    2302:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    2304:	e9 81       	ldd	r30, Y+1	; 0x01
    2306:	fa 81       	ldd	r31, Y+2	; 0x02
    2308:	04 80       	ldd	r0, Z+4	; 0x04
    230a:	f5 81       	ldd	r31, Z+5	; 0x05
    230c:	e0 2d       	mov	r30, r0
    230e:	8d 81       	ldd	r24, Y+5	; 0x05
    2310:	9e 81       	ldd	r25, Y+6	; 0x06
    2312:	93 83       	std	Z+3, r25	; 0x03
    2314:	82 83       	std	Z+2, r24	; 0x02
	pxIndex->pxPrevious = pxNewListItem;
    2316:	e9 81       	ldd	r30, Y+1	; 0x01
    2318:	fa 81       	ldd	r31, Y+2	; 0x02
    231a:	8d 81       	ldd	r24, Y+5	; 0x05
    231c:	9e 81       	ldd	r25, Y+6	; 0x06
    231e:	95 83       	std	Z+5, r25	; 0x05
    2320:	84 83       	std	Z+4, r24	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
    2322:	ed 81       	ldd	r30, Y+5	; 0x05
    2324:	fe 81       	ldd	r31, Y+6	; 0x06
    2326:	8b 81       	ldd	r24, Y+3	; 0x03
    2328:	9c 81       	ldd	r25, Y+4	; 0x04
    232a:	91 87       	std	Z+9, r25	; 0x09
    232c:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    232e:	eb 81       	ldd	r30, Y+3	; 0x03
    2330:	fc 81       	ldd	r31, Y+4	; 0x04
    2332:	80 81       	ld	r24, Z
    2334:	8f 5f       	subi	r24, 0xFF	; 255
    2336:	eb 81       	ldd	r30, Y+3	; 0x03
    2338:	fc 81       	ldd	r31, Y+4	; 0x04
    233a:	80 83       	st	Z, r24
}
    233c:	26 96       	adiw	r28, 0x06	; 6
    233e:	0f b6       	in	r0, 0x3f	; 63
    2340:	f8 94       	cli
    2342:	de bf       	out	0x3e, r29	; 62
    2344:	0f be       	out	0x3f, r0	; 63
    2346:	cd bf       	out	0x3d, r28	; 61
    2348:	cf 91       	pop	r28
    234a:	df 91       	pop	r29
    234c:	08 95       	ret

0000234e <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    234e:	df 93       	push	r29
    2350:	cf 93       	push	r28
    2352:	cd b7       	in	r28, 0x3d	; 61
    2354:	de b7       	in	r29, 0x3e	; 62
    2356:	28 97       	sbiw	r28, 0x08	; 8
    2358:	0f b6       	in	r0, 0x3f	; 63
    235a:	f8 94       	cli
    235c:	de bf       	out	0x3e, r29	; 62
    235e:	0f be       	out	0x3f, r0	; 63
    2360:	cd bf       	out	0x3d, r28	; 61
    2362:	9e 83       	std	Y+6, r25	; 0x06
    2364:	8d 83       	std	Y+5, r24	; 0x05
    2366:	78 87       	std	Y+8, r23	; 0x08
    2368:	6f 83       	std	Y+7, r22	; 0x07
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    236a:	ef 81       	ldd	r30, Y+7	; 0x07
    236c:	f8 85       	ldd	r31, Y+8	; 0x08
    236e:	80 81       	ld	r24, Z
    2370:	91 81       	ldd	r25, Z+1	; 0x01
    2372:	9a 83       	std	Y+2, r25	; 0x02
    2374:	89 83       	std	Y+1, r24	; 0x01
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    2376:	89 81       	ldd	r24, Y+1	; 0x01
    2378:	9a 81       	ldd	r25, Y+2	; 0x02
    237a:	2f ef       	ldi	r18, 0xFF	; 255
    237c:	8f 3f       	cpi	r24, 0xFF	; 255
    237e:	92 07       	cpc	r25, r18
    2380:	39 f4       	brne	.+14     	; 0x2390 <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    2382:	ed 81       	ldd	r30, Y+5	; 0x05
    2384:	fe 81       	ldd	r31, Y+6	; 0x06
    2386:	87 81       	ldd	r24, Z+7	; 0x07
    2388:	90 85       	ldd	r25, Z+8	; 0x08
    238a:	9c 83       	std	Y+4, r25	; 0x04
    238c:	8b 83       	std	Y+3, r24	; 0x03
    238e:	18 c0       	rjmp	.+48     	; 0x23c0 <vListInsert+0x72>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    2390:	8d 81       	ldd	r24, Y+5	; 0x05
    2392:	9e 81       	ldd	r25, Y+6	; 0x06
    2394:	03 96       	adiw	r24, 0x03	; 3
    2396:	9c 83       	std	Y+4, r25	; 0x04
    2398:	8b 83       	std	Y+3, r24	; 0x03
    239a:	06 c0       	rjmp	.+12     	; 0x23a8 <vListInsert+0x5a>
    239c:	eb 81       	ldd	r30, Y+3	; 0x03
    239e:	fc 81       	ldd	r31, Y+4	; 0x04
    23a0:	82 81       	ldd	r24, Z+2	; 0x02
    23a2:	93 81       	ldd	r25, Z+3	; 0x03
    23a4:	9c 83       	std	Y+4, r25	; 0x04
    23a6:	8b 83       	std	Y+3, r24	; 0x03
    23a8:	eb 81       	ldd	r30, Y+3	; 0x03
    23aa:	fc 81       	ldd	r31, Y+4	; 0x04
    23ac:	02 80       	ldd	r0, Z+2	; 0x02
    23ae:	f3 81       	ldd	r31, Z+3	; 0x03
    23b0:	e0 2d       	mov	r30, r0
    23b2:	20 81       	ld	r18, Z
    23b4:	31 81       	ldd	r19, Z+1	; 0x01
    23b6:	89 81       	ldd	r24, Y+1	; 0x01
    23b8:	9a 81       	ldd	r25, Y+2	; 0x02
    23ba:	82 17       	cp	r24, r18
    23bc:	93 07       	cpc	r25, r19
    23be:	70 f7       	brcc	.-36     	; 0x239c <vListInsert+0x4e>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    23c0:	eb 81       	ldd	r30, Y+3	; 0x03
    23c2:	fc 81       	ldd	r31, Y+4	; 0x04
    23c4:	82 81       	ldd	r24, Z+2	; 0x02
    23c6:	93 81       	ldd	r25, Z+3	; 0x03
    23c8:	ef 81       	ldd	r30, Y+7	; 0x07
    23ca:	f8 85       	ldd	r31, Y+8	; 0x08
    23cc:	93 83       	std	Z+3, r25	; 0x03
    23ce:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    23d0:	ef 81       	ldd	r30, Y+7	; 0x07
    23d2:	f8 85       	ldd	r31, Y+8	; 0x08
    23d4:	02 80       	ldd	r0, Z+2	; 0x02
    23d6:	f3 81       	ldd	r31, Z+3	; 0x03
    23d8:	e0 2d       	mov	r30, r0
    23da:	8f 81       	ldd	r24, Y+7	; 0x07
    23dc:	98 85       	ldd	r25, Y+8	; 0x08
    23de:	95 83       	std	Z+5, r25	; 0x05
    23e0:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    23e2:	ef 81       	ldd	r30, Y+7	; 0x07
    23e4:	f8 85       	ldd	r31, Y+8	; 0x08
    23e6:	8b 81       	ldd	r24, Y+3	; 0x03
    23e8:	9c 81       	ldd	r25, Y+4	; 0x04
    23ea:	95 83       	std	Z+5, r25	; 0x05
    23ec:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = pxNewListItem;
    23ee:	eb 81       	ldd	r30, Y+3	; 0x03
    23f0:	fc 81       	ldd	r31, Y+4	; 0x04
    23f2:	8f 81       	ldd	r24, Y+7	; 0x07
    23f4:	98 85       	ldd	r25, Y+8	; 0x08
    23f6:	93 83       	std	Z+3, r25	; 0x03
    23f8:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
    23fa:	ef 81       	ldd	r30, Y+7	; 0x07
    23fc:	f8 85       	ldd	r31, Y+8	; 0x08
    23fe:	8d 81       	ldd	r24, Y+5	; 0x05
    2400:	9e 81       	ldd	r25, Y+6	; 0x06
    2402:	91 87       	std	Z+9, r25	; 0x09
    2404:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    2406:	ed 81       	ldd	r30, Y+5	; 0x05
    2408:	fe 81       	ldd	r31, Y+6	; 0x06
    240a:	80 81       	ld	r24, Z
    240c:	8f 5f       	subi	r24, 0xFF	; 255
    240e:	ed 81       	ldd	r30, Y+5	; 0x05
    2410:	fe 81       	ldd	r31, Y+6	; 0x06
    2412:	80 83       	st	Z, r24
}
    2414:	28 96       	adiw	r28, 0x08	; 8
    2416:	0f b6       	in	r0, 0x3f	; 63
    2418:	f8 94       	cli
    241a:	de bf       	out	0x3e, r29	; 62
    241c:	0f be       	out	0x3f, r0	; 63
    241e:	cd bf       	out	0x3d, r28	; 61
    2420:	cf 91       	pop	r28
    2422:	df 91       	pop	r29
    2424:	08 95       	ret

00002426 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    2426:	df 93       	push	r29
    2428:	cf 93       	push	r28
    242a:	00 d0       	rcall	.+0      	; 0x242c <uxListRemove+0x6>
    242c:	00 d0       	rcall	.+0      	; 0x242e <uxListRemove+0x8>
    242e:	cd b7       	in	r28, 0x3d	; 61
    2430:	de b7       	in	r29, 0x3e	; 62
    2432:	9c 83       	std	Y+4, r25	; 0x04
    2434:	8b 83       	std	Y+3, r24	; 0x03
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
    2436:	eb 81       	ldd	r30, Y+3	; 0x03
    2438:	fc 81       	ldd	r31, Y+4	; 0x04
    243a:	80 85       	ldd	r24, Z+8	; 0x08
    243c:	91 85       	ldd	r25, Z+9	; 0x09
    243e:	9a 83       	std	Y+2, r25	; 0x02
    2440:	89 83       	std	Y+1, r24	; 0x01

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    2442:	eb 81       	ldd	r30, Y+3	; 0x03
    2444:	fc 81       	ldd	r31, Y+4	; 0x04
    2446:	a2 81       	ldd	r26, Z+2	; 0x02
    2448:	b3 81       	ldd	r27, Z+3	; 0x03
    244a:	eb 81       	ldd	r30, Y+3	; 0x03
    244c:	fc 81       	ldd	r31, Y+4	; 0x04
    244e:	84 81       	ldd	r24, Z+4	; 0x04
    2450:	95 81       	ldd	r25, Z+5	; 0x05
    2452:	15 96       	adiw	r26, 0x05	; 5
    2454:	9c 93       	st	X, r25
    2456:	8e 93       	st	-X, r24
    2458:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    245a:	eb 81       	ldd	r30, Y+3	; 0x03
    245c:	fc 81       	ldd	r31, Y+4	; 0x04
    245e:	a4 81       	ldd	r26, Z+4	; 0x04
    2460:	b5 81       	ldd	r27, Z+5	; 0x05
    2462:	eb 81       	ldd	r30, Y+3	; 0x03
    2464:	fc 81       	ldd	r31, Y+4	; 0x04
    2466:	82 81       	ldd	r24, Z+2	; 0x02
    2468:	93 81       	ldd	r25, Z+3	; 0x03
    246a:	13 96       	adiw	r26, 0x03	; 3
    246c:	9c 93       	st	X, r25
    246e:	8e 93       	st	-X, r24
    2470:	12 97       	sbiw	r26, 0x02	; 2

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    2472:	e9 81       	ldd	r30, Y+1	; 0x01
    2474:	fa 81       	ldd	r31, Y+2	; 0x02
    2476:	21 81       	ldd	r18, Z+1	; 0x01
    2478:	32 81       	ldd	r19, Z+2	; 0x02
    247a:	8b 81       	ldd	r24, Y+3	; 0x03
    247c:	9c 81       	ldd	r25, Y+4	; 0x04
    247e:	28 17       	cp	r18, r24
    2480:	39 07       	cpc	r19, r25
    2482:	41 f4       	brne	.+16     	; 0x2494 <uxListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    2484:	eb 81       	ldd	r30, Y+3	; 0x03
    2486:	fc 81       	ldd	r31, Y+4	; 0x04
    2488:	84 81       	ldd	r24, Z+4	; 0x04
    248a:	95 81       	ldd	r25, Z+5	; 0x05
    248c:	e9 81       	ldd	r30, Y+1	; 0x01
    248e:	fa 81       	ldd	r31, Y+2	; 0x02
    2490:	92 83       	std	Z+2, r25	; 0x02
    2492:	81 83       	std	Z+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
    2494:	eb 81       	ldd	r30, Y+3	; 0x03
    2496:	fc 81       	ldd	r31, Y+4	; 0x04
    2498:	11 86       	std	Z+9, r1	; 0x09
    249a:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    249c:	e9 81       	ldd	r30, Y+1	; 0x01
    249e:	fa 81       	ldd	r31, Y+2	; 0x02
    24a0:	80 81       	ld	r24, Z
    24a2:	81 50       	subi	r24, 0x01	; 1
    24a4:	e9 81       	ldd	r30, Y+1	; 0x01
    24a6:	fa 81       	ldd	r31, Y+2	; 0x02
    24a8:	80 83       	st	Z, r24

	return pxList->uxNumberOfItems;
    24aa:	e9 81       	ldd	r30, Y+1	; 0x01
    24ac:	fa 81       	ldd	r31, Y+2	; 0x02
    24ae:	80 81       	ld	r24, Z
}
    24b0:	0f 90       	pop	r0
    24b2:	0f 90       	pop	r0
    24b4:	0f 90       	pop	r0
    24b6:	0f 90       	pop	r0
    24b8:	cf 91       	pop	r28
    24ba:	df 91       	pop	r29
    24bc:	08 95       	ret

000024be <main>:
void A(void);
void C(void);
//void D(void);

int main(void)
{
    24be:	ef 92       	push	r14
    24c0:	ff 92       	push	r15
    24c2:	0f 93       	push	r16
    24c4:	df 93       	push	r29
    24c6:	cf 93       	push	r28
    24c8:	cd b7       	in	r28, 0x3d	; 61
    24ca:	de b7       	in	r29, 0x3e	; 62
	xTaskCreate((TaskFunction_t)InitTask,"init",200,NULL,5,&init_handel);
    24cc:	85 ea       	ldi	r24, 0xA5	; 165
    24ce:	92 e1       	ldi	r25, 0x12	; 18
    24d0:	20 e6       	ldi	r18, 0x60	; 96
    24d2:	30 e0       	ldi	r19, 0x00	; 0
    24d4:	eb e9       	ldi	r30, 0x9B	; 155
    24d6:	f6 e0       	ldi	r31, 0x06	; 6
    24d8:	b9 01       	movw	r22, r18
    24da:	48 ec       	ldi	r20, 0xC8	; 200
    24dc:	50 e0       	ldi	r21, 0x00	; 0
    24de:	20 e0       	ldi	r18, 0x00	; 0
    24e0:	30 e0       	ldi	r19, 0x00	; 0
    24e2:	05 e0       	ldi	r16, 0x05	; 5
    24e4:	7f 01       	movw	r14, r30
    24e6:	0e 94 c3 25 	call	0x4b86	; 0x4b86 <xTaskCreate>
	xTaskCreate((TaskFunction_t)B,"A",100,NULL,5,&B_handel);
    24ea:	8f e1       	ldi	r24, 0x1F	; 31
    24ec:	93 e1       	ldi	r25, 0x13	; 19
    24ee:	25 e6       	ldi	r18, 0x65	; 101
    24f0:	30 e0       	ldi	r19, 0x00	; 0
    24f2:	ef e9       	ldi	r30, 0x9F	; 159
    24f4:	f6 e0       	ldi	r31, 0x06	; 6
    24f6:	b9 01       	movw	r22, r18
    24f8:	44 e6       	ldi	r20, 0x64	; 100
    24fa:	50 e0       	ldi	r21, 0x00	; 0
    24fc:	20 e0       	ldi	r18, 0x00	; 0
    24fe:	30 e0       	ldi	r19, 0x00	; 0
    2500:	05 e0       	ldi	r16, 0x05	; 5
    2502:	7f 01       	movw	r14, r30
    2504:	0e 94 c3 25 	call	0x4b86	; 0x4b86 <xTaskCreate>
	xTaskCreate((TaskFunction_t)A,"B",100,NULL,5,&A_handel);
    2508:	8c ee       	ldi	r24, 0xEC	; 236
    250a:	92 e1       	ldi	r25, 0x12	; 18
    250c:	27 e6       	ldi	r18, 0x67	; 103
    250e:	30 e0       	ldi	r19, 0x00	; 0
    2510:	ed e9       	ldi	r30, 0x9D	; 157
    2512:	f6 e0       	ldi	r31, 0x06	; 6
    2514:	b9 01       	movw	r22, r18
    2516:	44 e6       	ldi	r20, 0x64	; 100
    2518:	50 e0       	ldi	r21, 0x00	; 0
    251a:	20 e0       	ldi	r18, 0x00	; 0
    251c:	30 e0       	ldi	r19, 0x00	; 0
    251e:	05 e0       	ldi	r16, 0x05	; 5
    2520:	7f 01       	movw	r14, r30
    2522:	0e 94 c3 25 	call	0x4b86	; 0x4b86 <xTaskCreate>
	xTaskCreate((TaskFunction_t)C,"C",100,NULL,2,&C_handel);
    2526:	82 e5       	ldi	r24, 0x52	; 82
    2528:	93 e1       	ldi	r25, 0x13	; 19
    252a:	29 e6       	ldi	r18, 0x69	; 105
    252c:	30 e0       	ldi	r19, 0x00	; 0
    252e:	e1 ea       	ldi	r30, 0xA1	; 161
    2530:	f6 e0       	ldi	r31, 0x06	; 6
    2532:	b9 01       	movw	r22, r18
    2534:	44 e6       	ldi	r20, 0x64	; 100
    2536:	50 e0       	ldi	r21, 0x00	; 0
    2538:	20 e0       	ldi	r18, 0x00	; 0
    253a:	30 e0       	ldi	r19, 0x00	; 0
    253c:	02 e0       	ldi	r16, 0x02	; 2
    253e:	7f 01       	movw	r14, r30
    2540:	0e 94 c3 25 	call	0x4b86	; 0x4b86 <xTaskCreate>
	//	xTaskCreate((TaskFunction_t)D,"D",100,NULL,4,&D_handel);
	//	LED_Write(1,HIGH);
	/* Start Scheduler */
	vTaskStartScheduler();
    2544:	0e 94 70 29 	call	0x52e0	; 0x52e0 <vTaskStartScheduler>
    2548:	ff cf       	rjmp	.-2      	; 0x2548 <main+0x8a>

0000254a <InitTask>:

	}
	return 0;
}
void InitTask(void)
{
    254a:	df 93       	push	r29
    254c:	cf 93       	push	r28
    254e:	cd b7       	in	r28, 0x3d	; 61
    2550:	de b7       	in	r29, 0x3e	; 62
	for(;;)
	{
		LED_Init();
    2552:	0e 94 cb 10 	call	0x2196	; 0x2196 <LED_Init>
		BUTTON_Init(2);
    2556:	82 e0       	ldi	r24, 0x02	; 2
    2558:	0e 94 ac 09 	call	0x1358	; 0x1358 <BUTTON_Init>
		vTaskDelay(10);
    255c:	8a e0       	ldi	r24, 0x0A	; 10
    255e:	90 e0       	ldi	r25, 0x00	; 0
    2560:	0e 94 e1 27 	call	0x4fc2	; 0x4fc2 <vTaskDelay>
		BUTTON_Init(1);
    2564:	81 e0       	ldi	r24, 0x01	; 1
    2566:	0e 94 ac 09 	call	0x1358	; 0x1358 <BUTTON_Init>
		vTaskDelay(10);
    256a:	8a e0       	ldi	r24, 0x0A	; 10
    256c:	90 e0       	ldi	r25, 0x00	; 0
    256e:	0e 94 e1 27 	call	0x4fc2	; 0x4fc2 <vTaskDelay>
		lcd_init();
    2572:	0e 94 99 0f 	call	0x1f32	; 0x1f32 <lcd_init>
		vTaskDelay(10);
    2576:	8a e0       	ldi	r24, 0x0A	; 10
    2578:	90 e0       	ldi	r25, 0x00	; 0
    257a:	0e 94 e1 27 	call	0x4fc2	; 0x4fc2 <vTaskDelay>
		/* Attempt to create a semaphore. */
		xSemaphore2 = xSemaphoreCreateBinary();
    257e:	81 e0       	ldi	r24, 0x01	; 1
    2580:	60 e0       	ldi	r22, 0x00	; 0
    2582:	43 e0       	ldi	r20, 0x03	; 3
    2584:	0e 94 73 17 	call	0x2ee6	; 0x2ee6 <xQueueGenericCreate>
    2588:	90 93 17 07 	sts	0x0717, r25
    258c:	80 93 16 07 	sts	0x0716, r24
		xSemaphore1 = xSemaphoreCreateBinary();
    2590:	81 e0       	ldi	r24, 0x01	; 1
    2592:	60 e0       	ldi	r22, 0x00	; 0
    2594:	43 e0       	ldi	r20, 0x03	; 3
    2596:	0e 94 73 17 	call	0x2ee6	; 0x2ee6 <xQueueGenericCreate>
    259a:	90 93 15 07 	sts	0x0715, r25
    259e:	80 93 14 07 	sts	0x0714, r24
		xSemaphoreCount_1 = xSemaphoreCreateCounting((UBaseType_t)10,(UBaseType_t)0);
    25a2:	8a e0       	ldi	r24, 0x0A	; 10
    25a4:	60 e0       	ldi	r22, 0x00	; 0
    25a6:	0e 94 ff 17 	call	0x2ffe	; 0x2ffe <xQueueCreateCountingSemaphore>
    25aa:	90 93 19 07 	sts	0x0719, r25
    25ae:	80 93 18 07 	sts	0x0718, r24
		xSemaphoreCount_2 = xSemaphoreCreateCounting((UBaseType_t)10,(UBaseType_t)0);
    25b2:	8a e0       	ldi	r24, 0x0A	; 10
    25b4:	60 e0       	ldi	r22, 0x00	; 0
    25b6:	0e 94 ff 17 	call	0x2ffe	; 0x2ffe <xQueueCreateCountingSemaphore>
    25ba:	90 93 13 07 	sts	0x0713, r25
    25be:	80 93 12 07 	sts	0x0712, r24
		vTaskDelay(10);
    25c2:	8a e0       	ldi	r24, 0x0A	; 10
    25c4:	90 e0       	ldi	r25, 0x00	; 0
    25c6:	0e 94 e1 27 	call	0x4fc2	; 0x4fc2 <vTaskDelay>
		vTaskSuspend(init_handel);
    25ca:	80 91 9b 06 	lds	r24, 0x069B
    25ce:	90 91 9c 06 	lds	r25, 0x069C
    25d2:	0e 94 03 28 	call	0x5006	; 0x5006 <vTaskSuspend>
    25d6:	bd cf       	rjmp	.-134    	; 0x2552 <InitTask+0x8>

000025d8 <A>:
	}
}
void A(void)
{
    25d8:	df 93       	push	r29
    25da:	cf 93       	push	r28
    25dc:	cd b7       	in	r28, 0x3d	; 61
    25de:	de b7       	in	r29, 0x3e	; 62
	vTaskDelay(50);
    25e0:	82 e3       	ldi	r24, 0x32	; 50
    25e2:	90 e0       	ldi	r25, 0x00	; 0
    25e4:	0e 94 e1 27 	call	0x4fc2	; 0x4fc2 <vTaskDelay>
	for(;;)
	{
		if(!BUTTON_GitButtonState(1))
    25e8:	81 e0       	ldi	r24, 0x01	; 1
    25ea:	0e 94 cd 09 	call	0x139a	; 0x139a <BUTTON_GitButtonState>
    25ee:	88 23       	and	r24, r24
    25f0:	09 f5       	brne	.+66     	; 0x2634 <A+0x5c>
		{
			vTaskDelay(10);
    25f2:	8a e0       	ldi	r24, 0x0A	; 10
    25f4:	90 e0       	ldi	r25, 0x00	; 0
    25f6:	0e 94 e1 27 	call	0x4fc2	; 0x4fc2 <vTaskDelay>
			if(!BUTTON_GitButtonState(1))
    25fa:	81 e0       	ldi	r24, 0x01	; 1
    25fc:	0e 94 cd 09 	call	0x139a	; 0x139a <BUTTON_GitButtonState>
    2600:	88 23       	and	r24, r24
    2602:	c1 f4       	brne	.+48     	; 0x2634 <A+0x5c>
			{
				xSemaphoreGive(xSemaphoreCount_2);
    2604:	80 91 12 07 	lds	r24, 0x0712
    2608:	90 91 13 07 	lds	r25, 0x0713
    260c:	60 e0       	ldi	r22, 0x00	; 0
    260e:	70 e0       	ldi	r23, 0x00	; 0
    2610:	40 e0       	ldi	r20, 0x00	; 0
    2612:	50 e0       	ldi	r21, 0x00	; 0
    2614:	20 e0       	ldi	r18, 0x00	; 0
    2616:	0e 94 1f 18 	call	0x303e	; 0x303e <xQueueGenericSend>
				if (xSemaphoreTake(xSemaphoreCount_1,0) == pdTRUE)
    261a:	80 91 18 07 	lds	r24, 0x0718
    261e:	90 91 19 07 	lds	r25, 0x0719
    2622:	60 e0       	ldi	r22, 0x00	; 0
    2624:	70 e0       	ldi	r23, 0x00	; 0
    2626:	0e 94 1f 1a 	call	0x343e	; 0x343e <xQueueSemaphoreTake>
				{

				}
				while(!BUTTON_GitButtonState(1));
    262a:	81 e0       	ldi	r24, 0x01	; 1
    262c:	0e 94 cd 09 	call	0x139a	; 0x139a <BUTTON_GitButtonState>
    2630:	88 23       	and	r24, r24
    2632:	d9 f3       	breq	.-10     	; 0x262a <A+0x52>
			}
		}
		vTaskDelay(5);
    2634:	85 e0       	ldi	r24, 0x05	; 5
    2636:	90 e0       	ldi	r25, 0x00	; 0
    2638:	0e 94 e1 27 	call	0x4fc2	; 0x4fc2 <vTaskDelay>
    263c:	d5 cf       	rjmp	.-86     	; 0x25e8 <A+0x10>

0000263e <B>:
	}
}
void B(void)
{
    263e:	df 93       	push	r29
    2640:	cf 93       	push	r28
    2642:	cd b7       	in	r28, 0x3d	; 61
    2644:	de b7       	in	r29, 0x3e	; 62
	vTaskDelay(50);
    2646:	82 e3       	ldi	r24, 0x32	; 50
    2648:	90 e0       	ldi	r25, 0x00	; 0
    264a:	0e 94 e1 27 	call	0x4fc2	; 0x4fc2 <vTaskDelay>
	for(;;)
	{
		if(!BUTTON_GitButtonState(2))
    264e:	82 e0       	ldi	r24, 0x02	; 2
    2650:	0e 94 cd 09 	call	0x139a	; 0x139a <BUTTON_GitButtonState>
    2654:	88 23       	and	r24, r24
    2656:	09 f5       	brne	.+66     	; 0x269a <B+0x5c>
		{
			vTaskDelay(10);
    2658:	8a e0       	ldi	r24, 0x0A	; 10
    265a:	90 e0       	ldi	r25, 0x00	; 0
    265c:	0e 94 e1 27 	call	0x4fc2	; 0x4fc2 <vTaskDelay>
			if(!BUTTON_GitButtonState(2))
    2660:	82 e0       	ldi	r24, 0x02	; 2
    2662:	0e 94 cd 09 	call	0x139a	; 0x139a <BUTTON_GitButtonState>
    2666:	88 23       	and	r24, r24
    2668:	c1 f4       	brne	.+48     	; 0x269a <B+0x5c>
			{
				xSemaphoreGive(xSemaphoreCount_1);
    266a:	80 91 18 07 	lds	r24, 0x0718
    266e:	90 91 19 07 	lds	r25, 0x0719
    2672:	60 e0       	ldi	r22, 0x00	; 0
    2674:	70 e0       	ldi	r23, 0x00	; 0
    2676:	40 e0       	ldi	r20, 0x00	; 0
    2678:	50 e0       	ldi	r21, 0x00	; 0
    267a:	20 e0       	ldi	r18, 0x00	; 0
    267c:	0e 94 1f 18 	call	0x303e	; 0x303e <xQueueGenericSend>
				if (xSemaphoreTake(xSemaphoreCount_2,0) == pdTRUE)
    2680:	80 91 12 07 	lds	r24, 0x0712
    2684:	90 91 13 07 	lds	r25, 0x0713
    2688:	60 e0       	ldi	r22, 0x00	; 0
    268a:	70 e0       	ldi	r23, 0x00	; 0
    268c:	0e 94 1f 1a 	call	0x343e	; 0x343e <xQueueSemaphoreTake>
				{

				}
				while(!BUTTON_GitButtonState(2));
    2690:	82 e0       	ldi	r24, 0x02	; 2
    2692:	0e 94 cd 09 	call	0x139a	; 0x139a <BUTTON_GitButtonState>
    2696:	88 23       	and	r24, r24
    2698:	d9 f3       	breq	.-10     	; 0x2690 <B+0x52>
			}
		}
		vTaskDelay(5);
    269a:	85 e0       	ldi	r24, 0x05	; 5
    269c:	90 e0       	ldi	r25, 0x00	; 0
    269e:	0e 94 e1 27 	call	0x4fc2	; 0x4fc2 <vTaskDelay>
    26a2:	d5 cf       	rjmp	.-86     	; 0x264e <B+0x10>

000026a4 <C>:
	}
}
void C(void)
{
    26a4:	df 93       	push	r29
    26a6:	cf 93       	push	r28
    26a8:	cd b7       	in	r28, 0x3d	; 61
    26aa:	de b7       	in	r29, 0x3e	; 62
	static UBaseType_t playerOneCount=0;
	static UBaseType_t playerTwoCount=0;
	static uint32 taskCount=0;
	vTaskDelay(50);
    26ac:	82 e3       	ldi	r24, 0x32	; 50
    26ae:	90 e0       	ldi	r25, 0x00	; 0
    26b0:	0e 94 e1 27 	call	0x4fc2	; 0x4fc2 <vTaskDelay>
	for(;;)
	{

		playerOneCount=uxSemaphoreGetCount(xSemaphoreCount_1);
    26b4:	80 91 18 07 	lds	r24, 0x0718
    26b8:	90 91 19 07 	lds	r25, 0x0719
    26bc:	0e 94 03 1c 	call	0x3806	; 0x3806 <uxQueueMessagesWaiting>
    26c0:	80 93 a8 06 	sts	0x06A8, r24
		playerTwoCount=uxSemaphoreGetCount(xSemaphoreCount_2);
    26c4:	80 91 12 07 	lds	r24, 0x0712
    26c8:	90 91 13 07 	lds	r25, 0x0713
    26cc:	0e 94 03 1c 	call	0x3806	; 0x3806 <uxQueueMessagesWaiting>
    26d0:	80 93 a7 06 	sts	0x06A7, r24

		if(playerOneCount==10)
    26d4:	80 91 a8 06 	lds	r24, 0x06A8
    26d8:	8a 30       	cpi	r24, 0x0A	; 10
    26da:	09 f0       	breq	.+2      	; 0x26de <C+0x3a>
    26dc:	47 c0       	rjmp	.+142    	; 0x276c <C+0xc8>
		{
			lcd_disp_string_xy("player one win",0,0);
    26de:	8b e6       	ldi	r24, 0x6B	; 107
    26e0:	90 e0       	ldi	r25, 0x00	; 0
    26e2:	60 e0       	ldi	r22, 0x00	; 0
    26e4:	70 e0       	ldi	r23, 0x00	; 0
    26e6:	40 e0       	ldi	r20, 0x00	; 0
    26e8:	50 e0       	ldi	r21, 0x00	; 0
    26ea:	0e 94 ac 10 	call	0x2158	; 0x2158 <lcd_disp_string_xy>
			taskCount++;
    26ee:	80 91 a3 06 	lds	r24, 0x06A3
    26f2:	90 91 a4 06 	lds	r25, 0x06A4
    26f6:	a0 91 a5 06 	lds	r26, 0x06A5
    26fa:	b0 91 a6 06 	lds	r27, 0x06A6
    26fe:	01 96       	adiw	r24, 0x01	; 1
    2700:	a1 1d       	adc	r26, r1
    2702:	b1 1d       	adc	r27, r1
    2704:	80 93 a3 06 	sts	0x06A3, r24
    2708:	90 93 a4 06 	sts	0x06A4, r25
    270c:	a0 93 a5 06 	sts	0x06A5, r26
    2710:	b0 93 a6 06 	sts	0x06A6, r27
			if(taskCount==10)
    2714:	80 91 a3 06 	lds	r24, 0x06A3
    2718:	90 91 a4 06 	lds	r25, 0x06A4
    271c:	a0 91 a5 06 	lds	r26, 0x06A5
    2720:	b0 91 a6 06 	lds	r27, 0x06A6
    2724:	8a 30       	cpi	r24, 0x0A	; 10
    2726:	91 05       	cpc	r25, r1
    2728:	a1 05       	cpc	r26, r1
    272a:	b1 05       	cpc	r27, r1
    272c:	31 f4       	brne	.+12     	; 0x273a <C+0x96>
			{
				vTaskSuspend(C_handel);
    272e:	80 91 a1 06 	lds	r24, 0x06A1
    2732:	90 91 a2 06 	lds	r25, 0x06A2
    2736:	0e 94 03 28 	call	0x5006	; 0x5006 <vTaskSuspend>
			}
			lcd_disp_string_xy("                  ",1,0);
    273a:	8a e7       	ldi	r24, 0x7A	; 122
    273c:	90 e0       	ldi	r25, 0x00	; 0
    273e:	61 e0       	ldi	r22, 0x01	; 1
    2740:	70 e0       	ldi	r23, 0x00	; 0
    2742:	40 e0       	ldi	r20, 0x00	; 0
    2744:	50 e0       	ldi	r21, 0x00	; 0
    2746:	0e 94 ac 10 	call	0x2158	; 0x2158 <lcd_disp_string_xy>
			vTaskDelay(200);
    274a:	88 ec       	ldi	r24, 0xC8	; 200
    274c:	90 e0       	ldi	r25, 0x00	; 0
    274e:	0e 94 e1 27 	call	0x4fc2	; 0x4fc2 <vTaskDelay>
			lcd_disp_string_xy("congratulations",1,0);
    2752:	8d e8       	ldi	r24, 0x8D	; 141
    2754:	90 e0       	ldi	r25, 0x00	; 0
    2756:	61 e0       	ldi	r22, 0x01	; 1
    2758:	70 e0       	ldi	r23, 0x00	; 0
    275a:	40 e0       	ldi	r20, 0x00	; 0
    275c:	50 e0       	ldi	r21, 0x00	; 0
    275e:	0e 94 ac 10 	call	0x2158	; 0x2158 <lcd_disp_string_xy>
			vTaskDelay(200);
    2762:	88 ec       	ldi	r24, 0xC8	; 200
    2764:	90 e0       	ldi	r25, 0x00	; 0
    2766:	0e 94 e1 27 	call	0x4fc2	; 0x4fc2 <vTaskDelay>
    276a:	5e c0       	rjmp	.+188    	; 0x2828 <C+0x184>

		}
		else if(playerTwoCount==10)
    276c:	80 91 a7 06 	lds	r24, 0x06A7
    2770:	8a 30       	cpi	r24, 0x0A	; 10
    2772:	09 f0       	breq	.+2      	; 0x2776 <C+0xd2>
    2774:	47 c0       	rjmp	.+142    	; 0x2804 <C+0x160>
		{
			taskCount++;
    2776:	80 91 a3 06 	lds	r24, 0x06A3
    277a:	90 91 a4 06 	lds	r25, 0x06A4
    277e:	a0 91 a5 06 	lds	r26, 0x06A5
    2782:	b0 91 a6 06 	lds	r27, 0x06A6
    2786:	01 96       	adiw	r24, 0x01	; 1
    2788:	a1 1d       	adc	r26, r1
    278a:	b1 1d       	adc	r27, r1
    278c:	80 93 a3 06 	sts	0x06A3, r24
    2790:	90 93 a4 06 	sts	0x06A4, r25
    2794:	a0 93 a5 06 	sts	0x06A5, r26
    2798:	b0 93 a6 06 	sts	0x06A6, r27
			lcd_disp_string_xy("player Two win",0,0);
    279c:	8d e9       	ldi	r24, 0x9D	; 157
    279e:	90 e0       	ldi	r25, 0x00	; 0
    27a0:	60 e0       	ldi	r22, 0x00	; 0
    27a2:	70 e0       	ldi	r23, 0x00	; 0
    27a4:	40 e0       	ldi	r20, 0x00	; 0
    27a6:	50 e0       	ldi	r21, 0x00	; 0
    27a8:	0e 94 ac 10 	call	0x2158	; 0x2158 <lcd_disp_string_xy>
			if(taskCount==10)
    27ac:	80 91 a3 06 	lds	r24, 0x06A3
    27b0:	90 91 a4 06 	lds	r25, 0x06A4
    27b4:	a0 91 a5 06 	lds	r26, 0x06A5
    27b8:	b0 91 a6 06 	lds	r27, 0x06A6
    27bc:	8a 30       	cpi	r24, 0x0A	; 10
    27be:	91 05       	cpc	r25, r1
    27c0:	a1 05       	cpc	r26, r1
    27c2:	b1 05       	cpc	r27, r1
    27c4:	31 f4       	brne	.+12     	; 0x27d2 <C+0x12e>
			{
				vTaskSuspend(C_handel);
    27c6:	80 91 a1 06 	lds	r24, 0x06A1
    27ca:	90 91 a2 06 	lds	r25, 0x06A2
    27ce:	0e 94 03 28 	call	0x5006	; 0x5006 <vTaskSuspend>
			}
			lcd_disp_string_xy("                  ",1,0);
    27d2:	8a e7       	ldi	r24, 0x7A	; 122
    27d4:	90 e0       	ldi	r25, 0x00	; 0
    27d6:	61 e0       	ldi	r22, 0x01	; 1
    27d8:	70 e0       	ldi	r23, 0x00	; 0
    27da:	40 e0       	ldi	r20, 0x00	; 0
    27dc:	50 e0       	ldi	r21, 0x00	; 0
    27de:	0e 94 ac 10 	call	0x2158	; 0x2158 <lcd_disp_string_xy>
			vTaskDelay(200);
    27e2:	88 ec       	ldi	r24, 0xC8	; 200
    27e4:	90 e0       	ldi	r25, 0x00	; 0
    27e6:	0e 94 e1 27 	call	0x4fc2	; 0x4fc2 <vTaskDelay>
			lcd_disp_string_xy("congratulations",1,0);
    27ea:	8d e8       	ldi	r24, 0x8D	; 141
    27ec:	90 e0       	ldi	r25, 0x00	; 0
    27ee:	61 e0       	ldi	r22, 0x01	; 1
    27f0:	70 e0       	ldi	r23, 0x00	; 0
    27f2:	40 e0       	ldi	r20, 0x00	; 0
    27f4:	50 e0       	ldi	r21, 0x00	; 0
    27f6:	0e 94 ac 10 	call	0x2158	; 0x2158 <lcd_disp_string_xy>
			vTaskDelay(200);
    27fa:	88 ec       	ldi	r24, 0xC8	; 200
    27fc:	90 e0       	ldi	r25, 0x00	; 0
    27fe:	0e 94 e1 27 	call	0x4fc2	; 0x4fc2 <vTaskDelay>
    2802:	12 c0       	rjmp	.+36     	; 0x2828 <C+0x184>
		}
		else
		{
			lcd_gotoxy(0,0);
    2804:	80 e0       	ldi	r24, 0x00	; 0
    2806:	60 e0       	ldi	r22, 0x00	; 0
    2808:	0e 94 3c 10 	call	0x2078	; 0x2078 <lcd_gotoxy>
			lcd_displayChar(playerOneCount + '0');
    280c:	80 91 a8 06 	lds	r24, 0x06A8
    2810:	80 5d       	subi	r24, 0xD0	; 208
    2812:	0e 94 f8 0f 	call	0x1ff0	; 0x1ff0 <lcd_displayChar>
			lcd_gotoxy(1,0);
    2816:	81 e0       	ldi	r24, 0x01	; 1
    2818:	60 e0       	ldi	r22, 0x00	; 0
    281a:	0e 94 3c 10 	call	0x2078	; 0x2078 <lcd_gotoxy>
			lcd_displayChar(playerTwoCount + '0');
    281e:	80 91 a7 06 	lds	r24, 0x06A7
    2822:	80 5d       	subi	r24, 0xD0	; 208
    2824:	0e 94 f8 0f 	call	0x1ff0	; 0x1ff0 <lcd_displayChar>
		}
		vTaskDelay(10);
    2828:	8a e0       	ldi	r24, 0x0A	; 10
    282a:	90 e0       	ldi	r25, 0x00	; 0
    282c:	0e 94 e1 27 	call	0x4fc2	; 0x4fc2 <vTaskDelay>
    2830:	41 cf       	rjmp	.-382    	; 0x26b4 <C+0x10>

00002832 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
    2832:	df 93       	push	r29
    2834:	cf 93       	push	r28
    2836:	cd b7       	in	r28, 0x3d	; 61
    2838:	de b7       	in	r29, 0x3e	; 62
    283a:	28 97       	sbiw	r28, 0x08	; 8
    283c:	0f b6       	in	r0, 0x3f	; 63
    283e:	f8 94       	cli
    2840:	de bf       	out	0x3e, r29	; 62
    2842:	0f be       	out	0x3f, r0	; 63
    2844:	cd bf       	out	0x3d, r28	; 61
    2846:	9c 83       	std	Y+4, r25	; 0x04
    2848:	8b 83       	std	Y+3, r24	; 0x03
    284a:	7e 83       	std	Y+6, r23	; 0x06
    284c:	6d 83       	std	Y+5, r22	; 0x05
    284e:	58 87       	std	Y+8, r21	; 0x08
    2850:	4f 83       	std	Y+7, r20	; 0x07
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    2852:	eb 81       	ldd	r30, Y+3	; 0x03
    2854:	fc 81       	ldd	r31, Y+4	; 0x04
    2856:	81 e1       	ldi	r24, 0x11	; 17
    2858:	80 83       	st	Z, r24
	pxTopOfStack--;
    285a:	8b 81       	ldd	r24, Y+3	; 0x03
    285c:	9c 81       	ldd	r25, Y+4	; 0x04
    285e:	01 97       	sbiw	r24, 0x01	; 1
    2860:	9c 83       	std	Y+4, r25	; 0x04
    2862:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    2864:	eb 81       	ldd	r30, Y+3	; 0x03
    2866:	fc 81       	ldd	r31, Y+4	; 0x04
    2868:	82 e2       	ldi	r24, 0x22	; 34
    286a:	80 83       	st	Z, r24
	pxTopOfStack--;
    286c:	8b 81       	ldd	r24, Y+3	; 0x03
    286e:	9c 81       	ldd	r25, Y+4	; 0x04
    2870:	01 97       	sbiw	r24, 0x01	; 1
    2872:	9c 83       	std	Y+4, r25	; 0x04
    2874:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    2876:	eb 81       	ldd	r30, Y+3	; 0x03
    2878:	fc 81       	ldd	r31, Y+4	; 0x04
    287a:	83 e3       	ldi	r24, 0x33	; 51
    287c:	80 83       	st	Z, r24
	pxTopOfStack--;
    287e:	8b 81       	ldd	r24, Y+3	; 0x03
    2880:	9c 81       	ldd	r25, Y+4	; 0x04
    2882:	01 97       	sbiw	r24, 0x01	; 1
    2884:	9c 83       	std	Y+4, r25	; 0x04
    2886:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
    2888:	8d 81       	ldd	r24, Y+5	; 0x05
    288a:	9e 81       	ldd	r25, Y+6	; 0x06
    288c:	9a 83       	std	Y+2, r25	; 0x02
    288e:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2890:	89 81       	ldd	r24, Y+1	; 0x01
    2892:	eb 81       	ldd	r30, Y+3	; 0x03
    2894:	fc 81       	ldd	r31, Y+4	; 0x04
    2896:	80 83       	st	Z, r24
	pxTopOfStack--;
    2898:	8b 81       	ldd	r24, Y+3	; 0x03
    289a:	9c 81       	ldd	r25, Y+4	; 0x04
    289c:	01 97       	sbiw	r24, 0x01	; 1
    289e:	9c 83       	std	Y+4, r25	; 0x04
    28a0:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    28a2:	89 81       	ldd	r24, Y+1	; 0x01
    28a4:	9a 81       	ldd	r25, Y+2	; 0x02
    28a6:	89 2f       	mov	r24, r25
    28a8:	99 27       	eor	r25, r25
    28aa:	9a 83       	std	Y+2, r25	; 0x02
    28ac:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    28ae:	89 81       	ldd	r24, Y+1	; 0x01
    28b0:	eb 81       	ldd	r30, Y+3	; 0x03
    28b2:	fc 81       	ldd	r31, Y+4	; 0x04
    28b4:	80 83       	st	Z, r24
	pxTopOfStack--;
    28b6:	8b 81       	ldd	r24, Y+3	; 0x03
    28b8:	9c 81       	ldd	r25, Y+4	; 0x04
    28ba:	01 97       	sbiw	r24, 0x01	; 1
    28bc:	9c 83       	std	Y+4, r25	; 0x04
    28be:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    28c0:	eb 81       	ldd	r30, Y+3	; 0x03
    28c2:	fc 81       	ldd	r31, Y+4	; 0x04
    28c4:	10 82       	st	Z, r1
	pxTopOfStack--;
    28c6:	8b 81       	ldd	r24, Y+3	; 0x03
    28c8:	9c 81       	ldd	r25, Y+4	; 0x04
    28ca:	01 97       	sbiw	r24, 0x01	; 1
    28cc:	9c 83       	std	Y+4, r25	; 0x04
    28ce:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    28d0:	eb 81       	ldd	r30, Y+3	; 0x03
    28d2:	fc 81       	ldd	r31, Y+4	; 0x04
    28d4:	80 e8       	ldi	r24, 0x80	; 128
    28d6:	80 83       	st	Z, r24
	pxTopOfStack--;
    28d8:	8b 81       	ldd	r24, Y+3	; 0x03
    28da:	9c 81       	ldd	r25, Y+4	; 0x04
    28dc:	01 97       	sbiw	r24, 0x01	; 1
    28de:	9c 83       	std	Y+4, r25	; 0x04
    28e0:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    28e2:	eb 81       	ldd	r30, Y+3	; 0x03
    28e4:	fc 81       	ldd	r31, Y+4	; 0x04
    28e6:	10 82       	st	Z, r1
	pxTopOfStack--;
    28e8:	8b 81       	ldd	r24, Y+3	; 0x03
    28ea:	9c 81       	ldd	r25, Y+4	; 0x04
    28ec:	01 97       	sbiw	r24, 0x01	; 1
    28ee:	9c 83       	std	Y+4, r25	; 0x04
    28f0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    28f2:	eb 81       	ldd	r30, Y+3	; 0x03
    28f4:	fc 81       	ldd	r31, Y+4	; 0x04
    28f6:	82 e0       	ldi	r24, 0x02	; 2
    28f8:	80 83       	st	Z, r24
	pxTopOfStack--;
    28fa:	8b 81       	ldd	r24, Y+3	; 0x03
    28fc:	9c 81       	ldd	r25, Y+4	; 0x04
    28fe:	01 97       	sbiw	r24, 0x01	; 1
    2900:	9c 83       	std	Y+4, r25	; 0x04
    2902:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    2904:	eb 81       	ldd	r30, Y+3	; 0x03
    2906:	fc 81       	ldd	r31, Y+4	; 0x04
    2908:	83 e0       	ldi	r24, 0x03	; 3
    290a:	80 83       	st	Z, r24
	pxTopOfStack--;
    290c:	8b 81       	ldd	r24, Y+3	; 0x03
    290e:	9c 81       	ldd	r25, Y+4	; 0x04
    2910:	01 97       	sbiw	r24, 0x01	; 1
    2912:	9c 83       	std	Y+4, r25	; 0x04
    2914:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    2916:	eb 81       	ldd	r30, Y+3	; 0x03
    2918:	fc 81       	ldd	r31, Y+4	; 0x04
    291a:	84 e0       	ldi	r24, 0x04	; 4
    291c:	80 83       	st	Z, r24
	pxTopOfStack--;
    291e:	8b 81       	ldd	r24, Y+3	; 0x03
    2920:	9c 81       	ldd	r25, Y+4	; 0x04
    2922:	01 97       	sbiw	r24, 0x01	; 1
    2924:	9c 83       	std	Y+4, r25	; 0x04
    2926:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    2928:	eb 81       	ldd	r30, Y+3	; 0x03
    292a:	fc 81       	ldd	r31, Y+4	; 0x04
    292c:	85 e0       	ldi	r24, 0x05	; 5
    292e:	80 83       	st	Z, r24
	pxTopOfStack--;
    2930:	8b 81       	ldd	r24, Y+3	; 0x03
    2932:	9c 81       	ldd	r25, Y+4	; 0x04
    2934:	01 97       	sbiw	r24, 0x01	; 1
    2936:	9c 83       	std	Y+4, r25	; 0x04
    2938:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    293a:	eb 81       	ldd	r30, Y+3	; 0x03
    293c:	fc 81       	ldd	r31, Y+4	; 0x04
    293e:	86 e0       	ldi	r24, 0x06	; 6
    2940:	80 83       	st	Z, r24
	pxTopOfStack--;
    2942:	8b 81       	ldd	r24, Y+3	; 0x03
    2944:	9c 81       	ldd	r25, Y+4	; 0x04
    2946:	01 97       	sbiw	r24, 0x01	; 1
    2948:	9c 83       	std	Y+4, r25	; 0x04
    294a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    294c:	eb 81       	ldd	r30, Y+3	; 0x03
    294e:	fc 81       	ldd	r31, Y+4	; 0x04
    2950:	87 e0       	ldi	r24, 0x07	; 7
    2952:	80 83       	st	Z, r24
	pxTopOfStack--;
    2954:	8b 81       	ldd	r24, Y+3	; 0x03
    2956:	9c 81       	ldd	r25, Y+4	; 0x04
    2958:	01 97       	sbiw	r24, 0x01	; 1
    295a:	9c 83       	std	Y+4, r25	; 0x04
    295c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    295e:	eb 81       	ldd	r30, Y+3	; 0x03
    2960:	fc 81       	ldd	r31, Y+4	; 0x04
    2962:	88 e0       	ldi	r24, 0x08	; 8
    2964:	80 83       	st	Z, r24
	pxTopOfStack--;
    2966:	8b 81       	ldd	r24, Y+3	; 0x03
    2968:	9c 81       	ldd	r25, Y+4	; 0x04
    296a:	01 97       	sbiw	r24, 0x01	; 1
    296c:	9c 83       	std	Y+4, r25	; 0x04
    296e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    2970:	eb 81       	ldd	r30, Y+3	; 0x03
    2972:	fc 81       	ldd	r31, Y+4	; 0x04
    2974:	89 e0       	ldi	r24, 0x09	; 9
    2976:	80 83       	st	Z, r24
	pxTopOfStack--;
    2978:	8b 81       	ldd	r24, Y+3	; 0x03
    297a:	9c 81       	ldd	r25, Y+4	; 0x04
    297c:	01 97       	sbiw	r24, 0x01	; 1
    297e:	9c 83       	std	Y+4, r25	; 0x04
    2980:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    2982:	eb 81       	ldd	r30, Y+3	; 0x03
    2984:	fc 81       	ldd	r31, Y+4	; 0x04
    2986:	80 e1       	ldi	r24, 0x10	; 16
    2988:	80 83       	st	Z, r24
	pxTopOfStack--;
    298a:	8b 81       	ldd	r24, Y+3	; 0x03
    298c:	9c 81       	ldd	r25, Y+4	; 0x04
    298e:	01 97       	sbiw	r24, 0x01	; 1
    2990:	9c 83       	std	Y+4, r25	; 0x04
    2992:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    2994:	eb 81       	ldd	r30, Y+3	; 0x03
    2996:	fc 81       	ldd	r31, Y+4	; 0x04
    2998:	81 e1       	ldi	r24, 0x11	; 17
    299a:	80 83       	st	Z, r24
	pxTopOfStack--;
    299c:	8b 81       	ldd	r24, Y+3	; 0x03
    299e:	9c 81       	ldd	r25, Y+4	; 0x04
    29a0:	01 97       	sbiw	r24, 0x01	; 1
    29a2:	9c 83       	std	Y+4, r25	; 0x04
    29a4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    29a6:	eb 81       	ldd	r30, Y+3	; 0x03
    29a8:	fc 81       	ldd	r31, Y+4	; 0x04
    29aa:	82 e1       	ldi	r24, 0x12	; 18
    29ac:	80 83       	st	Z, r24
	pxTopOfStack--;
    29ae:	8b 81       	ldd	r24, Y+3	; 0x03
    29b0:	9c 81       	ldd	r25, Y+4	; 0x04
    29b2:	01 97       	sbiw	r24, 0x01	; 1
    29b4:	9c 83       	std	Y+4, r25	; 0x04
    29b6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    29b8:	eb 81       	ldd	r30, Y+3	; 0x03
    29ba:	fc 81       	ldd	r31, Y+4	; 0x04
    29bc:	83 e1       	ldi	r24, 0x13	; 19
    29be:	80 83       	st	Z, r24
	pxTopOfStack--;
    29c0:	8b 81       	ldd	r24, Y+3	; 0x03
    29c2:	9c 81       	ldd	r25, Y+4	; 0x04
    29c4:	01 97       	sbiw	r24, 0x01	; 1
    29c6:	9c 83       	std	Y+4, r25	; 0x04
    29c8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    29ca:	eb 81       	ldd	r30, Y+3	; 0x03
    29cc:	fc 81       	ldd	r31, Y+4	; 0x04
    29ce:	84 e1       	ldi	r24, 0x14	; 20
    29d0:	80 83       	st	Z, r24
	pxTopOfStack--;
    29d2:	8b 81       	ldd	r24, Y+3	; 0x03
    29d4:	9c 81       	ldd	r25, Y+4	; 0x04
    29d6:	01 97       	sbiw	r24, 0x01	; 1
    29d8:	9c 83       	std	Y+4, r25	; 0x04
    29da:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    29dc:	eb 81       	ldd	r30, Y+3	; 0x03
    29de:	fc 81       	ldd	r31, Y+4	; 0x04
    29e0:	85 e1       	ldi	r24, 0x15	; 21
    29e2:	80 83       	st	Z, r24
	pxTopOfStack--;
    29e4:	8b 81       	ldd	r24, Y+3	; 0x03
    29e6:	9c 81       	ldd	r25, Y+4	; 0x04
    29e8:	01 97       	sbiw	r24, 0x01	; 1
    29ea:	9c 83       	std	Y+4, r25	; 0x04
    29ec:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    29ee:	eb 81       	ldd	r30, Y+3	; 0x03
    29f0:	fc 81       	ldd	r31, Y+4	; 0x04
    29f2:	86 e1       	ldi	r24, 0x16	; 22
    29f4:	80 83       	st	Z, r24
	pxTopOfStack--;
    29f6:	8b 81       	ldd	r24, Y+3	; 0x03
    29f8:	9c 81       	ldd	r25, Y+4	; 0x04
    29fa:	01 97       	sbiw	r24, 0x01	; 1
    29fc:	9c 83       	std	Y+4, r25	; 0x04
    29fe:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    2a00:	eb 81       	ldd	r30, Y+3	; 0x03
    2a02:	fc 81       	ldd	r31, Y+4	; 0x04
    2a04:	87 e1       	ldi	r24, 0x17	; 23
    2a06:	80 83       	st	Z, r24
	pxTopOfStack--;
    2a08:	8b 81       	ldd	r24, Y+3	; 0x03
    2a0a:	9c 81       	ldd	r25, Y+4	; 0x04
    2a0c:	01 97       	sbiw	r24, 0x01	; 1
    2a0e:	9c 83       	std	Y+4, r25	; 0x04
    2a10:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    2a12:	eb 81       	ldd	r30, Y+3	; 0x03
    2a14:	fc 81       	ldd	r31, Y+4	; 0x04
    2a16:	88 e1       	ldi	r24, 0x18	; 24
    2a18:	80 83       	st	Z, r24
	pxTopOfStack--;
    2a1a:	8b 81       	ldd	r24, Y+3	; 0x03
    2a1c:	9c 81       	ldd	r25, Y+4	; 0x04
    2a1e:	01 97       	sbiw	r24, 0x01	; 1
    2a20:	9c 83       	std	Y+4, r25	; 0x04
    2a22:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    2a24:	eb 81       	ldd	r30, Y+3	; 0x03
    2a26:	fc 81       	ldd	r31, Y+4	; 0x04
    2a28:	89 e1       	ldi	r24, 0x19	; 25
    2a2a:	80 83       	st	Z, r24
	pxTopOfStack--;
    2a2c:	8b 81       	ldd	r24, Y+3	; 0x03
    2a2e:	9c 81       	ldd	r25, Y+4	; 0x04
    2a30:	01 97       	sbiw	r24, 0x01	; 1
    2a32:	9c 83       	std	Y+4, r25	; 0x04
    2a34:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    2a36:	eb 81       	ldd	r30, Y+3	; 0x03
    2a38:	fc 81       	ldd	r31, Y+4	; 0x04
    2a3a:	80 e2       	ldi	r24, 0x20	; 32
    2a3c:	80 83       	st	Z, r24
	pxTopOfStack--;
    2a3e:	8b 81       	ldd	r24, Y+3	; 0x03
    2a40:	9c 81       	ldd	r25, Y+4	; 0x04
    2a42:	01 97       	sbiw	r24, 0x01	; 1
    2a44:	9c 83       	std	Y+4, r25	; 0x04
    2a46:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    2a48:	eb 81       	ldd	r30, Y+3	; 0x03
    2a4a:	fc 81       	ldd	r31, Y+4	; 0x04
    2a4c:	81 e2       	ldi	r24, 0x21	; 33
    2a4e:	80 83       	st	Z, r24
	pxTopOfStack--;
    2a50:	8b 81       	ldd	r24, Y+3	; 0x03
    2a52:	9c 81       	ldd	r25, Y+4	; 0x04
    2a54:	01 97       	sbiw	r24, 0x01	; 1
    2a56:	9c 83       	std	Y+4, r25	; 0x04
    2a58:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    2a5a:	eb 81       	ldd	r30, Y+3	; 0x03
    2a5c:	fc 81       	ldd	r31, Y+4	; 0x04
    2a5e:	82 e2       	ldi	r24, 0x22	; 34
    2a60:	80 83       	st	Z, r24
	pxTopOfStack--;
    2a62:	8b 81       	ldd	r24, Y+3	; 0x03
    2a64:	9c 81       	ldd	r25, Y+4	; 0x04
    2a66:	01 97       	sbiw	r24, 0x01	; 1
    2a68:	9c 83       	std	Y+4, r25	; 0x04
    2a6a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    2a6c:	eb 81       	ldd	r30, Y+3	; 0x03
    2a6e:	fc 81       	ldd	r31, Y+4	; 0x04
    2a70:	83 e2       	ldi	r24, 0x23	; 35
    2a72:	80 83       	st	Z, r24
	pxTopOfStack--;
    2a74:	8b 81       	ldd	r24, Y+3	; 0x03
    2a76:	9c 81       	ldd	r25, Y+4	; 0x04
    2a78:	01 97       	sbiw	r24, 0x01	; 1
    2a7a:	9c 83       	std	Y+4, r25	; 0x04
    2a7c:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
    2a7e:	8f 81       	ldd	r24, Y+7	; 0x07
    2a80:	98 85       	ldd	r25, Y+8	; 0x08
    2a82:	9a 83       	std	Y+2, r25	; 0x02
    2a84:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2a86:	89 81       	ldd	r24, Y+1	; 0x01
    2a88:	eb 81       	ldd	r30, Y+3	; 0x03
    2a8a:	fc 81       	ldd	r31, Y+4	; 0x04
    2a8c:	80 83       	st	Z, r24
	pxTopOfStack--;
    2a8e:	8b 81       	ldd	r24, Y+3	; 0x03
    2a90:	9c 81       	ldd	r25, Y+4	; 0x04
    2a92:	01 97       	sbiw	r24, 0x01	; 1
    2a94:	9c 83       	std	Y+4, r25	; 0x04
    2a96:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    2a98:	89 81       	ldd	r24, Y+1	; 0x01
    2a9a:	9a 81       	ldd	r25, Y+2	; 0x02
    2a9c:	89 2f       	mov	r24, r25
    2a9e:	99 27       	eor	r25, r25
    2aa0:	9a 83       	std	Y+2, r25	; 0x02
    2aa2:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2aa4:	89 81       	ldd	r24, Y+1	; 0x01
    2aa6:	eb 81       	ldd	r30, Y+3	; 0x03
    2aa8:	fc 81       	ldd	r31, Y+4	; 0x04
    2aaa:	80 83       	st	Z, r24
	pxTopOfStack--;
    2aac:	8b 81       	ldd	r24, Y+3	; 0x03
    2aae:	9c 81       	ldd	r25, Y+4	; 0x04
    2ab0:	01 97       	sbiw	r24, 0x01	; 1
    2ab2:	9c 83       	std	Y+4, r25	; 0x04
    2ab4:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    2ab6:	eb 81       	ldd	r30, Y+3	; 0x03
    2ab8:	fc 81       	ldd	r31, Y+4	; 0x04
    2aba:	86 e2       	ldi	r24, 0x26	; 38
    2abc:	80 83       	st	Z, r24
	pxTopOfStack--;
    2abe:	8b 81       	ldd	r24, Y+3	; 0x03
    2ac0:	9c 81       	ldd	r25, Y+4	; 0x04
    2ac2:	01 97       	sbiw	r24, 0x01	; 1
    2ac4:	9c 83       	std	Y+4, r25	; 0x04
    2ac6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    2ac8:	eb 81       	ldd	r30, Y+3	; 0x03
    2aca:	fc 81       	ldd	r31, Y+4	; 0x04
    2acc:	87 e2       	ldi	r24, 0x27	; 39
    2ace:	80 83       	st	Z, r24
	pxTopOfStack--;
    2ad0:	8b 81       	ldd	r24, Y+3	; 0x03
    2ad2:	9c 81       	ldd	r25, Y+4	; 0x04
    2ad4:	01 97       	sbiw	r24, 0x01	; 1
    2ad6:	9c 83       	std	Y+4, r25	; 0x04
    2ad8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    2ada:	eb 81       	ldd	r30, Y+3	; 0x03
    2adc:	fc 81       	ldd	r31, Y+4	; 0x04
    2ade:	88 e2       	ldi	r24, 0x28	; 40
    2ae0:	80 83       	st	Z, r24
	pxTopOfStack--;
    2ae2:	8b 81       	ldd	r24, Y+3	; 0x03
    2ae4:	9c 81       	ldd	r25, Y+4	; 0x04
    2ae6:	01 97       	sbiw	r24, 0x01	; 1
    2ae8:	9c 83       	std	Y+4, r25	; 0x04
    2aea:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    2aec:	eb 81       	ldd	r30, Y+3	; 0x03
    2aee:	fc 81       	ldd	r31, Y+4	; 0x04
    2af0:	89 e2       	ldi	r24, 0x29	; 41
    2af2:	80 83       	st	Z, r24
	pxTopOfStack--;
    2af4:	8b 81       	ldd	r24, Y+3	; 0x03
    2af6:	9c 81       	ldd	r25, Y+4	; 0x04
    2af8:	01 97       	sbiw	r24, 0x01	; 1
    2afa:	9c 83       	std	Y+4, r25	; 0x04
    2afc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    2afe:	eb 81       	ldd	r30, Y+3	; 0x03
    2b00:	fc 81       	ldd	r31, Y+4	; 0x04
    2b02:	80 e3       	ldi	r24, 0x30	; 48
    2b04:	80 83       	st	Z, r24
	pxTopOfStack--;
    2b06:	8b 81       	ldd	r24, Y+3	; 0x03
    2b08:	9c 81       	ldd	r25, Y+4	; 0x04
    2b0a:	01 97       	sbiw	r24, 0x01	; 1
    2b0c:	9c 83       	std	Y+4, r25	; 0x04
    2b0e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    2b10:	eb 81       	ldd	r30, Y+3	; 0x03
    2b12:	fc 81       	ldd	r31, Y+4	; 0x04
    2b14:	81 e3       	ldi	r24, 0x31	; 49
    2b16:	80 83       	st	Z, r24
	pxTopOfStack--;
    2b18:	8b 81       	ldd	r24, Y+3	; 0x03
    2b1a:	9c 81       	ldd	r25, Y+4	; 0x04
    2b1c:	01 97       	sbiw	r24, 0x01	; 1
    2b1e:	9c 83       	std	Y+4, r25	; 0x04
    2b20:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    2b22:	8b 81       	ldd	r24, Y+3	; 0x03
    2b24:	9c 81       	ldd	r25, Y+4	; 0x04
}
    2b26:	28 96       	adiw	r28, 0x08	; 8
    2b28:	0f b6       	in	r0, 0x3f	; 63
    2b2a:	f8 94       	cli
    2b2c:	de bf       	out	0x3e, r29	; 62
    2b2e:	0f be       	out	0x3f, r0	; 63
    2b30:	cd bf       	out	0x3d, r28	; 61
    2b32:	cf 91       	pop	r28
    2b34:	df 91       	pop	r29
    2b36:	08 95       	ret

00002b38 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

BaseType_t xPortStartScheduler( void )
{
    2b38:	df 93       	push	r29
    2b3a:	cf 93       	push	r28
    2b3c:	cd b7       	in	r28, 0x3d	; 61
    2b3e:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    2b40:	0e 94 8e 16 	call	0x2d1c	; 0x2d1c <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    2b44:	a0 91 a9 06 	lds	r26, 0x06A9
    2b48:	b0 91 aa 06 	lds	r27, 0x06AA
    2b4c:	cd 91       	ld	r28, X+
    2b4e:	cd bf       	out	0x3d, r28	; 61
    2b50:	dd 91       	ld	r29, X+
    2b52:	de bf       	out	0x3e, r29	; 62
    2b54:	ff 91       	pop	r31
    2b56:	ef 91       	pop	r30
    2b58:	df 91       	pop	r29
    2b5a:	cf 91       	pop	r28
    2b5c:	bf 91       	pop	r27
    2b5e:	af 91       	pop	r26
    2b60:	9f 91       	pop	r25
    2b62:	8f 91       	pop	r24
    2b64:	7f 91       	pop	r23
    2b66:	6f 91       	pop	r22
    2b68:	5f 91       	pop	r21
    2b6a:	4f 91       	pop	r20
    2b6c:	3f 91       	pop	r19
    2b6e:	2f 91       	pop	r18
    2b70:	1f 91       	pop	r17
    2b72:	0f 91       	pop	r16
    2b74:	ff 90       	pop	r15
    2b76:	ef 90       	pop	r14
    2b78:	df 90       	pop	r13
    2b7a:	cf 90       	pop	r12
    2b7c:	bf 90       	pop	r11
    2b7e:	af 90       	pop	r10
    2b80:	9f 90       	pop	r9
    2b82:	8f 90       	pop	r8
    2b84:	7f 90       	pop	r7
    2b86:	6f 90       	pop	r6
    2b88:	5f 90       	pop	r5
    2b8a:	4f 90       	pop	r4
    2b8c:	3f 90       	pop	r3
    2b8e:	2f 90       	pop	r2
    2b90:	1f 90       	pop	r1
    2b92:	0f 90       	pop	r0
    2b94:	0f be       	out	0x3f, r0	; 63
    2b96:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    2b98:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    2b9a:	81 e0       	ldi	r24, 0x01	; 1
}
    2b9c:	cf 91       	pop	r28
    2b9e:	df 91       	pop	r29
    2ba0:	08 95       	ret

00002ba2 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    2ba2:	df 93       	push	r29
    2ba4:	cf 93       	push	r28
    2ba6:	cd b7       	in	r28, 0x3d	; 61
    2ba8:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    2baa:	cf 91       	pop	r28
    2bac:	df 91       	pop	r29
    2bae:	08 95       	ret

00002bb0 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    2bb0:	0f 92       	push	r0
    2bb2:	0f b6       	in	r0, 0x3f	; 63
    2bb4:	f8 94       	cli
    2bb6:	0f 92       	push	r0
    2bb8:	1f 92       	push	r1
    2bba:	11 24       	eor	r1, r1
    2bbc:	2f 92       	push	r2
    2bbe:	3f 92       	push	r3
    2bc0:	4f 92       	push	r4
    2bc2:	5f 92       	push	r5
    2bc4:	6f 92       	push	r6
    2bc6:	7f 92       	push	r7
    2bc8:	8f 92       	push	r8
    2bca:	9f 92       	push	r9
    2bcc:	af 92       	push	r10
    2bce:	bf 92       	push	r11
    2bd0:	cf 92       	push	r12
    2bd2:	df 92       	push	r13
    2bd4:	ef 92       	push	r14
    2bd6:	ff 92       	push	r15
    2bd8:	0f 93       	push	r16
    2bda:	1f 93       	push	r17
    2bdc:	2f 93       	push	r18
    2bde:	3f 93       	push	r19
    2be0:	4f 93       	push	r20
    2be2:	5f 93       	push	r21
    2be4:	6f 93       	push	r22
    2be6:	7f 93       	push	r23
    2be8:	8f 93       	push	r24
    2bea:	9f 93       	push	r25
    2bec:	af 93       	push	r26
    2bee:	bf 93       	push	r27
    2bf0:	cf 93       	push	r28
    2bf2:	df 93       	push	r29
    2bf4:	ef 93       	push	r30
    2bf6:	ff 93       	push	r31
    2bf8:	a0 91 a9 06 	lds	r26, 0x06A9
    2bfc:	b0 91 aa 06 	lds	r27, 0x06AA
    2c00:	0d b6       	in	r0, 0x3d	; 61
    2c02:	0d 92       	st	X+, r0
    2c04:	0e b6       	in	r0, 0x3e	; 62
    2c06:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    2c08:	0e 94 8f 2b 	call	0x571e	; 0x571e <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    2c0c:	a0 91 a9 06 	lds	r26, 0x06A9
    2c10:	b0 91 aa 06 	lds	r27, 0x06AA
    2c14:	cd 91       	ld	r28, X+
    2c16:	cd bf       	out	0x3d, r28	; 61
    2c18:	dd 91       	ld	r29, X+
    2c1a:	de bf       	out	0x3e, r29	; 62
    2c1c:	ff 91       	pop	r31
    2c1e:	ef 91       	pop	r30
    2c20:	df 91       	pop	r29
    2c22:	cf 91       	pop	r28
    2c24:	bf 91       	pop	r27
    2c26:	af 91       	pop	r26
    2c28:	9f 91       	pop	r25
    2c2a:	8f 91       	pop	r24
    2c2c:	7f 91       	pop	r23
    2c2e:	6f 91       	pop	r22
    2c30:	5f 91       	pop	r21
    2c32:	4f 91       	pop	r20
    2c34:	3f 91       	pop	r19
    2c36:	2f 91       	pop	r18
    2c38:	1f 91       	pop	r17
    2c3a:	0f 91       	pop	r16
    2c3c:	ff 90       	pop	r15
    2c3e:	ef 90       	pop	r14
    2c40:	df 90       	pop	r13
    2c42:	cf 90       	pop	r12
    2c44:	bf 90       	pop	r11
    2c46:	af 90       	pop	r10
    2c48:	9f 90       	pop	r9
    2c4a:	8f 90       	pop	r8
    2c4c:	7f 90       	pop	r7
    2c4e:	6f 90       	pop	r6
    2c50:	5f 90       	pop	r5
    2c52:	4f 90       	pop	r4
    2c54:	3f 90       	pop	r3
    2c56:	2f 90       	pop	r2
    2c58:	1f 90       	pop	r1
    2c5a:	0f 90       	pop	r0
    2c5c:	0f be       	out	0x3f, r0	; 63
    2c5e:	0f 90       	pop	r0

	asm volatile ( "ret" );
    2c60:	08 95       	ret

00002c62 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    2c62:	0f 92       	push	r0
    2c64:	0f b6       	in	r0, 0x3f	; 63
    2c66:	f8 94       	cli
    2c68:	0f 92       	push	r0
    2c6a:	1f 92       	push	r1
    2c6c:	11 24       	eor	r1, r1
    2c6e:	2f 92       	push	r2
    2c70:	3f 92       	push	r3
    2c72:	4f 92       	push	r4
    2c74:	5f 92       	push	r5
    2c76:	6f 92       	push	r6
    2c78:	7f 92       	push	r7
    2c7a:	8f 92       	push	r8
    2c7c:	9f 92       	push	r9
    2c7e:	af 92       	push	r10
    2c80:	bf 92       	push	r11
    2c82:	cf 92       	push	r12
    2c84:	df 92       	push	r13
    2c86:	ef 92       	push	r14
    2c88:	ff 92       	push	r15
    2c8a:	0f 93       	push	r16
    2c8c:	1f 93       	push	r17
    2c8e:	2f 93       	push	r18
    2c90:	3f 93       	push	r19
    2c92:	4f 93       	push	r20
    2c94:	5f 93       	push	r21
    2c96:	6f 93       	push	r22
    2c98:	7f 93       	push	r23
    2c9a:	8f 93       	push	r24
    2c9c:	9f 93       	push	r25
    2c9e:	af 93       	push	r26
    2ca0:	bf 93       	push	r27
    2ca2:	cf 93       	push	r28
    2ca4:	df 93       	push	r29
    2ca6:	ef 93       	push	r30
    2ca8:	ff 93       	push	r31
    2caa:	a0 91 a9 06 	lds	r26, 0x06A9
    2cae:	b0 91 aa 06 	lds	r27, 0x06AA
    2cb2:	0d b6       	in	r0, 0x3d	; 61
    2cb4:	0d 92       	st	X+, r0
    2cb6:	0e b6       	in	r0, 0x3e	; 62
    2cb8:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    2cba:	0e 94 aa 2a 	call	0x5554	; 0x5554 <xTaskIncrementTick>
    2cbe:	88 23       	and	r24, r24
    2cc0:	11 f0       	breq	.+4      	; 0x2cc6 <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
    2cc2:	0e 94 8f 2b 	call	0x571e	; 0x571e <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    2cc6:	a0 91 a9 06 	lds	r26, 0x06A9
    2cca:	b0 91 aa 06 	lds	r27, 0x06AA
    2cce:	cd 91       	ld	r28, X+
    2cd0:	cd bf       	out	0x3d, r28	; 61
    2cd2:	dd 91       	ld	r29, X+
    2cd4:	de bf       	out	0x3e, r29	; 62
    2cd6:	ff 91       	pop	r31
    2cd8:	ef 91       	pop	r30
    2cda:	df 91       	pop	r29
    2cdc:	cf 91       	pop	r28
    2cde:	bf 91       	pop	r27
    2ce0:	af 91       	pop	r26
    2ce2:	9f 91       	pop	r25
    2ce4:	8f 91       	pop	r24
    2ce6:	7f 91       	pop	r23
    2ce8:	6f 91       	pop	r22
    2cea:	5f 91       	pop	r21
    2cec:	4f 91       	pop	r20
    2cee:	3f 91       	pop	r19
    2cf0:	2f 91       	pop	r18
    2cf2:	1f 91       	pop	r17
    2cf4:	0f 91       	pop	r16
    2cf6:	ff 90       	pop	r15
    2cf8:	ef 90       	pop	r14
    2cfa:	df 90       	pop	r13
    2cfc:	cf 90       	pop	r12
    2cfe:	bf 90       	pop	r11
    2d00:	af 90       	pop	r10
    2d02:	9f 90       	pop	r9
    2d04:	8f 90       	pop	r8
    2d06:	7f 90       	pop	r7
    2d08:	6f 90       	pop	r6
    2d0a:	5f 90       	pop	r5
    2d0c:	4f 90       	pop	r4
    2d0e:	3f 90       	pop	r3
    2d10:	2f 90       	pop	r2
    2d12:	1f 90       	pop	r1
    2d14:	0f 90       	pop	r0
    2d16:	0f be       	out	0x3f, r0	; 63
    2d18:	0f 90       	pop	r0

	asm volatile ( "ret" );
    2d1a:	08 95       	ret

00002d1c <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    2d1c:	df 93       	push	r29
    2d1e:	cf 93       	push	r28
    2d20:	00 d0       	rcall	.+0      	; 0x2d22 <prvSetupTimerInterrupt+0x6>
    2d22:	00 d0       	rcall	.+0      	; 0x2d24 <prvSetupTimerInterrupt+0x8>
    2d24:	00 d0       	rcall	.+0      	; 0x2d26 <prvSetupTimerInterrupt+0xa>
    2d26:	cd b7       	in	r28, 0x3d	; 61
    2d28:	de b7       	in	r29, 0x3e	; 62
uint8_t ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    2d2a:	80 e4       	ldi	r24, 0x40	; 64
    2d2c:	9f e1       	ldi	r25, 0x1F	; 31
    2d2e:	a0 e0       	ldi	r26, 0x00	; 0
    2d30:	b0 e0       	ldi	r27, 0x00	; 0
    2d32:	8b 83       	std	Y+3, r24	; 0x03
    2d34:	9c 83       	std	Y+4, r25	; 0x04
    2d36:	ad 83       	std	Y+5, r26	; 0x05
    2d38:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    2d3a:	8b 81       	ldd	r24, Y+3	; 0x03
    2d3c:	9c 81       	ldd	r25, Y+4	; 0x04
    2d3e:	ad 81       	ldd	r26, Y+5	; 0x05
    2d40:	be 81       	ldd	r27, Y+6	; 0x06
    2d42:	68 94       	set
    2d44:	15 f8       	bld	r1, 5
    2d46:	b6 95       	lsr	r27
    2d48:	a7 95       	ror	r26
    2d4a:	97 95       	ror	r25
    2d4c:	87 95       	ror	r24
    2d4e:	16 94       	lsr	r1
    2d50:	d1 f7       	brne	.-12     	; 0x2d46 <prvSetupTimerInterrupt+0x2a>
    2d52:	8b 83       	std	Y+3, r24	; 0x03
    2d54:	9c 83       	std	Y+4, r25	; 0x04
    2d56:	ad 83       	std	Y+5, r26	; 0x05
    2d58:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( uint32_t ) 1;
    2d5a:	8b 81       	ldd	r24, Y+3	; 0x03
    2d5c:	9c 81       	ldd	r25, Y+4	; 0x04
    2d5e:	ad 81       	ldd	r26, Y+5	; 0x05
    2d60:	be 81       	ldd	r27, Y+6	; 0x06
    2d62:	01 97       	sbiw	r24, 0x01	; 1
    2d64:	a1 09       	sbc	r26, r1
    2d66:	b1 09       	sbc	r27, r1
    2d68:	8b 83       	std	Y+3, r24	; 0x03
    2d6a:	9c 83       	std	Y+4, r25	; 0x04
    2d6c:	ad 83       	std	Y+5, r26	; 0x05
    2d6e:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    2d70:	8b 81       	ldd	r24, Y+3	; 0x03
    2d72:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
    2d74:	8b 81       	ldd	r24, Y+3	; 0x03
    2d76:	9c 81       	ldd	r25, Y+4	; 0x04
    2d78:	ad 81       	ldd	r26, Y+5	; 0x05
    2d7a:	be 81       	ldd	r27, Y+6	; 0x06
    2d7c:	89 2f       	mov	r24, r25
    2d7e:	9a 2f       	mov	r25, r26
    2d80:	ab 2f       	mov	r26, r27
    2d82:	bb 27       	eor	r27, r27
    2d84:	8b 83       	std	Y+3, r24	; 0x03
    2d86:	9c 83       	std	Y+4, r25	; 0x04
    2d88:	ad 83       	std	Y+5, r26	; 0x05
    2d8a:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    2d8c:	8b 81       	ldd	r24, Y+3	; 0x03
    2d8e:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
    2d90:	eb e4       	ldi	r30, 0x4B	; 75
    2d92:	f0 e0       	ldi	r31, 0x00	; 0
    2d94:	8a 81       	ldd	r24, Y+2	; 0x02
    2d96:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
    2d98:	ea e4       	ldi	r30, 0x4A	; 74
    2d9a:	f0 e0       	ldi	r31, 0x00	; 0
    2d9c:	89 81       	ldd	r24, Y+1	; 0x01
    2d9e:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    2da0:	8b e0       	ldi	r24, 0x0B	; 11
    2da2:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
    2da4:	ee e4       	ldi	r30, 0x4E	; 78
    2da6:	f0 e0       	ldi	r31, 0x00	; 0
    2da8:	89 81       	ldd	r24, Y+1	; 0x01
    2daa:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    2dac:	e9 e5       	ldi	r30, 0x59	; 89
    2dae:	f0 e0       	ldi	r31, 0x00	; 0
    2db0:	80 81       	ld	r24, Z
    2db2:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    2db4:	89 81       	ldd	r24, Y+1	; 0x01
    2db6:	80 61       	ori	r24, 0x10	; 16
    2db8:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    2dba:	e9 e5       	ldi	r30, 0x59	; 89
    2dbc:	f0 e0       	ldi	r31, 0x00	; 0
    2dbe:	89 81       	ldd	r24, Y+1	; 0x01
    2dc0:	80 83       	st	Z, r24
}
    2dc2:	26 96       	adiw	r28, 0x06	; 6
    2dc4:	0f b6       	in	r0, 0x3f	; 63
    2dc6:	f8 94       	cli
    2dc8:	de bf       	out	0x3e, r29	; 62
    2dca:	0f be       	out	0x3f, r0	; 63
    2dcc:	cd bf       	out	0x3d, r28	; 61
    2dce:	cf 91       	pop	r28
    2dd0:	df 91       	pop	r29
    2dd2:	08 95       	ret

00002dd4 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
	void SIG_OUTPUT_COMPARE1A( void )
	{
		vPortYieldFromTick();
    2dd4:	0e 94 31 16 	call	0x2c62	; 0x2c62 <vPortYieldFromTick>
		asm volatile ( "reti" );
    2dd8:	18 95       	reti

00002dda <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    2dda:	df 93       	push	r29
    2ddc:	cf 93       	push	r28
    2dde:	00 d0       	rcall	.+0      	; 0x2de0 <xQueueGenericReset+0x6>
    2de0:	00 d0       	rcall	.+0      	; 0x2de2 <xQueueGenericReset+0x8>
    2de2:	0f 92       	push	r0
    2de4:	cd b7       	in	r28, 0x3d	; 61
    2de6:	de b7       	in	r29, 0x3e	; 62
    2de8:	9c 83       	std	Y+4, r25	; 0x04
    2dea:	8b 83       	std	Y+3, r24	; 0x03
    2dec:	6d 83       	std	Y+5, r22	; 0x05
Queue_t * const pxQueue = xQueue;
    2dee:	8b 81       	ldd	r24, Y+3	; 0x03
    2df0:	9c 81       	ldd	r25, Y+4	; 0x04
    2df2:	9a 83       	std	Y+2, r25	; 0x02
    2df4:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    2df6:	0f b6       	in	r0, 0x3f	; 63
    2df8:	f8 94       	cli
    2dfa:	0f 92       	push	r0
	{
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    2dfc:	e9 81       	ldd	r30, Y+1	; 0x01
    2dfe:	fa 81       	ldd	r31, Y+2	; 0x02
    2e00:	40 81       	ld	r20, Z
    2e02:	51 81       	ldd	r21, Z+1	; 0x01
    2e04:	e9 81       	ldd	r30, Y+1	; 0x01
    2e06:	fa 81       	ldd	r31, Y+2	; 0x02
    2e08:	83 8d       	ldd	r24, Z+27	; 0x1b
    2e0a:	28 2f       	mov	r18, r24
    2e0c:	30 e0       	ldi	r19, 0x00	; 0
    2e0e:	e9 81       	ldd	r30, Y+1	; 0x01
    2e10:	fa 81       	ldd	r31, Y+2	; 0x02
    2e12:	84 8d       	ldd	r24, Z+28	; 0x1c
    2e14:	88 2f       	mov	r24, r24
    2e16:	90 e0       	ldi	r25, 0x00	; 0
    2e18:	bc 01       	movw	r22, r24
    2e1a:	26 9f       	mul	r18, r22
    2e1c:	c0 01       	movw	r24, r0
    2e1e:	27 9f       	mul	r18, r23
    2e20:	90 0d       	add	r25, r0
    2e22:	36 9f       	mul	r19, r22
    2e24:	90 0d       	add	r25, r0
    2e26:	11 24       	eor	r1, r1
    2e28:	84 0f       	add	r24, r20
    2e2a:	95 1f       	adc	r25, r21
    2e2c:	e9 81       	ldd	r30, Y+1	; 0x01
    2e2e:	fa 81       	ldd	r31, Y+2	; 0x02
    2e30:	95 83       	std	Z+5, r25	; 0x05
    2e32:	84 83       	std	Z+4, r24	; 0x04
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    2e34:	e9 81       	ldd	r30, Y+1	; 0x01
    2e36:	fa 81       	ldd	r31, Y+2	; 0x02
    2e38:	12 8e       	std	Z+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    2e3a:	e9 81       	ldd	r30, Y+1	; 0x01
    2e3c:	fa 81       	ldd	r31, Y+2	; 0x02
    2e3e:	80 81       	ld	r24, Z
    2e40:	91 81       	ldd	r25, Z+1	; 0x01
    2e42:	e9 81       	ldd	r30, Y+1	; 0x01
    2e44:	fa 81       	ldd	r31, Y+2	; 0x02
    2e46:	93 83       	std	Z+3, r25	; 0x03
    2e48:	82 83       	std	Z+2, r24	; 0x02
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    2e4a:	e9 81       	ldd	r30, Y+1	; 0x01
    2e4c:	fa 81       	ldd	r31, Y+2	; 0x02
    2e4e:	40 81       	ld	r20, Z
    2e50:	51 81       	ldd	r21, Z+1	; 0x01
    2e52:	e9 81       	ldd	r30, Y+1	; 0x01
    2e54:	fa 81       	ldd	r31, Y+2	; 0x02
    2e56:	83 8d       	ldd	r24, Z+27	; 0x1b
    2e58:	88 2f       	mov	r24, r24
    2e5a:	90 e0       	ldi	r25, 0x00	; 0
    2e5c:	9c 01       	movw	r18, r24
    2e5e:	21 50       	subi	r18, 0x01	; 1
    2e60:	30 40       	sbci	r19, 0x00	; 0
    2e62:	e9 81       	ldd	r30, Y+1	; 0x01
    2e64:	fa 81       	ldd	r31, Y+2	; 0x02
    2e66:	84 8d       	ldd	r24, Z+28	; 0x1c
    2e68:	88 2f       	mov	r24, r24
    2e6a:	90 e0       	ldi	r25, 0x00	; 0
    2e6c:	bc 01       	movw	r22, r24
    2e6e:	26 9f       	mul	r18, r22
    2e70:	c0 01       	movw	r24, r0
    2e72:	27 9f       	mul	r18, r23
    2e74:	90 0d       	add	r25, r0
    2e76:	36 9f       	mul	r19, r22
    2e78:	90 0d       	add	r25, r0
    2e7a:	11 24       	eor	r1, r1
    2e7c:	84 0f       	add	r24, r20
    2e7e:	95 1f       	adc	r25, r21
    2e80:	e9 81       	ldd	r30, Y+1	; 0x01
    2e82:	fa 81       	ldd	r31, Y+2	; 0x02
    2e84:	97 83       	std	Z+7, r25	; 0x07
    2e86:	86 83       	std	Z+6, r24	; 0x06
		pxQueue->cRxLock = queueUNLOCKED;
    2e88:	e9 81       	ldd	r30, Y+1	; 0x01
    2e8a:	fa 81       	ldd	r31, Y+2	; 0x02
    2e8c:	8f ef       	ldi	r24, 0xFF	; 255
    2e8e:	85 8f       	std	Z+29, r24	; 0x1d
		pxQueue->cTxLock = queueUNLOCKED;
    2e90:	e9 81       	ldd	r30, Y+1	; 0x01
    2e92:	fa 81       	ldd	r31, Y+2	; 0x02
    2e94:	8f ef       	ldi	r24, 0xFF	; 255
    2e96:	86 8f       	std	Z+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    2e98:	8d 81       	ldd	r24, Y+5	; 0x05
    2e9a:	88 23       	and	r24, r24
    2e9c:	79 f4       	brne	.+30     	; 0x2ebc <xQueueGenericReset+0xe2>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2e9e:	e9 81       	ldd	r30, Y+1	; 0x01
    2ea0:	fa 81       	ldd	r31, Y+2	; 0x02
    2ea2:	80 85       	ldd	r24, Z+8	; 0x08
    2ea4:	88 23       	and	r24, r24
    2ea6:	a1 f0       	breq	.+40     	; 0x2ed0 <xQueueGenericReset+0xf6>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2ea8:	89 81       	ldd	r24, Y+1	; 0x01
    2eaa:	9a 81       	ldd	r25, Y+2	; 0x02
    2eac:	08 96       	adiw	r24, 0x08	; 8
    2eae:	0e 94 4e 2c 	call	0x589c	; 0x589c <xTaskRemoveFromEventList>
    2eb2:	88 23       	and	r24, r24
    2eb4:	69 f0       	breq	.+26     	; 0x2ed0 <xQueueGenericReset+0xf6>
				{
					queueYIELD_IF_USING_PREEMPTION();
    2eb6:	0e 94 d8 15 	call	0x2bb0	; 0x2bb0 <vPortYield>
    2eba:	0a c0       	rjmp	.+20     	; 0x2ed0 <xQueueGenericReset+0xf6>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    2ebc:	89 81       	ldd	r24, Y+1	; 0x01
    2ebe:	9a 81       	ldd	r25, Y+2	; 0x02
    2ec0:	08 96       	adiw	r24, 0x08	; 8
    2ec2:	0e 94 29 11 	call	0x2252	; 0x2252 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    2ec6:	89 81       	ldd	r24, Y+1	; 0x01
    2ec8:	9a 81       	ldd	r25, Y+2	; 0x02
    2eca:	41 96       	adiw	r24, 0x11	; 17
    2ecc:	0e 94 29 11 	call	0x2252	; 0x2252 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    2ed0:	0f 90       	pop	r0
    2ed2:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
    2ed4:	81 e0       	ldi	r24, 0x01	; 1
}
    2ed6:	0f 90       	pop	r0
    2ed8:	0f 90       	pop	r0
    2eda:	0f 90       	pop	r0
    2edc:	0f 90       	pop	r0
    2ede:	0f 90       	pop	r0
    2ee0:	cf 91       	pop	r28
    2ee2:	df 91       	pop	r29
    2ee4:	08 95       	ret

00002ee6 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
    2ee6:	0f 93       	push	r16
    2ee8:	1f 93       	push	r17
    2eea:	df 93       	push	r29
    2eec:	cf 93       	push	r28
    2eee:	cd b7       	in	r28, 0x3d	; 61
    2ef0:	de b7       	in	r29, 0x3e	; 62
    2ef2:	29 97       	sbiw	r28, 0x09	; 9
    2ef4:	0f b6       	in	r0, 0x3f	; 63
    2ef6:	f8 94       	cli
    2ef8:	de bf       	out	0x3e, r29	; 62
    2efa:	0f be       	out	0x3f, r0	; 63
    2efc:	cd bf       	out	0x3d, r28	; 61
    2efe:	8f 83       	std	Y+7, r24	; 0x07
    2f00:	68 87       	std	Y+8, r22	; 0x08
    2f02:	49 87       	std	Y+9, r20	; 0x09
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
    2f04:	88 85       	ldd	r24, Y+8	; 0x08
    2f06:	88 23       	and	r24, r24
    2f08:	19 f4       	brne	.+6      	; 0x2f10 <xQueueGenericCreate+0x2a>
		{
			/* There is not going to be a queue storage area. */
			xQueueSizeInBytes = ( size_t ) 0;
    2f0a:	1c 82       	std	Y+4, r1	; 0x04
    2f0c:	1b 82       	std	Y+3, r1	; 0x03
    2f0e:	10 c0       	rjmp	.+32     	; 0x2f30 <xQueueGenericCreate+0x4a>
		}
		else
		{
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    2f10:	8f 81       	ldd	r24, Y+7	; 0x07
    2f12:	28 2f       	mov	r18, r24
    2f14:	30 e0       	ldi	r19, 0x00	; 0
    2f16:	88 85       	ldd	r24, Y+8	; 0x08
    2f18:	88 2f       	mov	r24, r24
    2f1a:	90 e0       	ldi	r25, 0x00	; 0
    2f1c:	ac 01       	movw	r20, r24
    2f1e:	24 9f       	mul	r18, r20
    2f20:	c0 01       	movw	r24, r0
    2f22:	25 9f       	mul	r18, r21
    2f24:	90 0d       	add	r25, r0
    2f26:	34 9f       	mul	r19, r20
    2f28:	90 0d       	add	r25, r0
    2f2a:	11 24       	eor	r1, r1
    2f2c:	9c 83       	std	Y+4, r25	; 0x04
    2f2e:	8b 83       	std	Y+3, r24	; 0x03
		alignment requirements of the Queue_t structure - which in this case
		is an int8_t *.  Therefore, whenever the stack alignment requirements
		are greater than or equal to the pointer to char requirements the cast
		is safe.  In other cases alignment requirements are not strict (one or
		two bytes). */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
    2f30:	8b 81       	ldd	r24, Y+3	; 0x03
    2f32:	9c 81       	ldd	r25, Y+4	; 0x04
    2f34:	4f 96       	adiw	r24, 0x1f	; 31
    2f36:	0e 94 33 0d 	call	0x1a66	; 0x1a66 <pvPortMalloc>
    2f3a:	9e 83       	std	Y+6, r25	; 0x06
    2f3c:	8d 83       	std	Y+5, r24	; 0x05

		if( pxNewQueue != NULL )
    2f3e:	8d 81       	ldd	r24, Y+5	; 0x05
    2f40:	9e 81       	ldd	r25, Y+6	; 0x06
    2f42:	00 97       	sbiw	r24, 0x00	; 0
    2f44:	a1 f0       	breq	.+40     	; 0x2f6e <xQueueGenericCreate+0x88>
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pucQueueStorage = ( uint8_t * ) pxNewQueue;
    2f46:	8d 81       	ldd	r24, Y+5	; 0x05
    2f48:	9e 81       	ldd	r25, Y+6	; 0x06
    2f4a:	9a 83       	std	Y+2, r25	; 0x02
    2f4c:	89 83       	std	Y+1, r24	; 0x01
			pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    2f4e:	89 81       	ldd	r24, Y+1	; 0x01
    2f50:	9a 81       	ldd	r25, Y+2	; 0x02
    2f52:	4f 96       	adiw	r24, 0x1f	; 31
    2f54:	9a 83       	std	Y+2, r25	; 0x02
    2f56:	89 83       	std	Y+1, r24	; 0x01
				deleted. */
				pxNewQueue->ucStaticallyAllocated = pdFALSE;
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
    2f58:	29 81       	ldd	r18, Y+1	; 0x01
    2f5a:	3a 81       	ldd	r19, Y+2	; 0x02
    2f5c:	ed 81       	ldd	r30, Y+5	; 0x05
    2f5e:	fe 81       	ldd	r31, Y+6	; 0x06
    2f60:	8f 81       	ldd	r24, Y+7	; 0x07
    2f62:	68 85       	ldd	r22, Y+8	; 0x08
    2f64:	a9 01       	movw	r20, r18
    2f66:	29 85       	ldd	r18, Y+9	; 0x09
    2f68:	8f 01       	movw	r16, r30
    2f6a:	0e 94 c4 17 	call	0x2f88	; 0x2f88 <prvInitialiseNewQueue>
		{
			traceQUEUE_CREATE_FAILED( ucQueueType );
			mtCOVERAGE_TEST_MARKER();
		}

		return pxNewQueue;
    2f6e:	8d 81       	ldd	r24, Y+5	; 0x05
    2f70:	9e 81       	ldd	r25, Y+6	; 0x06
	}
    2f72:	29 96       	adiw	r28, 0x09	; 9
    2f74:	0f b6       	in	r0, 0x3f	; 63
    2f76:	f8 94       	cli
    2f78:	de bf       	out	0x3e, r29	; 62
    2f7a:	0f be       	out	0x3f, r0	; 63
    2f7c:	cd bf       	out	0x3d, r28	; 61
    2f7e:	cf 91       	pop	r28
    2f80:	df 91       	pop	r29
    2f82:	1f 91       	pop	r17
    2f84:	0f 91       	pop	r16
    2f86:	08 95       	ret

00002f88 <prvInitialiseNewQueue>:

#endif /* configSUPPORT_STATIC_ALLOCATION */
/*-----------------------------------------------------------*/

static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue )
{
    2f88:	0f 93       	push	r16
    2f8a:	1f 93       	push	r17
    2f8c:	df 93       	push	r29
    2f8e:	cf 93       	push	r28
    2f90:	cd b7       	in	r28, 0x3d	; 61
    2f92:	de b7       	in	r29, 0x3e	; 62
    2f94:	27 97       	sbiw	r28, 0x07	; 7
    2f96:	0f b6       	in	r0, 0x3f	; 63
    2f98:	f8 94       	cli
    2f9a:	de bf       	out	0x3e, r29	; 62
    2f9c:	0f be       	out	0x3f, r0	; 63
    2f9e:	cd bf       	out	0x3d, r28	; 61
    2fa0:	89 83       	std	Y+1, r24	; 0x01
    2fa2:	6a 83       	std	Y+2, r22	; 0x02
    2fa4:	5c 83       	std	Y+4, r21	; 0x04
    2fa6:	4b 83       	std	Y+3, r20	; 0x03
    2fa8:	2d 83       	std	Y+5, r18	; 0x05
    2faa:	1f 83       	std	Y+7, r17	; 0x07
    2fac:	0e 83       	std	Y+6, r16	; 0x06
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
    2fae:	8a 81       	ldd	r24, Y+2	; 0x02
    2fb0:	88 23       	and	r24, r24
    2fb2:	39 f4       	brne	.+14     	; 0x2fc2 <prvInitialiseNewQueue+0x3a>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    2fb4:	8e 81       	ldd	r24, Y+6	; 0x06
    2fb6:	9f 81       	ldd	r25, Y+7	; 0x07
    2fb8:	ee 81       	ldd	r30, Y+6	; 0x06
    2fba:	ff 81       	ldd	r31, Y+7	; 0x07
    2fbc:	91 83       	std	Z+1, r25	; 0x01
    2fbe:	80 83       	st	Z, r24
    2fc0:	06 c0       	rjmp	.+12     	; 0x2fce <prvInitialiseNewQueue+0x46>
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    2fc2:	8b 81       	ldd	r24, Y+3	; 0x03
    2fc4:	9c 81       	ldd	r25, Y+4	; 0x04
    2fc6:	ee 81       	ldd	r30, Y+6	; 0x06
    2fc8:	ff 81       	ldd	r31, Y+7	; 0x07
    2fca:	91 83       	std	Z+1, r25	; 0x01
    2fcc:	80 83       	st	Z, r24
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
    2fce:	ee 81       	ldd	r30, Y+6	; 0x06
    2fd0:	ff 81       	ldd	r31, Y+7	; 0x07
    2fd2:	89 81       	ldd	r24, Y+1	; 0x01
    2fd4:	83 8f       	std	Z+27, r24	; 0x1b
	pxNewQueue->uxItemSize = uxItemSize;
    2fd6:	ee 81       	ldd	r30, Y+6	; 0x06
    2fd8:	ff 81       	ldd	r31, Y+7	; 0x07
    2fda:	8a 81       	ldd	r24, Y+2	; 0x02
    2fdc:	84 8f       	std	Z+28, r24	; 0x1c
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    2fde:	8e 81       	ldd	r24, Y+6	; 0x06
    2fe0:	9f 81       	ldd	r25, Y+7	; 0x07
    2fe2:	61 e0       	ldi	r22, 0x01	; 1
    2fe4:	0e 94 ed 16 	call	0x2dda	; 0x2dda <xQueueGenericReset>
		pxNewQueue->pxQueueSetContainer = NULL;
	}
	#endif /* configUSE_QUEUE_SETS */

	traceQUEUE_CREATE( pxNewQueue );
}
    2fe8:	27 96       	adiw	r28, 0x07	; 7
    2fea:	0f b6       	in	r0, 0x3f	; 63
    2fec:	f8 94       	cli
    2fee:	de bf       	out	0x3e, r29	; 62
    2ff0:	0f be       	out	0x3f, r0	; 63
    2ff2:	cd bf       	out	0x3d, r28	; 61
    2ff4:	cf 91       	pop	r28
    2ff6:	df 91       	pop	r29
    2ff8:	1f 91       	pop	r17
    2ffa:	0f 91       	pop	r16
    2ffc:	08 95       	ret

00002ffe <xQueueCreateCountingSemaphore>:
/*-----------------------------------------------------------*/

#if( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

	QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount )
	{
    2ffe:	df 93       	push	r29
    3000:	cf 93       	push	r28
    3002:	00 d0       	rcall	.+0      	; 0x3004 <xQueueCreateCountingSemaphore+0x6>
    3004:	00 d0       	rcall	.+0      	; 0x3006 <xQueueCreateCountingSemaphore+0x8>
    3006:	cd b7       	in	r28, 0x3d	; 61
    3008:	de b7       	in	r29, 0x3e	; 62
    300a:	8b 83       	std	Y+3, r24	; 0x03
    300c:	6c 83       	std	Y+4, r22	; 0x04
	QueueHandle_t xHandle;

		configASSERT( uxMaxCount != 0 );
		configASSERT( uxInitialCount <= uxMaxCount );

		xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
    300e:	8b 81       	ldd	r24, Y+3	; 0x03
    3010:	60 e0       	ldi	r22, 0x00	; 0
    3012:	42 e0       	ldi	r20, 0x02	; 2
    3014:	0e 94 73 17 	call	0x2ee6	; 0x2ee6 <xQueueGenericCreate>
    3018:	9a 83       	std	Y+2, r25	; 0x02
    301a:	89 83       	std	Y+1, r24	; 0x01

		if( xHandle != NULL )
    301c:	89 81       	ldd	r24, Y+1	; 0x01
    301e:	9a 81       	ldd	r25, Y+2	; 0x02
    3020:	00 97       	sbiw	r24, 0x00	; 0
    3022:	21 f0       	breq	.+8      	; 0x302c <xQueueCreateCountingSemaphore+0x2e>
		{
			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
    3024:	e9 81       	ldd	r30, Y+1	; 0x01
    3026:	fa 81       	ldd	r31, Y+2	; 0x02
    3028:	8c 81       	ldd	r24, Y+4	; 0x04
    302a:	82 8f       	std	Z+26, r24	; 0x1a
		else
		{
			traceCREATE_COUNTING_SEMAPHORE_FAILED();
		}

		return xHandle;
    302c:	89 81       	ldd	r24, Y+1	; 0x01
    302e:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    3030:	0f 90       	pop	r0
    3032:	0f 90       	pop	r0
    3034:	0f 90       	pop	r0
    3036:	0f 90       	pop	r0
    3038:	cf 91       	pop	r28
    303a:	df 91       	pop	r29
    303c:	08 95       	ret

0000303e <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    303e:	df 93       	push	r29
    3040:	cf 93       	push	r28
    3042:	cd b7       	in	r28, 0x3d	; 61
    3044:	de b7       	in	r29, 0x3e	; 62
    3046:	2f 97       	sbiw	r28, 0x0f	; 15
    3048:	0f b6       	in	r0, 0x3f	; 63
    304a:	f8 94       	cli
    304c:	de bf       	out	0x3e, r29	; 62
    304e:	0f be       	out	0x3f, r0	; 63
    3050:	cd bf       	out	0x3d, r28	; 61
    3052:	99 87       	std	Y+9, r25	; 0x09
    3054:	88 87       	std	Y+8, r24	; 0x08
    3056:	7b 87       	std	Y+11, r23	; 0x0b
    3058:	6a 87       	std	Y+10, r22	; 0x0a
    305a:	5d 87       	std	Y+13, r21	; 0x0d
    305c:	4c 87       	std	Y+12, r20	; 0x0c
    305e:	2e 87       	std	Y+14, r18	; 0x0e
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    3060:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    3062:	88 85       	ldd	r24, Y+8	; 0x08
    3064:	99 85       	ldd	r25, Y+9	; 0x09
    3066:	9a 83       	std	Y+2, r25	; 0x02
    3068:	89 83       	std	Y+1, r24	; 0x01
	/*lint -save -e904 This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    306a:	0f b6       	in	r0, 0x3f	; 63
    306c:	f8 94       	cli
    306e:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    3070:	e9 81       	ldd	r30, Y+1	; 0x01
    3072:	fa 81       	ldd	r31, Y+2	; 0x02
    3074:	92 8d       	ldd	r25, Z+26	; 0x1a
    3076:	e9 81       	ldd	r30, Y+1	; 0x01
    3078:	fa 81       	ldd	r31, Y+2	; 0x02
    307a:	83 8d       	ldd	r24, Z+27	; 0x1b
    307c:	98 17       	cp	r25, r24
    307e:	18 f0       	brcs	.+6      	; 0x3086 <xQueueGenericSend+0x48>
    3080:	8e 85       	ldd	r24, Y+14	; 0x0e
    3082:	82 30       	cpi	r24, 0x02	; 2
    3084:	11 f5       	brne	.+68     	; 0x30ca <xQueueGenericSend+0x8c>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    3086:	89 81       	ldd	r24, Y+1	; 0x01
    3088:	9a 81       	ldd	r25, Y+2	; 0x02
    308a:	2a 85       	ldd	r18, Y+10	; 0x0a
    308c:	3b 85       	ldd	r19, Y+11	; 0x0b
    308e:	b9 01       	movw	r22, r18
    3090:	4e 85       	ldd	r20, Y+14	; 0x0e
    3092:	0e 94 71 1c 	call	0x38e2	; 0x38e2 <prvCopyDataToQueue>
    3096:	8b 83       	std	Y+3, r24	; 0x03

					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3098:	e9 81       	ldd	r30, Y+1	; 0x01
    309a:	fa 81       	ldd	r31, Y+2	; 0x02
    309c:	81 89       	ldd	r24, Z+17	; 0x11
    309e:	88 23       	and	r24, r24
    30a0:	51 f0       	breq	.+20     	; 0x30b6 <xQueueGenericSend+0x78>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    30a2:	89 81       	ldd	r24, Y+1	; 0x01
    30a4:	9a 81       	ldd	r25, Y+2	; 0x02
    30a6:	41 96       	adiw	r24, 0x11	; 17
    30a8:	0e 94 4e 2c 	call	0x589c	; 0x589c <xTaskRemoveFromEventList>
    30ac:	88 23       	and	r24, r24
    30ae:	41 f0       	breq	.+16     	; 0x30c0 <xQueueGenericSend+0x82>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    30b0:	0e 94 d8 15 	call	0x2bb0	; 0x2bb0 <vPortYield>
    30b4:	05 c0       	rjmp	.+10     	; 0x30c0 <xQueueGenericSend+0x82>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    30b6:	8b 81       	ldd	r24, Y+3	; 0x03
    30b8:	88 23       	and	r24, r24
    30ba:	11 f0       	breq	.+4      	; 0x30c0 <xQueueGenericSend+0x82>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    30bc:	0e 94 d8 15 	call	0x2bb0	; 0x2bb0 <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    30c0:	0f 90       	pop	r0
    30c2:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    30c4:	81 e0       	ldi	r24, 0x01	; 1
    30c6:	8f 87       	std	Y+15, r24	; 0x0f
    30c8:	5c c0       	rjmp	.+184    	; 0x3182 <xQueueGenericSend+0x144>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    30ca:	8c 85       	ldd	r24, Y+12	; 0x0c
    30cc:	9d 85       	ldd	r25, Y+13	; 0x0d
    30ce:	00 97       	sbiw	r24, 0x00	; 0
    30d0:	21 f4       	brne	.+8      	; 0x30da <xQueueGenericSend+0x9c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    30d2:	0f 90       	pop	r0
    30d4:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    30d6:	1f 86       	std	Y+15, r1	; 0x0f
    30d8:	54 c0       	rjmp	.+168    	; 0x3182 <xQueueGenericSend+0x144>
				}
				else if( xEntryTimeSet == pdFALSE )
    30da:	8c 81       	ldd	r24, Y+4	; 0x04
    30dc:	88 23       	and	r24, r24
    30de:	31 f4       	brne	.+12     	; 0x30ec <xQueueGenericSend+0xae>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    30e0:	ce 01       	movw	r24, r28
    30e2:	05 96       	adiw	r24, 0x05	; 5
    30e4:	0e 94 34 2d 	call	0x5a68	; 0x5a68 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    30e8:	81 e0       	ldi	r24, 0x01	; 1
    30ea:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    30ec:	0f 90       	pop	r0
    30ee:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    30f0:	0e 94 ae 29 	call	0x535c	; 0x535c <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    30f4:	0f b6       	in	r0, 0x3f	; 63
    30f6:	f8 94       	cli
    30f8:	0f 92       	push	r0
    30fa:	e9 81       	ldd	r30, Y+1	; 0x01
    30fc:	fa 81       	ldd	r31, Y+2	; 0x02
    30fe:	85 8d       	ldd	r24, Z+29	; 0x1d
    3100:	8f 3f       	cpi	r24, 0xFF	; 255
    3102:	19 f4       	brne	.+6      	; 0x310a <xQueueGenericSend+0xcc>
    3104:	e9 81       	ldd	r30, Y+1	; 0x01
    3106:	fa 81       	ldd	r31, Y+2	; 0x02
    3108:	15 8e       	std	Z+29, r1	; 0x1d
    310a:	e9 81       	ldd	r30, Y+1	; 0x01
    310c:	fa 81       	ldd	r31, Y+2	; 0x02
    310e:	86 8d       	ldd	r24, Z+30	; 0x1e
    3110:	8f 3f       	cpi	r24, 0xFF	; 255
    3112:	19 f4       	brne	.+6      	; 0x311a <xQueueGenericSend+0xdc>
    3114:	e9 81       	ldd	r30, Y+1	; 0x01
    3116:	fa 81       	ldd	r31, Y+2	; 0x02
    3118:	16 8e       	std	Z+30, r1	; 0x1e
    311a:	0f 90       	pop	r0
    311c:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    311e:	ce 01       	movw	r24, r28
    3120:	05 96       	adiw	r24, 0x05	; 5
    3122:	9e 01       	movw	r18, r28
    3124:	24 5f       	subi	r18, 0xF4	; 244
    3126:	3f 4f       	sbci	r19, 0xFF	; 255
    3128:	b9 01       	movw	r22, r18
    312a:	0e 94 4d 2d 	call	0x5a9a	; 0x5a9a <xTaskCheckForTimeOut>
    312e:	88 23       	and	r24, r24
    3130:	09 f5       	brne	.+66     	; 0x3174 <xQueueGenericSend+0x136>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    3132:	89 81       	ldd	r24, Y+1	; 0x01
    3134:	9a 81       	ldd	r25, Y+2	; 0x02
    3136:	0e 94 ed 1d 	call	0x3bda	; 0x3bda <prvIsQueueFull>
    313a:	88 23       	and	r24, r24
    313c:	a1 f0       	breq	.+40     	; 0x3166 <xQueueGenericSend+0x128>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    313e:	89 81       	ldd	r24, Y+1	; 0x01
    3140:	9a 81       	ldd	r25, Y+2	; 0x02
    3142:	08 96       	adiw	r24, 0x08	; 8
    3144:	2c 85       	ldd	r18, Y+12	; 0x0c
    3146:	3d 85       	ldd	r19, Y+13	; 0x0d
    3148:	b9 01       	movw	r22, r18
    314a:	0e 94 fc 2b 	call	0x57f8	; 0x57f8 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible that interrupts occurring now
				remove this task from the event list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    314e:	89 81       	ldd	r24, Y+1	; 0x01
    3150:	9a 81       	ldd	r25, Y+2	; 0x02
    3152:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    3156:	0e 94 ba 29 	call	0x5374	; 0x5374 <xTaskResumeAll>
    315a:	88 23       	and	r24, r24
    315c:	09 f0       	breq	.+2      	; 0x3160 <xQueueGenericSend+0x122>
    315e:	85 cf       	rjmp	.-246    	; 0x306a <xQueueGenericSend+0x2c>
				{
					portYIELD_WITHIN_API();
    3160:	0e 94 d8 15 	call	0x2bb0	; 0x2bb0 <vPortYield>
    3164:	82 cf       	rjmp	.-252    	; 0x306a <xQueueGenericSend+0x2c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    3166:	89 81       	ldd	r24, Y+1	; 0x01
    3168:	9a 81       	ldd	r25, Y+2	; 0x02
    316a:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <prvUnlockQueue>
				( void ) xTaskResumeAll();
    316e:	0e 94 ba 29 	call	0x5374	; 0x5374 <xTaskResumeAll>
    3172:	7b cf       	rjmp	.-266    	; 0x306a <xQueueGenericSend+0x2c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    3174:	89 81       	ldd	r24, Y+1	; 0x01
    3176:	9a 81       	ldd	r25, Y+2	; 0x02
    3178:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <prvUnlockQueue>
			( void ) xTaskResumeAll();
    317c:	0e 94 ba 29 	call	0x5374	; 0x5374 <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    3180:	1f 86       	std	Y+15, r1	; 0x0f
    3182:	8f 85       	ldd	r24, Y+15	; 0x0f
		}
	} /*lint -restore */
}
    3184:	2f 96       	adiw	r28, 0x0f	; 15
    3186:	0f b6       	in	r0, 0x3f	; 63
    3188:	f8 94       	cli
    318a:	de bf       	out	0x3e, r29	; 62
    318c:	0f be       	out	0x3f, r0	; 63
    318e:	cd bf       	out	0x3d, r28	; 61
    3190:	cf 91       	pop	r28
    3192:	df 91       	pop	r29
    3194:	08 95       	ret

00003196 <xQueueGenericSendFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    3196:	df 93       	push	r29
    3198:	cf 93       	push	r28
    319a:	cd b7       	in	r28, 0x3d	; 61
    319c:	de b7       	in	r29, 0x3e	; 62
    319e:	2c 97       	sbiw	r28, 0x0c	; 12
    31a0:	0f b6       	in	r0, 0x3f	; 63
    31a2:	f8 94       	cli
    31a4:	de bf       	out	0x3e, r29	; 62
    31a6:	0f be       	out	0x3f, r0	; 63
    31a8:	cd bf       	out	0x3d, r28	; 61
    31aa:	9f 83       	std	Y+7, r25	; 0x07
    31ac:	8e 83       	std	Y+6, r24	; 0x06
    31ae:	79 87       	std	Y+9, r23	; 0x09
    31b0:	68 87       	std	Y+8, r22	; 0x08
    31b2:	5b 87       	std	Y+11, r21	; 0x0b
    31b4:	4a 87       	std	Y+10, r20	; 0x0a
    31b6:	2c 87       	std	Y+12, r18	; 0x0c
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    31b8:	8e 81       	ldd	r24, Y+6	; 0x06
    31ba:	9f 81       	ldd	r25, Y+7	; 0x07
    31bc:	9b 83       	std	Y+3, r25	; 0x03
    31be:	8a 83       	std	Y+2, r24	; 0x02
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    31c0:	1c 82       	std	Y+4, r1	; 0x04
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    31c2:	ea 81       	ldd	r30, Y+2	; 0x02
    31c4:	fb 81       	ldd	r31, Y+3	; 0x03
    31c6:	92 8d       	ldd	r25, Z+26	; 0x1a
    31c8:	ea 81       	ldd	r30, Y+2	; 0x02
    31ca:	fb 81       	ldd	r31, Y+3	; 0x03
    31cc:	83 8d       	ldd	r24, Z+27	; 0x1b
    31ce:	98 17       	cp	r25, r24
    31d0:	18 f0       	brcs	.+6      	; 0x31d8 <xQueueGenericSendFromISR+0x42>
    31d2:	8c 85       	ldd	r24, Y+12	; 0x0c
    31d4:	82 30       	cpi	r24, 0x02	; 2
    31d6:	61 f5       	brne	.+88     	; 0x3230 <xQueueGenericSendFromISR+0x9a>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    31d8:	ea 81       	ldd	r30, Y+2	; 0x02
    31da:	fb 81       	ldd	r31, Y+3	; 0x03
    31dc:	86 8d       	ldd	r24, Z+30	; 0x1e
    31de:	89 83       	std	Y+1, r24	; 0x01
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    31e0:	8a 81       	ldd	r24, Y+2	; 0x02
    31e2:	9b 81       	ldd	r25, Y+3	; 0x03
    31e4:	28 85       	ldd	r18, Y+8	; 0x08
    31e6:	39 85       	ldd	r19, Y+9	; 0x09
    31e8:	b9 01       	movw	r22, r18
    31ea:	4c 85       	ldd	r20, Y+12	; 0x0c
    31ec:	0e 94 71 1c 	call	0x38e2	; 0x38e2 <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    31f0:	89 81       	ldd	r24, Y+1	; 0x01
    31f2:	8f 3f       	cpi	r24, 0xFF	; 255
    31f4:	a9 f4       	brne	.+42     	; 0x3220 <xQueueGenericSendFromISR+0x8a>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    31f6:	ea 81       	ldd	r30, Y+2	; 0x02
    31f8:	fb 81       	ldd	r31, Y+3	; 0x03
    31fa:	81 89       	ldd	r24, Z+17	; 0x11
    31fc:	88 23       	and	r24, r24
    31fe:	a9 f0       	breq	.+42     	; 0x322a <xQueueGenericSendFromISR+0x94>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3200:	8a 81       	ldd	r24, Y+2	; 0x02
    3202:	9b 81       	ldd	r25, Y+3	; 0x03
    3204:	41 96       	adiw	r24, 0x11	; 17
    3206:	0e 94 4e 2c 	call	0x589c	; 0x589c <xTaskRemoveFromEventList>
    320a:	88 23       	and	r24, r24
    320c:	71 f0       	breq	.+28     	; 0x322a <xQueueGenericSendFromISR+0x94>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    320e:	8a 85       	ldd	r24, Y+10	; 0x0a
    3210:	9b 85       	ldd	r25, Y+11	; 0x0b
    3212:	00 97       	sbiw	r24, 0x00	; 0
    3214:	51 f0       	breq	.+20     	; 0x322a <xQueueGenericSendFromISR+0x94>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    3216:	ea 85       	ldd	r30, Y+10	; 0x0a
    3218:	fb 85       	ldd	r31, Y+11	; 0x0b
    321a:	81 e0       	ldi	r24, 0x01	; 1
    321c:	80 83       	st	Z, r24
    321e:	05 c0       	rjmp	.+10     	; 0x322a <xQueueGenericSendFromISR+0x94>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    3220:	89 81       	ldd	r24, Y+1	; 0x01
    3222:	8f 5f       	subi	r24, 0xFF	; 255
    3224:	ea 81       	ldd	r30, Y+2	; 0x02
    3226:	fb 81       	ldd	r31, Y+3	; 0x03
    3228:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    322a:	81 e0       	ldi	r24, 0x01	; 1
    322c:	8d 83       	std	Y+5, r24	; 0x05
    322e:	01 c0       	rjmp	.+2      	; 0x3232 <xQueueGenericSendFromISR+0x9c>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    3230:	1d 82       	std	Y+5, r1	; 0x05
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    3232:	8d 81       	ldd	r24, Y+5	; 0x05
}
    3234:	2c 96       	adiw	r28, 0x0c	; 12
    3236:	0f b6       	in	r0, 0x3f	; 63
    3238:	f8 94       	cli
    323a:	de bf       	out	0x3e, r29	; 62
    323c:	0f be       	out	0x3f, r0	; 63
    323e:	cd bf       	out	0x3d, r28	; 61
    3240:	cf 91       	pop	r28
    3242:	df 91       	pop	r29
    3244:	08 95       	ret

00003246 <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    3246:	df 93       	push	r29
    3248:	cf 93       	push	r28
    324a:	cd b7       	in	r28, 0x3d	; 61
    324c:	de b7       	in	r29, 0x3e	; 62
    324e:	2a 97       	sbiw	r28, 0x0a	; 10
    3250:	0f b6       	in	r0, 0x3f	; 63
    3252:	f8 94       	cli
    3254:	de bf       	out	0x3e, r29	; 62
    3256:	0f be       	out	0x3f, r0	; 63
    3258:	cd bf       	out	0x3d, r28	; 61
    325a:	98 87       	std	Y+8, r25	; 0x08
    325c:	8f 83       	std	Y+7, r24	; 0x07
    325e:	7a 87       	std	Y+10, r23	; 0x0a
    3260:	69 87       	std	Y+9, r22	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    3262:	8f 81       	ldd	r24, Y+7	; 0x07
    3264:	98 85       	ldd	r25, Y+8	; 0x08
    3266:	9c 83       	std	Y+4, r25	; 0x04
    3268:	8b 83       	std	Y+3, r24	; 0x03
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    326a:	1d 82       	std	Y+5, r1	; 0x05
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    326c:	eb 81       	ldd	r30, Y+3	; 0x03
    326e:	fc 81       	ldd	r31, Y+4	; 0x04
    3270:	82 8d       	ldd	r24, Z+26	; 0x1a
    3272:	8a 83       	std	Y+2, r24	; 0x02

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
    3274:	eb 81       	ldd	r30, Y+3	; 0x03
    3276:	fc 81       	ldd	r31, Y+4	; 0x04
    3278:	93 8d       	ldd	r25, Z+27	; 0x1b
    327a:	8a 81       	ldd	r24, Y+2	; 0x02
    327c:	89 17       	cp	r24, r25
    327e:	48 f5       	brcc	.+82     	; 0x32d2 <xQueueGiveFromISR+0x8c>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    3280:	eb 81       	ldd	r30, Y+3	; 0x03
    3282:	fc 81       	ldd	r31, Y+4	; 0x04
    3284:	86 8d       	ldd	r24, Z+30	; 0x1e
    3286:	89 83       	std	Y+1, r24	; 0x01
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    3288:	8a 81       	ldd	r24, Y+2	; 0x02
    328a:	8f 5f       	subi	r24, 0xFF	; 255
    328c:	eb 81       	ldd	r30, Y+3	; 0x03
    328e:	fc 81       	ldd	r31, Y+4	; 0x04
    3290:	82 8f       	std	Z+26, r24	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    3292:	89 81       	ldd	r24, Y+1	; 0x01
    3294:	8f 3f       	cpi	r24, 0xFF	; 255
    3296:	a9 f4       	brne	.+42     	; 0x32c2 <xQueueGiveFromISR+0x7c>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3298:	eb 81       	ldd	r30, Y+3	; 0x03
    329a:	fc 81       	ldd	r31, Y+4	; 0x04
    329c:	81 89       	ldd	r24, Z+17	; 0x11
    329e:	88 23       	and	r24, r24
    32a0:	a9 f0       	breq	.+42     	; 0x32cc <xQueueGiveFromISR+0x86>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    32a2:	8b 81       	ldd	r24, Y+3	; 0x03
    32a4:	9c 81       	ldd	r25, Y+4	; 0x04
    32a6:	41 96       	adiw	r24, 0x11	; 17
    32a8:	0e 94 4e 2c 	call	0x589c	; 0x589c <xTaskRemoveFromEventList>
    32ac:	88 23       	and	r24, r24
    32ae:	71 f0       	breq	.+28     	; 0x32cc <xQueueGiveFromISR+0x86>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    32b0:	89 85       	ldd	r24, Y+9	; 0x09
    32b2:	9a 85       	ldd	r25, Y+10	; 0x0a
    32b4:	00 97       	sbiw	r24, 0x00	; 0
    32b6:	51 f0       	breq	.+20     	; 0x32cc <xQueueGiveFromISR+0x86>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    32b8:	e9 85       	ldd	r30, Y+9	; 0x09
    32ba:	fa 85       	ldd	r31, Y+10	; 0x0a
    32bc:	81 e0       	ldi	r24, 0x01	; 1
    32be:	80 83       	st	Z, r24
    32c0:	05 c0       	rjmp	.+10     	; 0x32cc <xQueueGiveFromISR+0x86>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    32c2:	89 81       	ldd	r24, Y+1	; 0x01
    32c4:	8f 5f       	subi	r24, 0xFF	; 255
    32c6:	eb 81       	ldd	r30, Y+3	; 0x03
    32c8:	fc 81       	ldd	r31, Y+4	; 0x04
    32ca:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    32cc:	81 e0       	ldi	r24, 0x01	; 1
    32ce:	8e 83       	std	Y+6, r24	; 0x06
    32d0:	01 c0       	rjmp	.+2      	; 0x32d4 <xQueueGiveFromISR+0x8e>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    32d2:	1e 82       	std	Y+6, r1	; 0x06
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    32d4:	8e 81       	ldd	r24, Y+6	; 0x06
}
    32d6:	2a 96       	adiw	r28, 0x0a	; 10
    32d8:	0f b6       	in	r0, 0x3f	; 63
    32da:	f8 94       	cli
    32dc:	de bf       	out	0x3e, r29	; 62
    32de:	0f be       	out	0x3f, r0	; 63
    32e0:	cd bf       	out	0x3d, r28	; 61
    32e2:	cf 91       	pop	r28
    32e4:	df 91       	pop	r29
    32e6:	08 95       	ret

000032e8 <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    32e8:	df 93       	push	r29
    32ea:	cf 93       	push	r28
    32ec:	cd b7       	in	r28, 0x3d	; 61
    32ee:	de b7       	in	r29, 0x3e	; 62
    32f0:	2e 97       	sbiw	r28, 0x0e	; 14
    32f2:	0f b6       	in	r0, 0x3f	; 63
    32f4:	f8 94       	cli
    32f6:	de bf       	out	0x3e, r29	; 62
    32f8:	0f be       	out	0x3f, r0	; 63
    32fa:	cd bf       	out	0x3d, r28	; 61
    32fc:	99 87       	std	Y+9, r25	; 0x09
    32fe:	88 87       	std	Y+8, r24	; 0x08
    3300:	7b 87       	std	Y+11, r23	; 0x0b
    3302:	6a 87       	std	Y+10, r22	; 0x0a
    3304:	5d 87       	std	Y+13, r21	; 0x0d
    3306:	4c 87       	std	Y+12, r20	; 0x0c
BaseType_t xEntryTimeSet = pdFALSE;
    3308:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    330a:	88 85       	ldd	r24, Y+8	; 0x08
    330c:	99 85       	ldd	r25, Y+9	; 0x09
    330e:	9b 83       	std	Y+3, r25	; 0x03
    3310:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    3312:	0f b6       	in	r0, 0x3f	; 63
    3314:	f8 94       	cli
    3316:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    3318:	ea 81       	ldd	r30, Y+2	; 0x02
    331a:	fb 81       	ldd	r31, Y+3	; 0x03
    331c:	82 8d       	ldd	r24, Z+26	; 0x1a
    331e:	89 83       	std	Y+1, r24	; 0x01

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    3320:	89 81       	ldd	r24, Y+1	; 0x01
    3322:	88 23       	and	r24, r24
    3324:	f9 f0       	breq	.+62     	; 0x3364 <xQueueReceive+0x7c>
			{
				/* Data available, remove one item. */
				prvCopyDataFromQueue( pxQueue, pvBuffer );
    3326:	8a 81       	ldd	r24, Y+2	; 0x02
    3328:	9b 81       	ldd	r25, Y+3	; 0x03
    332a:	2a 85       	ldd	r18, Y+10	; 0x0a
    332c:	3b 85       	ldd	r19, Y+11	; 0x0b
    332e:	b9 01       	movw	r22, r18
    3330:	0e 94 17 1d 	call	0x3a2e	; 0x3a2e <prvCopyDataFromQueue>
				traceQUEUE_RECEIVE( pxQueue );
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    3334:	89 81       	ldd	r24, Y+1	; 0x01
    3336:	81 50       	subi	r24, 0x01	; 1
    3338:	ea 81       	ldd	r30, Y+2	; 0x02
    333a:	fb 81       	ldd	r31, Y+3	; 0x03
    333c:	82 8f       	std	Z+26, r24	; 0x1a

				/* There is now space in the queue, were any tasks waiting to
				post to the queue?  If so, unblock the highest priority waiting
				task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    333e:	ea 81       	ldd	r30, Y+2	; 0x02
    3340:	fb 81       	ldd	r31, Y+3	; 0x03
    3342:	80 85       	ldd	r24, Z+8	; 0x08
    3344:	88 23       	and	r24, r24
    3346:	49 f0       	breq	.+18     	; 0x335a <xQueueReceive+0x72>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    3348:	8a 81       	ldd	r24, Y+2	; 0x02
    334a:	9b 81       	ldd	r25, Y+3	; 0x03
    334c:	08 96       	adiw	r24, 0x08	; 8
    334e:	0e 94 4e 2c 	call	0x589c	; 0x589c <xTaskRemoveFromEventList>
    3352:	88 23       	and	r24, r24
    3354:	11 f0       	breq	.+4      	; 0x335a <xQueueReceive+0x72>
					{
						queueYIELD_IF_USING_PREEMPTION();
    3356:	0e 94 d8 15 	call	0x2bb0	; 0x2bb0 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    335a:	0f 90       	pop	r0
    335c:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    335e:	81 e0       	ldi	r24, 0x01	; 1
    3360:	8e 87       	std	Y+14, r24	; 0x0e
    3362:	63 c0       	rjmp	.+198    	; 0x342a <xQueueReceive+0x142>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    3364:	8c 85       	ldd	r24, Y+12	; 0x0c
    3366:	9d 85       	ldd	r25, Y+13	; 0x0d
    3368:	00 97       	sbiw	r24, 0x00	; 0
    336a:	21 f4       	brne	.+8      	; 0x3374 <xQueueReceive+0x8c>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    336c:	0f 90       	pop	r0
    336e:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    3370:	1e 86       	std	Y+14, r1	; 0x0e
    3372:	5b c0       	rjmp	.+182    	; 0x342a <xQueueReceive+0x142>
				}
				else if( xEntryTimeSet == pdFALSE )
    3374:	8c 81       	ldd	r24, Y+4	; 0x04
    3376:	88 23       	and	r24, r24
    3378:	31 f4       	brne	.+12     	; 0x3386 <xQueueReceive+0x9e>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    337a:	ce 01       	movw	r24, r28
    337c:	05 96       	adiw	r24, 0x05	; 5
    337e:	0e 94 34 2d 	call	0x5a68	; 0x5a68 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    3382:	81 e0       	ldi	r24, 0x01	; 1
    3384:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    3386:	0f 90       	pop	r0
    3388:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    338a:	0e 94 ae 29 	call	0x535c	; 0x535c <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    338e:	0f b6       	in	r0, 0x3f	; 63
    3390:	f8 94       	cli
    3392:	0f 92       	push	r0
    3394:	ea 81       	ldd	r30, Y+2	; 0x02
    3396:	fb 81       	ldd	r31, Y+3	; 0x03
    3398:	85 8d       	ldd	r24, Z+29	; 0x1d
    339a:	8f 3f       	cpi	r24, 0xFF	; 255
    339c:	19 f4       	brne	.+6      	; 0x33a4 <xQueueReceive+0xbc>
    339e:	ea 81       	ldd	r30, Y+2	; 0x02
    33a0:	fb 81       	ldd	r31, Y+3	; 0x03
    33a2:	15 8e       	std	Z+29, r1	; 0x1d
    33a4:	ea 81       	ldd	r30, Y+2	; 0x02
    33a6:	fb 81       	ldd	r31, Y+3	; 0x03
    33a8:	86 8d       	ldd	r24, Z+30	; 0x1e
    33aa:	8f 3f       	cpi	r24, 0xFF	; 255
    33ac:	19 f4       	brne	.+6      	; 0x33b4 <xQueueReceive+0xcc>
    33ae:	ea 81       	ldd	r30, Y+2	; 0x02
    33b0:	fb 81       	ldd	r31, Y+3	; 0x03
    33b2:	16 8e       	std	Z+30, r1	; 0x1e
    33b4:	0f 90       	pop	r0
    33b6:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    33b8:	ce 01       	movw	r24, r28
    33ba:	05 96       	adiw	r24, 0x05	; 5
    33bc:	9e 01       	movw	r18, r28
    33be:	24 5f       	subi	r18, 0xF4	; 244
    33c0:	3f 4f       	sbci	r19, 0xFF	; 255
    33c2:	b9 01       	movw	r22, r18
    33c4:	0e 94 4d 2d 	call	0x5a9a	; 0x5a9a <xTaskCheckForTimeOut>
    33c8:	88 23       	and	r24, r24
    33ca:	09 f5       	brne	.+66     	; 0x340e <xQueueReceive+0x126>
		{
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    33cc:	8a 81       	ldd	r24, Y+2	; 0x02
    33ce:	9b 81       	ldd	r25, Y+3	; 0x03
    33d0:	0e 94 b1 1d 	call	0x3b62	; 0x3b62 <prvIsQueueEmpty>
    33d4:	88 23       	and	r24, r24
    33d6:	a1 f0       	breq	.+40     	; 0x3400 <xQueueReceive+0x118>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    33d8:	8a 81       	ldd	r24, Y+2	; 0x02
    33da:	9b 81       	ldd	r25, Y+3	; 0x03
    33dc:	41 96       	adiw	r24, 0x11	; 17
    33de:	2c 85       	ldd	r18, Y+12	; 0x0c
    33e0:	3d 85       	ldd	r19, Y+13	; 0x0d
    33e2:	b9 01       	movw	r22, r18
    33e4:	0e 94 fc 2b 	call	0x57f8	; 0x57f8 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    33e8:	8a 81       	ldd	r24, Y+2	; 0x02
    33ea:	9b 81       	ldd	r25, Y+3	; 0x03
    33ec:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    33f0:	0e 94 ba 29 	call	0x5374	; 0x5374 <xTaskResumeAll>
    33f4:	88 23       	and	r24, r24
    33f6:	09 f0       	breq	.+2      	; 0x33fa <xQueueReceive+0x112>
    33f8:	8c cf       	rjmp	.-232    	; 0x3312 <xQueueReceive+0x2a>
				{
					portYIELD_WITHIN_API();
    33fa:	0e 94 d8 15 	call	0x2bb0	; 0x2bb0 <vPortYield>
    33fe:	89 cf       	rjmp	.-238    	; 0x3312 <xQueueReceive+0x2a>
			}
			else
			{
				/* The queue contains data again.  Loop back to try and read the
				data. */
				prvUnlockQueue( pxQueue );
    3400:	8a 81       	ldd	r24, Y+2	; 0x02
    3402:	9b 81       	ldd	r25, Y+3	; 0x03
    3404:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <prvUnlockQueue>
				( void ) xTaskResumeAll();
    3408:	0e 94 ba 29 	call	0x5374	; 0x5374 <xTaskResumeAll>
    340c:	82 cf       	rjmp	.-252    	; 0x3312 <xQueueReceive+0x2a>
		}
		else
		{
			/* Timed out.  If there is no data in the queue exit, otherwise loop
			back and attempt to read the data. */
			prvUnlockQueue( pxQueue );
    340e:	8a 81       	ldd	r24, Y+2	; 0x02
    3410:	9b 81       	ldd	r25, Y+3	; 0x03
    3412:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <prvUnlockQueue>
			( void ) xTaskResumeAll();
    3416:	0e 94 ba 29 	call	0x5374	; 0x5374 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    341a:	8a 81       	ldd	r24, Y+2	; 0x02
    341c:	9b 81       	ldd	r25, Y+3	; 0x03
    341e:	0e 94 b1 1d 	call	0x3b62	; 0x3b62 <prvIsQueueEmpty>
    3422:	88 23       	and	r24, r24
    3424:	09 f4       	brne	.+2      	; 0x3428 <xQueueReceive+0x140>
    3426:	75 cf       	rjmp	.-278    	; 0x3312 <xQueueReceive+0x2a>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    3428:	1e 86       	std	Y+14, r1	; 0x0e
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    342a:	8e 85       	ldd	r24, Y+14	; 0x0e
}
    342c:	2e 96       	adiw	r28, 0x0e	; 14
    342e:	0f b6       	in	r0, 0x3f	; 63
    3430:	f8 94       	cli
    3432:	de bf       	out	0x3e, r29	; 62
    3434:	0f be       	out	0x3f, r0	; 63
    3436:	cd bf       	out	0x3d, r28	; 61
    3438:	cf 91       	pop	r28
    343a:	df 91       	pop	r29
    343c:	08 95       	ret

0000343e <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
{
    343e:	df 93       	push	r29
    3440:	cf 93       	push	r28
    3442:	cd b7       	in	r28, 0x3d	; 61
    3444:	de b7       	in	r29, 0x3e	; 62
    3446:	2c 97       	sbiw	r28, 0x0c	; 12
    3448:	0f b6       	in	r0, 0x3f	; 63
    344a:	f8 94       	cli
    344c:	de bf       	out	0x3e, r29	; 62
    344e:	0f be       	out	0x3f, r0	; 63
    3450:	cd bf       	out	0x3d, r28	; 61
    3452:	99 87       	std	Y+9, r25	; 0x09
    3454:	88 87       	std	Y+8, r24	; 0x08
    3456:	7b 87       	std	Y+11, r23	; 0x0b
    3458:	6a 87       	std	Y+10, r22	; 0x0a
BaseType_t xEntryTimeSet = pdFALSE;
    345a:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    345c:	88 85       	ldd	r24, Y+8	; 0x08
    345e:	99 85       	ldd	r25, Y+9	; 0x09
    3460:	9b 83       	std	Y+3, r25	; 0x03
    3462:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904 This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    3464:	0f b6       	in	r0, 0x3f	; 63
    3466:	f8 94       	cli
    3468:	0f 92       	push	r0
		{
			/* Semaphores are queues with an item size of 0, and where the
			number of messages in the queue is the semaphore's count value. */
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
    346a:	ea 81       	ldd	r30, Y+2	; 0x02
    346c:	fb 81       	ldd	r31, Y+3	; 0x03
    346e:	82 8d       	ldd	r24, Z+26	; 0x1a
    3470:	89 83       	std	Y+1, r24	; 0x01

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
    3472:	89 81       	ldd	r24, Y+1	; 0x01
    3474:	88 23       	and	r24, r24
    3476:	c1 f0       	breq	.+48     	; 0x34a8 <xQueueSemaphoreTake+0x6a>
			{
				traceQUEUE_RECEIVE( pxQueue );

				/* Semaphores are queues with a data size of zero and where the
				messages waiting is the semaphore's count.  Reduce the count. */
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
    3478:	89 81       	ldd	r24, Y+1	; 0x01
    347a:	81 50       	subi	r24, 0x01	; 1
    347c:	ea 81       	ldd	r30, Y+2	; 0x02
    347e:	fb 81       	ldd	r31, Y+3	; 0x03
    3480:	82 8f       	std	Z+26, r24	; 0x1a
				}
				#endif /* configUSE_MUTEXES */

				/* Check to see if other tasks are blocked waiting to give the
				semaphore, and if so, unblock the highest priority such task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3482:	ea 81       	ldd	r30, Y+2	; 0x02
    3484:	fb 81       	ldd	r31, Y+3	; 0x03
    3486:	80 85       	ldd	r24, Z+8	; 0x08
    3488:	88 23       	and	r24, r24
    348a:	49 f0       	breq	.+18     	; 0x349e <xQueueSemaphoreTake+0x60>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    348c:	8a 81       	ldd	r24, Y+2	; 0x02
    348e:	9b 81       	ldd	r25, Y+3	; 0x03
    3490:	08 96       	adiw	r24, 0x08	; 8
    3492:	0e 94 4e 2c 	call	0x589c	; 0x589c <xTaskRemoveFromEventList>
    3496:	88 23       	and	r24, r24
    3498:	11 f0       	breq	.+4      	; 0x349e <xQueueSemaphoreTake+0x60>
					{
						queueYIELD_IF_USING_PREEMPTION();
    349a:	0e 94 d8 15 	call	0x2bb0	; 0x2bb0 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    349e:	0f 90       	pop	r0
    34a0:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    34a2:	81 e0       	ldi	r24, 0x01	; 1
    34a4:	8c 87       	std	Y+12, r24	; 0x0c
    34a6:	63 c0       	rjmp	.+198    	; 0x356e <xQueueSemaphoreTake+0x130>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    34a8:	8a 85       	ldd	r24, Y+10	; 0x0a
    34aa:	9b 85       	ldd	r25, Y+11	; 0x0b
    34ac:	00 97       	sbiw	r24, 0x00	; 0
    34ae:	21 f4       	brne	.+8      	; 0x34b8 <xQueueSemaphoreTake+0x7a>
					}
					#endif /* configUSE_MUTEXES */

					/* The semaphore count was 0 and no block time is specified
					(or the block time has expired) so exit now. */
					taskEXIT_CRITICAL();
    34b0:	0f 90       	pop	r0
    34b2:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    34b4:	1c 86       	std	Y+12, r1	; 0x0c
    34b6:	5b c0       	rjmp	.+182    	; 0x356e <xQueueSemaphoreTake+0x130>
				}
				else if( xEntryTimeSet == pdFALSE )
    34b8:	8c 81       	ldd	r24, Y+4	; 0x04
    34ba:	88 23       	and	r24, r24
    34bc:	31 f4       	brne	.+12     	; 0x34ca <xQueueSemaphoreTake+0x8c>
				{
					/* The semaphore count was 0 and a block time was specified
					so configure the timeout structure ready to block. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    34be:	ce 01       	movw	r24, r28
    34c0:	05 96       	adiw	r24, 0x05	; 5
    34c2:	0e 94 34 2d 	call	0x5a68	; 0x5a68 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    34c6:	81 e0       	ldi	r24, 0x01	; 1
    34c8:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    34ca:	0f 90       	pop	r0
    34cc:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can give to and take from the semaphore
		now the critical section has been exited. */

		vTaskSuspendAll();
    34ce:	0e 94 ae 29 	call	0x535c	; 0x535c <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    34d2:	0f b6       	in	r0, 0x3f	; 63
    34d4:	f8 94       	cli
    34d6:	0f 92       	push	r0
    34d8:	ea 81       	ldd	r30, Y+2	; 0x02
    34da:	fb 81       	ldd	r31, Y+3	; 0x03
    34dc:	85 8d       	ldd	r24, Z+29	; 0x1d
    34de:	8f 3f       	cpi	r24, 0xFF	; 255
    34e0:	19 f4       	brne	.+6      	; 0x34e8 <xQueueSemaphoreTake+0xaa>
    34e2:	ea 81       	ldd	r30, Y+2	; 0x02
    34e4:	fb 81       	ldd	r31, Y+3	; 0x03
    34e6:	15 8e       	std	Z+29, r1	; 0x1d
    34e8:	ea 81       	ldd	r30, Y+2	; 0x02
    34ea:	fb 81       	ldd	r31, Y+3	; 0x03
    34ec:	86 8d       	ldd	r24, Z+30	; 0x1e
    34ee:	8f 3f       	cpi	r24, 0xFF	; 255
    34f0:	19 f4       	brne	.+6      	; 0x34f8 <xQueueSemaphoreTake+0xba>
    34f2:	ea 81       	ldd	r30, Y+2	; 0x02
    34f4:	fb 81       	ldd	r31, Y+3	; 0x03
    34f6:	16 8e       	std	Z+30, r1	; 0x1e
    34f8:	0f 90       	pop	r0
    34fa:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    34fc:	ce 01       	movw	r24, r28
    34fe:	05 96       	adiw	r24, 0x05	; 5
    3500:	9e 01       	movw	r18, r28
    3502:	26 5f       	subi	r18, 0xF6	; 246
    3504:	3f 4f       	sbci	r19, 0xFF	; 255
    3506:	b9 01       	movw	r22, r18
    3508:	0e 94 4d 2d 	call	0x5a9a	; 0x5a9a <xTaskCheckForTimeOut>
    350c:	88 23       	and	r24, r24
    350e:	09 f5       	brne	.+66     	; 0x3552 <xQueueSemaphoreTake+0x114>
		{
			/* A block time is specified and not expired.  If the semaphore
			count is 0 then enter the Blocked state to wait for a semaphore to
			become available.  As semaphores are implemented with queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    3510:	8a 81       	ldd	r24, Y+2	; 0x02
    3512:	9b 81       	ldd	r25, Y+3	; 0x03
    3514:	0e 94 b1 1d 	call	0x3b62	; 0x3b62 <prvIsQueueEmpty>
    3518:	88 23       	and	r24, r24
    351a:	a1 f0       	breq	.+40     	; 0x3544 <xQueueSemaphoreTake+0x106>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    351c:	8a 81       	ldd	r24, Y+2	; 0x02
    351e:	9b 81       	ldd	r25, Y+3	; 0x03
    3520:	41 96       	adiw	r24, 0x11	; 17
    3522:	2a 85       	ldd	r18, Y+10	; 0x0a
    3524:	3b 85       	ldd	r19, Y+11	; 0x0b
    3526:	b9 01       	movw	r22, r18
    3528:	0e 94 fc 2b 	call	0x57f8	; 0x57f8 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    352c:	8a 81       	ldd	r24, Y+2	; 0x02
    352e:	9b 81       	ldd	r25, Y+3	; 0x03
    3530:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    3534:	0e 94 ba 29 	call	0x5374	; 0x5374 <xTaskResumeAll>
    3538:	88 23       	and	r24, r24
    353a:	09 f0       	breq	.+2      	; 0x353e <xQueueSemaphoreTake+0x100>
    353c:	93 cf       	rjmp	.-218    	; 0x3464 <xQueueSemaphoreTake+0x26>
				{
					portYIELD_WITHIN_API();
    353e:	0e 94 d8 15 	call	0x2bb0	; 0x2bb0 <vPortYield>
    3542:	90 cf       	rjmp	.-224    	; 0x3464 <xQueueSemaphoreTake+0x26>
			}
			else
			{
				/* There was no timeout and the semaphore count was not 0, so
				attempt to take the semaphore again. */
				prvUnlockQueue( pxQueue );
    3544:	8a 81       	ldd	r24, Y+2	; 0x02
    3546:	9b 81       	ldd	r25, Y+3	; 0x03
    3548:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <prvUnlockQueue>
				( void ) xTaskResumeAll();
    354c:	0e 94 ba 29 	call	0x5374	; 0x5374 <xTaskResumeAll>
    3550:	89 cf       	rjmp	.-238    	; 0x3464 <xQueueSemaphoreTake+0x26>
			}
		}
		else
		{
			/* Timed out. */
			prvUnlockQueue( pxQueue );
    3552:	8a 81       	ldd	r24, Y+2	; 0x02
    3554:	9b 81       	ldd	r25, Y+3	; 0x03
    3556:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <prvUnlockQueue>
			( void ) xTaskResumeAll();
    355a:	0e 94 ba 29 	call	0x5374	; 0x5374 <xTaskResumeAll>

			/* If the semaphore count is 0 exit now as the timeout has
			expired.  Otherwise return to attempt to take the semaphore that is
			known to be available.  As semaphores are implemented by queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    355e:	8a 81       	ldd	r24, Y+2	; 0x02
    3560:	9b 81       	ldd	r25, Y+3	; 0x03
    3562:	0e 94 b1 1d 	call	0x3b62	; 0x3b62 <prvIsQueueEmpty>
    3566:	88 23       	and	r24, r24
    3568:	09 f4       	brne	.+2      	; 0x356c <xQueueSemaphoreTake+0x12e>
    356a:	7c cf       	rjmp	.-264    	; 0x3464 <xQueueSemaphoreTake+0x26>
					}
				}
				#endif /* configUSE_MUTEXES */

				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    356c:	1c 86       	std	Y+12, r1	; 0x0c
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    356e:	8c 85       	ldd	r24, Y+12	; 0x0c
}
    3570:	2c 96       	adiw	r28, 0x0c	; 12
    3572:	0f b6       	in	r0, 0x3f	; 63
    3574:	f8 94       	cli
    3576:	de bf       	out	0x3e, r29	; 62
    3578:	0f be       	out	0x3f, r0	; 63
    357a:	cd bf       	out	0x3d, r28	; 61
    357c:	cf 91       	pop	r28
    357e:	df 91       	pop	r29
    3580:	08 95       	ret

00003582 <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    3582:	df 93       	push	r29
    3584:	cf 93       	push	r28
    3586:	cd b7       	in	r28, 0x3d	; 61
    3588:	de b7       	in	r29, 0x3e	; 62
    358a:	60 97       	sbiw	r28, 0x10	; 16
    358c:	0f b6       	in	r0, 0x3f	; 63
    358e:	f8 94       	cli
    3590:	de bf       	out	0x3e, r29	; 62
    3592:	0f be       	out	0x3f, r0	; 63
    3594:	cd bf       	out	0x3d, r28	; 61
    3596:	9b 87       	std	Y+11, r25	; 0x0b
    3598:	8a 87       	std	Y+10, r24	; 0x0a
    359a:	7d 87       	std	Y+13, r23	; 0x0d
    359c:	6c 87       	std	Y+12, r22	; 0x0c
    359e:	5f 87       	std	Y+15, r21	; 0x0f
    35a0:	4e 87       	std	Y+14, r20	; 0x0e
BaseType_t xEntryTimeSet = pdFALSE;
    35a2:	1e 82       	std	Y+6, r1	; 0x06
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = xQueue;
    35a4:	8a 85       	ldd	r24, Y+10	; 0x0a
    35a6:	9b 85       	ldd	r25, Y+11	; 0x0b
    35a8:	9b 83       	std	Y+3, r25	; 0x03
    35aa:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    35ac:	0f b6       	in	r0, 0x3f	; 63
    35ae:	f8 94       	cli
    35b0:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    35b2:	ea 81       	ldd	r30, Y+2	; 0x02
    35b4:	fb 81       	ldd	r31, Y+3	; 0x03
    35b6:	82 8d       	ldd	r24, Z+26	; 0x1a
    35b8:	89 83       	std	Y+1, r24	; 0x01

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    35ba:	89 81       	ldd	r24, Y+1	; 0x01
    35bc:	88 23       	and	r24, r24
    35be:	31 f1       	breq	.+76     	; 0x360c <xQueuePeek+0x8a>
			{
				/* Remember the read position so it can be reset after the data
				is read from the queue as this function is only peeking the
				data, not removing it. */
				pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    35c0:	ea 81       	ldd	r30, Y+2	; 0x02
    35c2:	fb 81       	ldd	r31, Y+3	; 0x03
    35c4:	86 81       	ldd	r24, Z+6	; 0x06
    35c6:	97 81       	ldd	r25, Z+7	; 0x07
    35c8:	9d 83       	std	Y+5, r25	; 0x05
    35ca:	8c 83       	std	Y+4, r24	; 0x04

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    35cc:	8a 81       	ldd	r24, Y+2	; 0x02
    35ce:	9b 81       	ldd	r25, Y+3	; 0x03
    35d0:	2c 85       	ldd	r18, Y+12	; 0x0c
    35d2:	3d 85       	ldd	r19, Y+13	; 0x0d
    35d4:	b9 01       	movw	r22, r18
    35d6:	0e 94 17 1d 	call	0x3a2e	; 0x3a2e <prvCopyDataFromQueue>
				traceQUEUE_PEEK( pxQueue );

				/* The data is not being removed, so reset the read pointer. */
				pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    35da:	ea 81       	ldd	r30, Y+2	; 0x02
    35dc:	fb 81       	ldd	r31, Y+3	; 0x03
    35de:	8c 81       	ldd	r24, Y+4	; 0x04
    35e0:	9d 81       	ldd	r25, Y+5	; 0x05
    35e2:	97 83       	std	Z+7, r25	; 0x07
    35e4:	86 83       	std	Z+6, r24	; 0x06

				/* The data is being left in the queue, so see if there are
				any other tasks waiting for the data. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    35e6:	ea 81       	ldd	r30, Y+2	; 0x02
    35e8:	fb 81       	ldd	r31, Y+3	; 0x03
    35ea:	81 89       	ldd	r24, Z+17	; 0x11
    35ec:	88 23       	and	r24, r24
    35ee:	49 f0       	breq	.+18     	; 0x3602 <xQueuePeek+0x80>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    35f0:	8a 81       	ldd	r24, Y+2	; 0x02
    35f2:	9b 81       	ldd	r25, Y+3	; 0x03
    35f4:	41 96       	adiw	r24, 0x11	; 17
    35f6:	0e 94 4e 2c 	call	0x589c	; 0x589c <xTaskRemoveFromEventList>
    35fa:	88 23       	and	r24, r24
    35fc:	11 f0       	breq	.+4      	; 0x3602 <xQueuePeek+0x80>
					{
						/* The task waiting has a higher priority than this task. */
						queueYIELD_IF_USING_PREEMPTION();
    35fe:	0e 94 d8 15 	call	0x2bb0	; 0x2bb0 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    3602:	0f 90       	pop	r0
    3604:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    3606:	81 e0       	ldi	r24, 0x01	; 1
    3608:	88 8b       	std	Y+16, r24	; 0x10
    360a:	63 c0       	rjmp	.+198    	; 0x36d2 <xQueuePeek+0x150>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    360c:	8e 85       	ldd	r24, Y+14	; 0x0e
    360e:	9f 85       	ldd	r25, Y+15	; 0x0f
    3610:	00 97       	sbiw	r24, 0x00	; 0
    3612:	21 f4       	brne	.+8      	; 0x361c <xQueuePeek+0x9a>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    3614:	0f 90       	pop	r0
    3616:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_PEEK_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    3618:	18 8a       	std	Y+16, r1	; 0x10
    361a:	5b c0       	rjmp	.+182    	; 0x36d2 <xQueuePeek+0x150>
				}
				else if( xEntryTimeSet == pdFALSE )
    361c:	8e 81       	ldd	r24, Y+6	; 0x06
    361e:	88 23       	and	r24, r24
    3620:	31 f4       	brne	.+12     	; 0x362e <xQueuePeek+0xac>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure ready to enter the blocked
					state. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    3622:	ce 01       	movw	r24, r28
    3624:	07 96       	adiw	r24, 0x07	; 7
    3626:	0e 94 34 2d 	call	0x5a68	; 0x5a68 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    362a:	81 e0       	ldi	r24, 0x01	; 1
    362c:	8e 83       	std	Y+6, r24	; 0x06
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    362e:	0f 90       	pop	r0
    3630:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    3632:	0e 94 ae 29 	call	0x535c	; 0x535c <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    3636:	0f b6       	in	r0, 0x3f	; 63
    3638:	f8 94       	cli
    363a:	0f 92       	push	r0
    363c:	ea 81       	ldd	r30, Y+2	; 0x02
    363e:	fb 81       	ldd	r31, Y+3	; 0x03
    3640:	85 8d       	ldd	r24, Z+29	; 0x1d
    3642:	8f 3f       	cpi	r24, 0xFF	; 255
    3644:	19 f4       	brne	.+6      	; 0x364c <xQueuePeek+0xca>
    3646:	ea 81       	ldd	r30, Y+2	; 0x02
    3648:	fb 81       	ldd	r31, Y+3	; 0x03
    364a:	15 8e       	std	Z+29, r1	; 0x1d
    364c:	ea 81       	ldd	r30, Y+2	; 0x02
    364e:	fb 81       	ldd	r31, Y+3	; 0x03
    3650:	86 8d       	ldd	r24, Z+30	; 0x1e
    3652:	8f 3f       	cpi	r24, 0xFF	; 255
    3654:	19 f4       	brne	.+6      	; 0x365c <xQueuePeek+0xda>
    3656:	ea 81       	ldd	r30, Y+2	; 0x02
    3658:	fb 81       	ldd	r31, Y+3	; 0x03
    365a:	16 8e       	std	Z+30, r1	; 0x1e
    365c:	0f 90       	pop	r0
    365e:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    3660:	ce 01       	movw	r24, r28
    3662:	07 96       	adiw	r24, 0x07	; 7
    3664:	9e 01       	movw	r18, r28
    3666:	22 5f       	subi	r18, 0xF2	; 242
    3668:	3f 4f       	sbci	r19, 0xFF	; 255
    366a:	b9 01       	movw	r22, r18
    366c:	0e 94 4d 2d 	call	0x5a9a	; 0x5a9a <xTaskCheckForTimeOut>
    3670:	88 23       	and	r24, r24
    3672:	09 f5       	brne	.+66     	; 0x36b6 <xQueuePeek+0x134>
		{
			/* Timeout has not expired yet, check to see if there is data in the
			queue now, and if not enter the Blocked state to wait for data. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    3674:	8a 81       	ldd	r24, Y+2	; 0x02
    3676:	9b 81       	ldd	r25, Y+3	; 0x03
    3678:	0e 94 b1 1d 	call	0x3b62	; 0x3b62 <prvIsQueueEmpty>
    367c:	88 23       	and	r24, r24
    367e:	a1 f0       	breq	.+40     	; 0x36a8 <xQueuePeek+0x126>
			{
				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    3680:	8a 81       	ldd	r24, Y+2	; 0x02
    3682:	9b 81       	ldd	r25, Y+3	; 0x03
    3684:	41 96       	adiw	r24, 0x11	; 17
    3686:	2e 85       	ldd	r18, Y+14	; 0x0e
    3688:	3f 85       	ldd	r19, Y+15	; 0x0f
    368a:	b9 01       	movw	r22, r18
    368c:	0e 94 fc 2b 	call	0x57f8	; 0x57f8 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    3690:	8a 81       	ldd	r24, Y+2	; 0x02
    3692:	9b 81       	ldd	r25, Y+3	; 0x03
    3694:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    3698:	0e 94 ba 29 	call	0x5374	; 0x5374 <xTaskResumeAll>
    369c:	88 23       	and	r24, r24
    369e:	09 f0       	breq	.+2      	; 0x36a2 <xQueuePeek+0x120>
    36a0:	85 cf       	rjmp	.-246    	; 0x35ac <xQueuePeek+0x2a>
				{
					portYIELD_WITHIN_API();
    36a2:	0e 94 d8 15 	call	0x2bb0	; 0x2bb0 <vPortYield>
    36a6:	82 cf       	rjmp	.-252    	; 0x35ac <xQueuePeek+0x2a>
			}
			else
			{
				/* There is data in the queue now, so don't enter the blocked
				state, instead return to try and obtain the data. */
				prvUnlockQueue( pxQueue );
    36a8:	8a 81       	ldd	r24, Y+2	; 0x02
    36aa:	9b 81       	ldd	r25, Y+3	; 0x03
    36ac:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <prvUnlockQueue>
				( void ) xTaskResumeAll();
    36b0:	0e 94 ba 29 	call	0x5374	; 0x5374 <xTaskResumeAll>
    36b4:	7b cf       	rjmp	.-266    	; 0x35ac <xQueuePeek+0x2a>
		}
		else
		{
			/* The timeout has expired.  If there is still no data in the queue
			exit, otherwise go back and try to read the data again. */
			prvUnlockQueue( pxQueue );
    36b6:	8a 81       	ldd	r24, Y+2	; 0x02
    36b8:	9b 81       	ldd	r25, Y+3	; 0x03
    36ba:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <prvUnlockQueue>
			( void ) xTaskResumeAll();
    36be:	0e 94 ba 29 	call	0x5374	; 0x5374 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    36c2:	8a 81       	ldd	r24, Y+2	; 0x02
    36c4:	9b 81       	ldd	r25, Y+3	; 0x03
    36c6:	0e 94 b1 1d 	call	0x3b62	; 0x3b62 <prvIsQueueEmpty>
    36ca:	88 23       	and	r24, r24
    36cc:	09 f4       	brne	.+2      	; 0x36d0 <xQueuePeek+0x14e>
    36ce:	6e cf       	rjmp	.-292    	; 0x35ac <xQueuePeek+0x2a>
			{
				traceQUEUE_PEEK_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    36d0:	18 8a       	std	Y+16, r1	; 0x10
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    36d2:	88 89       	ldd	r24, Y+16	; 0x10
}
    36d4:	60 96       	adiw	r28, 0x10	; 16
    36d6:	0f b6       	in	r0, 0x3f	; 63
    36d8:	f8 94       	cli
    36da:	de bf       	out	0x3e, r29	; 62
    36dc:	0f be       	out	0x3f, r0	; 63
    36de:	cd bf       	out	0x3d, r28	; 61
    36e0:	cf 91       	pop	r28
    36e2:	df 91       	pop	r29
    36e4:	08 95       	ret

000036e6 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    36e6:	df 93       	push	r29
    36e8:	cf 93       	push	r28
    36ea:	cd b7       	in	r28, 0x3d	; 61
    36ec:	de b7       	in	r29, 0x3e	; 62
    36ee:	2c 97       	sbiw	r28, 0x0c	; 12
    36f0:	0f b6       	in	r0, 0x3f	; 63
    36f2:	f8 94       	cli
    36f4:	de bf       	out	0x3e, r29	; 62
    36f6:	0f be       	out	0x3f, r0	; 63
    36f8:	cd bf       	out	0x3d, r28	; 61
    36fa:	98 87       	std	Y+8, r25	; 0x08
    36fc:	8f 83       	std	Y+7, r24	; 0x07
    36fe:	7a 87       	std	Y+10, r23	; 0x0a
    3700:	69 87       	std	Y+9, r22	; 0x09
    3702:	5c 87       	std	Y+12, r21	; 0x0c
    3704:	4b 87       	std	Y+11, r20	; 0x0b
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    3706:	8f 81       	ldd	r24, Y+7	; 0x07
    3708:	98 85       	ldd	r25, Y+8	; 0x08
    370a:	9c 83       	std	Y+4, r25	; 0x04
    370c:	8b 83       	std	Y+3, r24	; 0x03
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    370e:	1d 82       	std	Y+5, r1	; 0x05
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    3710:	eb 81       	ldd	r30, Y+3	; 0x03
    3712:	fc 81       	ldd	r31, Y+4	; 0x04
    3714:	82 8d       	ldd	r24, Z+26	; 0x1a
    3716:	8a 83       	std	Y+2, r24	; 0x02

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    3718:	8a 81       	ldd	r24, Y+2	; 0x02
    371a:	88 23       	and	r24, r24
    371c:	81 f1       	breq	.+96     	; 0x377e <xQueueReceiveFromISR+0x98>
		{
			const int8_t cRxLock = pxQueue->cRxLock;
    371e:	eb 81       	ldd	r30, Y+3	; 0x03
    3720:	fc 81       	ldd	r31, Y+4	; 0x04
    3722:	85 8d       	ldd	r24, Z+29	; 0x1d
    3724:	89 83       	std	Y+1, r24	; 0x01

			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    3726:	8b 81       	ldd	r24, Y+3	; 0x03
    3728:	9c 81       	ldd	r25, Y+4	; 0x04
    372a:	29 85       	ldd	r18, Y+9	; 0x09
    372c:	3a 85       	ldd	r19, Y+10	; 0x0a
    372e:	b9 01       	movw	r22, r18
    3730:	0e 94 17 1d 	call	0x3a2e	; 0x3a2e <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    3734:	8a 81       	ldd	r24, Y+2	; 0x02
    3736:	81 50       	subi	r24, 0x01	; 1
    3738:	eb 81       	ldd	r30, Y+3	; 0x03
    373a:	fc 81       	ldd	r31, Y+4	; 0x04
    373c:	82 8f       	std	Z+26, r24	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
    373e:	89 81       	ldd	r24, Y+1	; 0x01
    3740:	8f 3f       	cpi	r24, 0xFF	; 255
    3742:	a9 f4       	brne	.+42     	; 0x376e <xQueueReceiveFromISR+0x88>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3744:	eb 81       	ldd	r30, Y+3	; 0x03
    3746:	fc 81       	ldd	r31, Y+4	; 0x04
    3748:	80 85       	ldd	r24, Z+8	; 0x08
    374a:	88 23       	and	r24, r24
    374c:	a9 f0       	breq	.+42     	; 0x3778 <xQueueReceiveFromISR+0x92>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    374e:	8b 81       	ldd	r24, Y+3	; 0x03
    3750:	9c 81       	ldd	r25, Y+4	; 0x04
    3752:	08 96       	adiw	r24, 0x08	; 8
    3754:	0e 94 4e 2c 	call	0x589c	; 0x589c <xTaskRemoveFromEventList>
    3758:	88 23       	and	r24, r24
    375a:	71 f0       	breq	.+28     	; 0x3778 <xQueueReceiveFromISR+0x92>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    375c:	8b 85       	ldd	r24, Y+11	; 0x0b
    375e:	9c 85       	ldd	r25, Y+12	; 0x0c
    3760:	00 97       	sbiw	r24, 0x00	; 0
    3762:	51 f0       	breq	.+20     	; 0x3778 <xQueueReceiveFromISR+0x92>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    3764:	eb 85       	ldd	r30, Y+11	; 0x0b
    3766:	fc 85       	ldd	r31, Y+12	; 0x0c
    3768:	81 e0       	ldi	r24, 0x01	; 1
    376a:	80 83       	st	Z, r24
    376c:	05 c0       	rjmp	.+10     	; 0x3778 <xQueueReceiveFromISR+0x92>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
    376e:	89 81       	ldd	r24, Y+1	; 0x01
    3770:	8f 5f       	subi	r24, 0xFF	; 255
    3772:	eb 81       	ldd	r30, Y+3	; 0x03
    3774:	fc 81       	ldd	r31, Y+4	; 0x04
    3776:	85 8f       	std	Z+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    3778:	81 e0       	ldi	r24, 0x01	; 1
    377a:	8e 83       	std	Y+6, r24	; 0x06
    377c:	01 c0       	rjmp	.+2      	; 0x3780 <xQueueReceiveFromISR+0x9a>
		}
		else
		{
			xReturn = pdFAIL;
    377e:	1e 82       	std	Y+6, r1	; 0x06
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    3780:	8e 81       	ldd	r24, Y+6	; 0x06
}
    3782:	2c 96       	adiw	r28, 0x0c	; 12
    3784:	0f b6       	in	r0, 0x3f	; 63
    3786:	f8 94       	cli
    3788:	de bf       	out	0x3e, r29	; 62
    378a:	0f be       	out	0x3f, r0	; 63
    378c:	cd bf       	out	0x3d, r28	; 61
    378e:	cf 91       	pop	r28
    3790:	df 91       	pop	r29
    3792:	08 95       	ret

00003794 <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
    3794:	df 93       	push	r29
    3796:	cf 93       	push	r28
    3798:	cd b7       	in	r28, 0x3d	; 61
    379a:	de b7       	in	r29, 0x3e	; 62
    379c:	2a 97       	sbiw	r28, 0x0a	; 10
    379e:	0f b6       	in	r0, 0x3f	; 63
    37a0:	f8 94       	cli
    37a2:	de bf       	out	0x3e, r29	; 62
    37a4:	0f be       	out	0x3f, r0	; 63
    37a6:	cd bf       	out	0x3d, r28	; 61
    37a8:	98 87       	std	Y+8, r25	; 0x08
    37aa:	8f 83       	std	Y+7, r24	; 0x07
    37ac:	7a 87       	std	Y+10, r23	; 0x0a
    37ae:	69 87       	std	Y+9, r22	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = xQueue;
    37b0:	8f 81       	ldd	r24, Y+7	; 0x07
    37b2:	98 85       	ldd	r25, Y+8	; 0x08
    37b4:	9a 83       	std	Y+2, r25	; 0x02
    37b6:	89 83       	std	Y+1, r24	; 0x01
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    37b8:	1d 82       	std	Y+5, r1	; 0x05
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    37ba:	e9 81       	ldd	r30, Y+1	; 0x01
    37bc:	fa 81       	ldd	r31, Y+2	; 0x02
    37be:	82 8d       	ldd	r24, Z+26	; 0x1a
    37c0:	88 23       	and	r24, r24
    37c2:	b1 f0       	breq	.+44     	; 0x37f0 <xQueuePeekFromISR+0x5c>
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    37c4:	e9 81       	ldd	r30, Y+1	; 0x01
    37c6:	fa 81       	ldd	r31, Y+2	; 0x02
    37c8:	86 81       	ldd	r24, Z+6	; 0x06
    37ca:	97 81       	ldd	r25, Z+7	; 0x07
    37cc:	9c 83       	std	Y+4, r25	; 0x04
    37ce:	8b 83       	std	Y+3, r24	; 0x03
			prvCopyDataFromQueue( pxQueue, pvBuffer );
    37d0:	89 81       	ldd	r24, Y+1	; 0x01
    37d2:	9a 81       	ldd	r25, Y+2	; 0x02
    37d4:	29 85       	ldd	r18, Y+9	; 0x09
    37d6:	3a 85       	ldd	r19, Y+10	; 0x0a
    37d8:	b9 01       	movw	r22, r18
    37da:	0e 94 17 1d 	call	0x3a2e	; 0x3a2e <prvCopyDataFromQueue>
			pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    37de:	e9 81       	ldd	r30, Y+1	; 0x01
    37e0:	fa 81       	ldd	r31, Y+2	; 0x02
    37e2:	8b 81       	ldd	r24, Y+3	; 0x03
    37e4:	9c 81       	ldd	r25, Y+4	; 0x04
    37e6:	97 83       	std	Z+7, r25	; 0x07
    37e8:	86 83       	std	Z+6, r24	; 0x06

			xReturn = pdPASS;
    37ea:	81 e0       	ldi	r24, 0x01	; 1
    37ec:	8e 83       	std	Y+6, r24	; 0x06
    37ee:	01 c0       	rjmp	.+2      	; 0x37f2 <xQueuePeekFromISR+0x5e>
		}
		else
		{
			xReturn = pdFAIL;
    37f0:	1e 82       	std	Y+6, r1	; 0x06
			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    37f2:	8e 81       	ldd	r24, Y+6	; 0x06
}
    37f4:	2a 96       	adiw	r28, 0x0a	; 10
    37f6:	0f b6       	in	r0, 0x3f	; 63
    37f8:	f8 94       	cli
    37fa:	de bf       	out	0x3e, r29	; 62
    37fc:	0f be       	out	0x3f, r0	; 63
    37fe:	cd bf       	out	0x3d, r28	; 61
    3800:	cf 91       	pop	r28
    3802:	df 91       	pop	r29
    3804:	08 95       	ret

00003806 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
    3806:	df 93       	push	r29
    3808:	cf 93       	push	r28
    380a:	00 d0       	rcall	.+0      	; 0x380c <uxQueueMessagesWaiting+0x6>
    380c:	0f 92       	push	r0
    380e:	cd b7       	in	r28, 0x3d	; 61
    3810:	de b7       	in	r29, 0x3e	; 62
    3812:	9b 83       	std	Y+3, r25	; 0x03
    3814:	8a 83       	std	Y+2, r24	; 0x02
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    3816:	0f b6       	in	r0, 0x3f	; 63
    3818:	f8 94       	cli
    381a:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    381c:	ea 81       	ldd	r30, Y+2	; 0x02
    381e:	fb 81       	ldd	r31, Y+3	; 0x03
    3820:	82 8d       	ldd	r24, Z+26	; 0x1a
    3822:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    3824:	0f 90       	pop	r0
    3826:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    3828:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    382a:	0f 90       	pop	r0
    382c:	0f 90       	pop	r0
    382e:	0f 90       	pop	r0
    3830:	cf 91       	pop	r28
    3832:	df 91       	pop	r29
    3834:	08 95       	ret

00003836 <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    3836:	df 93       	push	r29
    3838:	cf 93       	push	r28
    383a:	00 d0       	rcall	.+0      	; 0x383c <uxQueueSpacesAvailable+0x6>
    383c:	00 d0       	rcall	.+0      	; 0x383e <uxQueueSpacesAvailable+0x8>
    383e:	0f 92       	push	r0
    3840:	cd b7       	in	r28, 0x3d	; 61
    3842:	de b7       	in	r29, 0x3e	; 62
    3844:	9d 83       	std	Y+5, r25	; 0x05
    3846:	8c 83       	std	Y+4, r24	; 0x04
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;
    3848:	8c 81       	ldd	r24, Y+4	; 0x04
    384a:	9d 81       	ldd	r25, Y+5	; 0x05
    384c:	9a 83       	std	Y+2, r25	; 0x02
    384e:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    3850:	0f b6       	in	r0, 0x3f	; 63
    3852:	f8 94       	cli
    3854:	0f 92       	push	r0
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    3856:	e9 81       	ldd	r30, Y+1	; 0x01
    3858:	fa 81       	ldd	r31, Y+2	; 0x02
    385a:	93 8d       	ldd	r25, Z+27	; 0x1b
    385c:	e9 81       	ldd	r30, Y+1	; 0x01
    385e:	fa 81       	ldd	r31, Y+2	; 0x02
    3860:	82 8d       	ldd	r24, Z+26	; 0x1a
    3862:	29 2f       	mov	r18, r25
    3864:	28 1b       	sub	r18, r24
    3866:	82 2f       	mov	r24, r18
    3868:	8b 83       	std	Y+3, r24	; 0x03
	}
	taskEXIT_CRITICAL();
    386a:	0f 90       	pop	r0
    386c:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    386e:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    3870:	0f 90       	pop	r0
    3872:	0f 90       	pop	r0
    3874:	0f 90       	pop	r0
    3876:	0f 90       	pop	r0
    3878:	0f 90       	pop	r0
    387a:	cf 91       	pop	r28
    387c:	df 91       	pop	r29
    387e:	08 95       	ret

00003880 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
    3880:	df 93       	push	r29
    3882:	cf 93       	push	r28
    3884:	00 d0       	rcall	.+0      	; 0x3886 <uxQueueMessagesWaitingFromISR+0x6>
    3886:	00 d0       	rcall	.+0      	; 0x3888 <uxQueueMessagesWaitingFromISR+0x8>
    3888:	0f 92       	push	r0
    388a:	cd b7       	in	r28, 0x3d	; 61
    388c:	de b7       	in	r29, 0x3e	; 62
    388e:	9d 83       	std	Y+5, r25	; 0x05
    3890:	8c 83       	std	Y+4, r24	; 0x04
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;
    3892:	8c 81       	ldd	r24, Y+4	; 0x04
    3894:	9d 81       	ldd	r25, Y+5	; 0x05
    3896:	9a 83       	std	Y+2, r25	; 0x02
    3898:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );
	uxReturn = pxQueue->uxMessagesWaiting;
    389a:	e9 81       	ldd	r30, Y+1	; 0x01
    389c:	fa 81       	ldd	r31, Y+2	; 0x02
    389e:	82 8d       	ldd	r24, Z+26	; 0x1a
    38a0:	8b 83       	std	Y+3, r24	; 0x03

	return uxReturn;
    38a2:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    38a4:	0f 90       	pop	r0
    38a6:	0f 90       	pop	r0
    38a8:	0f 90       	pop	r0
    38aa:	0f 90       	pop	r0
    38ac:	0f 90       	pop	r0
    38ae:	cf 91       	pop	r28
    38b0:	df 91       	pop	r29
    38b2:	08 95       	ret

000038b4 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
    38b4:	df 93       	push	r29
    38b6:	cf 93       	push	r28
    38b8:	00 d0       	rcall	.+0      	; 0x38ba <vQueueDelete+0x6>
    38ba:	00 d0       	rcall	.+0      	; 0x38bc <vQueueDelete+0x8>
    38bc:	cd b7       	in	r28, 0x3d	; 61
    38be:	de b7       	in	r29, 0x3e	; 62
    38c0:	9c 83       	std	Y+4, r25	; 0x04
    38c2:	8b 83       	std	Y+3, r24	; 0x03
Queue_t * const pxQueue = xQueue;
    38c4:	8b 81       	ldd	r24, Y+3	; 0x03
    38c6:	9c 81       	ldd	r25, Y+4	; 0x04
    38c8:	9a 83       	std	Y+2, r25	; 0x02
    38ca:	89 83       	std	Y+1, r24	; 0x01

	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
	{
		/* The queue can only have been allocated dynamically - free it
		again. */
		vPortFree( pxQueue );
    38cc:	89 81       	ldd	r24, Y+1	; 0x01
    38ce:	9a 81       	ldd	r25, Y+2	; 0x02
    38d0:	0e 94 89 0d 	call	0x1b12	; 0x1b12 <vPortFree>
		/* The queue must have been statically allocated, so is not going to be
		deleted.  Avoid compiler warnings about the unused parameter. */
		( void ) pxQueue;
	}
	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
    38d4:	0f 90       	pop	r0
    38d6:	0f 90       	pop	r0
    38d8:	0f 90       	pop	r0
    38da:	0f 90       	pop	r0
    38dc:	cf 91       	pop	r28
    38de:	df 91       	pop	r29
    38e0:	08 95       	ret

000038e2 <prvCopyDataToQueue>:

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    38e2:	df 93       	push	r29
    38e4:	cf 93       	push	r28
    38e6:	cd b7       	in	r28, 0x3d	; 61
    38e8:	de b7       	in	r29, 0x3e	; 62
    38ea:	27 97       	sbiw	r28, 0x07	; 7
    38ec:	0f b6       	in	r0, 0x3f	; 63
    38ee:	f8 94       	cli
    38f0:	de bf       	out	0x3e, r29	; 62
    38f2:	0f be       	out	0x3f, r0	; 63
    38f4:	cd bf       	out	0x3d, r28	; 61
    38f6:	9c 83       	std	Y+4, r25	; 0x04
    38f8:	8b 83       	std	Y+3, r24	; 0x03
    38fa:	7e 83       	std	Y+6, r23	; 0x06
    38fc:	6d 83       	std	Y+5, r22	; 0x05
    38fe:	4f 83       	std	Y+7, r20	; 0x07
BaseType_t xReturn = pdFALSE;
    3900:	1a 82       	std	Y+2, r1	; 0x02
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    3902:	eb 81       	ldd	r30, Y+3	; 0x03
    3904:	fc 81       	ldd	r31, Y+4	; 0x04
    3906:	82 8d       	ldd	r24, Z+26	; 0x1a
    3908:	89 83       	std	Y+1, r24	; 0x01

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    390a:	eb 81       	ldd	r30, Y+3	; 0x03
    390c:	fc 81       	ldd	r31, Y+4	; 0x04
    390e:	84 8d       	ldd	r24, Z+28	; 0x1c
    3910:	88 23       	and	r24, r24
    3912:	09 f4       	brne	.+2      	; 0x3916 <prvCopyDataToQueue+0x34>
    3914:	7d c0       	rjmp	.+250    	; 0x3a10 <prvCopyDataToQueue+0x12e>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    3916:	8f 81       	ldd	r24, Y+7	; 0x07
    3918:	88 23       	and	r24, r24
    391a:	99 f5       	brne	.+102    	; 0x3982 <prvCopyDataToQueue+0xa0>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    391c:	eb 81       	ldd	r30, Y+3	; 0x03
    391e:	fc 81       	ldd	r31, Y+4	; 0x04
    3920:	62 81       	ldd	r22, Z+2	; 0x02
    3922:	73 81       	ldd	r23, Z+3	; 0x03
    3924:	eb 81       	ldd	r30, Y+3	; 0x03
    3926:	fc 81       	ldd	r31, Y+4	; 0x04
    3928:	84 8d       	ldd	r24, Z+28	; 0x1c
    392a:	48 2f       	mov	r20, r24
    392c:	50 e0       	ldi	r21, 0x00	; 0
    392e:	2d 81       	ldd	r18, Y+5	; 0x05
    3930:	3e 81       	ldd	r19, Y+6	; 0x06
    3932:	cb 01       	movw	r24, r22
    3934:	b9 01       	movw	r22, r18
    3936:	0e 94 13 33 	call	0x6626	; 0x6626 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    393a:	eb 81       	ldd	r30, Y+3	; 0x03
    393c:	fc 81       	ldd	r31, Y+4	; 0x04
    393e:	22 81       	ldd	r18, Z+2	; 0x02
    3940:	33 81       	ldd	r19, Z+3	; 0x03
    3942:	eb 81       	ldd	r30, Y+3	; 0x03
    3944:	fc 81       	ldd	r31, Y+4	; 0x04
    3946:	84 8d       	ldd	r24, Z+28	; 0x1c
    3948:	88 2f       	mov	r24, r24
    394a:	90 e0       	ldi	r25, 0x00	; 0
    394c:	82 0f       	add	r24, r18
    394e:	93 1f       	adc	r25, r19
    3950:	eb 81       	ldd	r30, Y+3	; 0x03
    3952:	fc 81       	ldd	r31, Y+4	; 0x04
    3954:	93 83       	std	Z+3, r25	; 0x03
    3956:	82 83       	std	Z+2, r24	; 0x02
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    3958:	eb 81       	ldd	r30, Y+3	; 0x03
    395a:	fc 81       	ldd	r31, Y+4	; 0x04
    395c:	22 81       	ldd	r18, Z+2	; 0x02
    395e:	33 81       	ldd	r19, Z+3	; 0x03
    3960:	eb 81       	ldd	r30, Y+3	; 0x03
    3962:	fc 81       	ldd	r31, Y+4	; 0x04
    3964:	84 81       	ldd	r24, Z+4	; 0x04
    3966:	95 81       	ldd	r25, Z+5	; 0x05
    3968:	28 17       	cp	r18, r24
    396a:	39 07       	cpc	r19, r25
    396c:	08 f4       	brcc	.+2      	; 0x3970 <prvCopyDataToQueue+0x8e>
    396e:	50 c0       	rjmp	.+160    	; 0x3a10 <prvCopyDataToQueue+0x12e>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    3970:	eb 81       	ldd	r30, Y+3	; 0x03
    3972:	fc 81       	ldd	r31, Y+4	; 0x04
    3974:	80 81       	ld	r24, Z
    3976:	91 81       	ldd	r25, Z+1	; 0x01
    3978:	eb 81       	ldd	r30, Y+3	; 0x03
    397a:	fc 81       	ldd	r31, Y+4	; 0x04
    397c:	93 83       	std	Z+3, r25	; 0x03
    397e:	82 83       	std	Z+2, r24	; 0x02
    3980:	47 c0       	rjmp	.+142    	; 0x3a10 <prvCopyDataToQueue+0x12e>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
    3982:	eb 81       	ldd	r30, Y+3	; 0x03
    3984:	fc 81       	ldd	r31, Y+4	; 0x04
    3986:	66 81       	ldd	r22, Z+6	; 0x06
    3988:	77 81       	ldd	r23, Z+7	; 0x07
    398a:	eb 81       	ldd	r30, Y+3	; 0x03
    398c:	fc 81       	ldd	r31, Y+4	; 0x04
    398e:	84 8d       	ldd	r24, Z+28	; 0x1c
    3990:	48 2f       	mov	r20, r24
    3992:	50 e0       	ldi	r21, 0x00	; 0
    3994:	2d 81       	ldd	r18, Y+5	; 0x05
    3996:	3e 81       	ldd	r19, Y+6	; 0x06
    3998:	cb 01       	movw	r24, r22
    399a:	b9 01       	movw	r22, r18
    399c:	0e 94 13 33 	call	0x6626	; 0x6626 <memcpy>
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
    39a0:	eb 81       	ldd	r30, Y+3	; 0x03
    39a2:	fc 81       	ldd	r31, Y+4	; 0x04
    39a4:	26 81       	ldd	r18, Z+6	; 0x06
    39a6:	37 81       	ldd	r19, Z+7	; 0x07
    39a8:	eb 81       	ldd	r30, Y+3	; 0x03
    39aa:	fc 81       	ldd	r31, Y+4	; 0x04
    39ac:	84 8d       	ldd	r24, Z+28	; 0x1c
    39ae:	88 2f       	mov	r24, r24
    39b0:	90 e0       	ldi	r25, 0x00	; 0
    39b2:	90 95       	com	r25
    39b4:	81 95       	neg	r24
    39b6:	9f 4f       	sbci	r25, 0xFF	; 255
    39b8:	82 0f       	add	r24, r18
    39ba:	93 1f       	adc	r25, r19
    39bc:	eb 81       	ldd	r30, Y+3	; 0x03
    39be:	fc 81       	ldd	r31, Y+4	; 0x04
    39c0:	97 83       	std	Z+7, r25	; 0x07
    39c2:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    39c4:	eb 81       	ldd	r30, Y+3	; 0x03
    39c6:	fc 81       	ldd	r31, Y+4	; 0x04
    39c8:	26 81       	ldd	r18, Z+6	; 0x06
    39ca:	37 81       	ldd	r19, Z+7	; 0x07
    39cc:	eb 81       	ldd	r30, Y+3	; 0x03
    39ce:	fc 81       	ldd	r31, Y+4	; 0x04
    39d0:	80 81       	ld	r24, Z
    39d2:	91 81       	ldd	r25, Z+1	; 0x01
    39d4:	28 17       	cp	r18, r24
    39d6:	39 07       	cpc	r19, r25
    39d8:	90 f4       	brcc	.+36     	; 0x39fe <prvCopyDataToQueue+0x11c>
		{
			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
    39da:	eb 81       	ldd	r30, Y+3	; 0x03
    39dc:	fc 81       	ldd	r31, Y+4	; 0x04
    39de:	24 81       	ldd	r18, Z+4	; 0x04
    39e0:	35 81       	ldd	r19, Z+5	; 0x05
    39e2:	eb 81       	ldd	r30, Y+3	; 0x03
    39e4:	fc 81       	ldd	r31, Y+4	; 0x04
    39e6:	84 8d       	ldd	r24, Z+28	; 0x1c
    39e8:	88 2f       	mov	r24, r24
    39ea:	90 e0       	ldi	r25, 0x00	; 0
    39ec:	90 95       	com	r25
    39ee:	81 95       	neg	r24
    39f0:	9f 4f       	sbci	r25, 0xFF	; 255
    39f2:	82 0f       	add	r24, r18
    39f4:	93 1f       	adc	r25, r19
    39f6:	eb 81       	ldd	r30, Y+3	; 0x03
    39f8:	fc 81       	ldd	r31, Y+4	; 0x04
    39fa:	97 83       	std	Z+7, r25	; 0x07
    39fc:	86 83       	std	Z+6, r24	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    39fe:	8f 81       	ldd	r24, Y+7	; 0x07
    3a00:	82 30       	cpi	r24, 0x02	; 2
    3a02:	31 f4       	brne	.+12     	; 0x3a10 <prvCopyDataToQueue+0x12e>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    3a04:	89 81       	ldd	r24, Y+1	; 0x01
    3a06:	88 23       	and	r24, r24
    3a08:	19 f0       	breq	.+6      	; 0x3a10 <prvCopyDataToQueue+0x12e>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
    3a0a:	89 81       	ldd	r24, Y+1	; 0x01
    3a0c:	81 50       	subi	r24, 0x01	; 1
    3a0e:	89 83       	std	Y+1, r24	; 0x01
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    3a10:	89 81       	ldd	r24, Y+1	; 0x01
    3a12:	8f 5f       	subi	r24, 0xFF	; 255
    3a14:	eb 81       	ldd	r30, Y+3	; 0x03
    3a16:	fc 81       	ldd	r31, Y+4	; 0x04
    3a18:	82 8f       	std	Z+26, r24	; 0x1a

	return xReturn;
    3a1a:	8a 81       	ldd	r24, Y+2	; 0x02
}
    3a1c:	27 96       	adiw	r28, 0x07	; 7
    3a1e:	0f b6       	in	r0, 0x3f	; 63
    3a20:	f8 94       	cli
    3a22:	de bf       	out	0x3e, r29	; 62
    3a24:	0f be       	out	0x3f, r0	; 63
    3a26:	cd bf       	out	0x3d, r28	; 61
    3a28:	cf 91       	pop	r28
    3a2a:	df 91       	pop	r29
    3a2c:	08 95       	ret

00003a2e <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    3a2e:	df 93       	push	r29
    3a30:	cf 93       	push	r28
    3a32:	00 d0       	rcall	.+0      	; 0x3a34 <prvCopyDataFromQueue+0x6>
    3a34:	00 d0       	rcall	.+0      	; 0x3a36 <prvCopyDataFromQueue+0x8>
    3a36:	cd b7       	in	r28, 0x3d	; 61
    3a38:	de b7       	in	r29, 0x3e	; 62
    3a3a:	9a 83       	std	Y+2, r25	; 0x02
    3a3c:	89 83       	std	Y+1, r24	; 0x01
    3a3e:	7c 83       	std	Y+4, r23	; 0x04
    3a40:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    3a42:	e9 81       	ldd	r30, Y+1	; 0x01
    3a44:	fa 81       	ldd	r31, Y+2	; 0x02
    3a46:	84 8d       	ldd	r24, Z+28	; 0x1c
    3a48:	88 23       	and	r24, r24
    3a4a:	89 f1       	breq	.+98     	; 0x3aae <prvCopyDataFromQueue+0x80>
	{
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    3a4c:	e9 81       	ldd	r30, Y+1	; 0x01
    3a4e:	fa 81       	ldd	r31, Y+2	; 0x02
    3a50:	26 81       	ldd	r18, Z+6	; 0x06
    3a52:	37 81       	ldd	r19, Z+7	; 0x07
    3a54:	e9 81       	ldd	r30, Y+1	; 0x01
    3a56:	fa 81       	ldd	r31, Y+2	; 0x02
    3a58:	84 8d       	ldd	r24, Z+28	; 0x1c
    3a5a:	88 2f       	mov	r24, r24
    3a5c:	90 e0       	ldi	r25, 0x00	; 0
    3a5e:	82 0f       	add	r24, r18
    3a60:	93 1f       	adc	r25, r19
    3a62:	e9 81       	ldd	r30, Y+1	; 0x01
    3a64:	fa 81       	ldd	r31, Y+2	; 0x02
    3a66:	97 83       	std	Z+7, r25	; 0x07
    3a68:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    3a6a:	e9 81       	ldd	r30, Y+1	; 0x01
    3a6c:	fa 81       	ldd	r31, Y+2	; 0x02
    3a6e:	26 81       	ldd	r18, Z+6	; 0x06
    3a70:	37 81       	ldd	r19, Z+7	; 0x07
    3a72:	e9 81       	ldd	r30, Y+1	; 0x01
    3a74:	fa 81       	ldd	r31, Y+2	; 0x02
    3a76:	84 81       	ldd	r24, Z+4	; 0x04
    3a78:	95 81       	ldd	r25, Z+5	; 0x05
    3a7a:	28 17       	cp	r18, r24
    3a7c:	39 07       	cpc	r19, r25
    3a7e:	40 f0       	brcs	.+16     	; 0x3a90 <prvCopyDataFromQueue+0x62>
		{
			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    3a80:	e9 81       	ldd	r30, Y+1	; 0x01
    3a82:	fa 81       	ldd	r31, Y+2	; 0x02
    3a84:	80 81       	ld	r24, Z
    3a86:	91 81       	ldd	r25, Z+1	; 0x01
    3a88:	e9 81       	ldd	r30, Y+1	; 0x01
    3a8a:	fa 81       	ldd	r31, Y+2	; 0x02
    3a8c:	97 83       	std	Z+7, r25	; 0x07
    3a8e:	86 83       	std	Z+6, r24	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    3a90:	e9 81       	ldd	r30, Y+1	; 0x01
    3a92:	fa 81       	ldd	r31, Y+2	; 0x02
    3a94:	46 81       	ldd	r20, Z+6	; 0x06
    3a96:	57 81       	ldd	r21, Z+7	; 0x07
    3a98:	e9 81       	ldd	r30, Y+1	; 0x01
    3a9a:	fa 81       	ldd	r31, Y+2	; 0x02
    3a9c:	84 8d       	ldd	r24, Z+28	; 0x1c
    3a9e:	28 2f       	mov	r18, r24
    3aa0:	30 e0       	ldi	r19, 0x00	; 0
    3aa2:	8b 81       	ldd	r24, Y+3	; 0x03
    3aa4:	9c 81       	ldd	r25, Y+4	; 0x04
    3aa6:	ba 01       	movw	r22, r20
    3aa8:	a9 01       	movw	r20, r18
    3aaa:	0e 94 13 33 	call	0x6626	; 0x6626 <memcpy>
	}
}
    3aae:	0f 90       	pop	r0
    3ab0:	0f 90       	pop	r0
    3ab2:	0f 90       	pop	r0
    3ab4:	0f 90       	pop	r0
    3ab6:	cf 91       	pop	r28
    3ab8:	df 91       	pop	r29
    3aba:	08 95       	ret

00003abc <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    3abc:	df 93       	push	r29
    3abe:	cf 93       	push	r28
    3ac0:	00 d0       	rcall	.+0      	; 0x3ac2 <prvUnlockQueue+0x6>
    3ac2:	00 d0       	rcall	.+0      	; 0x3ac4 <prvUnlockQueue+0x8>
    3ac4:	cd b7       	in	r28, 0x3d	; 61
    3ac6:	de b7       	in	r29, 0x3e	; 62
    3ac8:	9c 83       	std	Y+4, r25	; 0x04
    3aca:	8b 83       	std	Y+3, r24	; 0x03

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    3acc:	0f b6       	in	r0, 0x3f	; 63
    3ace:	f8 94       	cli
    3ad0:	0f 92       	push	r0
	{
		int8_t cTxLock = pxQueue->cTxLock;
    3ad2:	eb 81       	ldd	r30, Y+3	; 0x03
    3ad4:	fc 81       	ldd	r31, Y+4	; 0x04
    3ad6:	86 8d       	ldd	r24, Z+30	; 0x1e
    3ad8:	8a 83       	std	Y+2, r24	; 0x02
    3ada:	11 c0       	rjmp	.+34     	; 0x3afe <prvUnlockQueue+0x42>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3adc:	eb 81       	ldd	r30, Y+3	; 0x03
    3ade:	fc 81       	ldd	r31, Y+4	; 0x04
    3ae0:	81 89       	ldd	r24, Z+17	; 0x11
    3ae2:	88 23       	and	r24, r24
    3ae4:	79 f0       	breq	.+30     	; 0x3b04 <prvUnlockQueue+0x48>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3ae6:	8b 81       	ldd	r24, Y+3	; 0x03
    3ae8:	9c 81       	ldd	r25, Y+4	; 0x04
    3aea:	41 96       	adiw	r24, 0x11	; 17
    3aec:	0e 94 4e 2c 	call	0x589c	; 0x589c <xTaskRemoveFromEventList>
    3af0:	88 23       	and	r24, r24
    3af2:	11 f0       	breq	.+4      	; 0x3af8 <prvUnlockQueue+0x3c>
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
    3af4:	0e 94 ba 2d 	call	0x5b74	; 0x5b74 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
    3af8:	8a 81       	ldd	r24, Y+2	; 0x02
    3afa:	81 50       	subi	r24, 0x01	; 1
    3afc:	8a 83       	std	Y+2, r24	; 0x02
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
    3afe:	8a 81       	ldd	r24, Y+2	; 0x02
    3b00:	18 16       	cp	r1, r24
    3b02:	64 f3       	brlt	.-40     	; 0x3adc <prvUnlockQueue+0x20>
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
    3b04:	eb 81       	ldd	r30, Y+3	; 0x03
    3b06:	fc 81       	ldd	r31, Y+4	; 0x04
    3b08:	8f ef       	ldi	r24, 0xFF	; 255
    3b0a:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    3b0c:	0f 90       	pop	r0
    3b0e:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    3b10:	0f b6       	in	r0, 0x3f	; 63
    3b12:	f8 94       	cli
    3b14:	0f 92       	push	r0
	{
		int8_t cRxLock = pxQueue->cRxLock;
    3b16:	eb 81       	ldd	r30, Y+3	; 0x03
    3b18:	fc 81       	ldd	r31, Y+4	; 0x04
    3b1a:	85 8d       	ldd	r24, Z+29	; 0x1d
    3b1c:	89 83       	std	Y+1, r24	; 0x01
    3b1e:	11 c0       	rjmp	.+34     	; 0x3b42 <prvUnlockQueue+0x86>

		while( cRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3b20:	eb 81       	ldd	r30, Y+3	; 0x03
    3b22:	fc 81       	ldd	r31, Y+4	; 0x04
    3b24:	80 85       	ldd	r24, Z+8	; 0x08
    3b26:	88 23       	and	r24, r24
    3b28:	79 f0       	breq	.+30     	; 0x3b48 <prvUnlockQueue+0x8c>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    3b2a:	8b 81       	ldd	r24, Y+3	; 0x03
    3b2c:	9c 81       	ldd	r25, Y+4	; 0x04
    3b2e:	08 96       	adiw	r24, 0x08	; 8
    3b30:	0e 94 4e 2c 	call	0x589c	; 0x589c <xTaskRemoveFromEventList>
    3b34:	88 23       	and	r24, r24
    3b36:	11 f0       	breq	.+4      	; 0x3b3c <prvUnlockQueue+0x80>
				{
					vTaskMissedYield();
    3b38:	0e 94 ba 2d 	call	0x5b74	; 0x5b74 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--cRxLock;
    3b3c:	89 81       	ldd	r24, Y+1	; 0x01
    3b3e:	81 50       	subi	r24, 0x01	; 1
    3b40:	89 83       	std	Y+1, r24	; 0x01
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
    3b42:	89 81       	ldd	r24, Y+1	; 0x01
    3b44:	18 16       	cp	r1, r24
    3b46:	64 f3       	brlt	.-40     	; 0x3b20 <prvUnlockQueue+0x64>
			{
				break;
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
    3b48:	eb 81       	ldd	r30, Y+3	; 0x03
    3b4a:	fc 81       	ldd	r31, Y+4	; 0x04
    3b4c:	8f ef       	ldi	r24, 0xFF	; 255
    3b4e:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    3b50:	0f 90       	pop	r0
    3b52:	0f be       	out	0x3f, r0	; 63
}
    3b54:	0f 90       	pop	r0
    3b56:	0f 90       	pop	r0
    3b58:	0f 90       	pop	r0
    3b5a:	0f 90       	pop	r0
    3b5c:	cf 91       	pop	r28
    3b5e:	df 91       	pop	r29
    3b60:	08 95       	ret

00003b62 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
    3b62:	df 93       	push	r29
    3b64:	cf 93       	push	r28
    3b66:	00 d0       	rcall	.+0      	; 0x3b68 <prvIsQueueEmpty+0x6>
    3b68:	0f 92       	push	r0
    3b6a:	cd b7       	in	r28, 0x3d	; 61
    3b6c:	de b7       	in	r29, 0x3e	; 62
    3b6e:	9b 83       	std	Y+3, r25	; 0x03
    3b70:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    3b72:	0f b6       	in	r0, 0x3f	; 63
    3b74:	f8 94       	cli
    3b76:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    3b78:	ea 81       	ldd	r30, Y+2	; 0x02
    3b7a:	fb 81       	ldd	r31, Y+3	; 0x03
    3b7c:	82 8d       	ldd	r24, Z+26	; 0x1a
    3b7e:	88 23       	and	r24, r24
    3b80:	19 f4       	brne	.+6      	; 0x3b88 <prvIsQueueEmpty+0x26>
		{
			xReturn = pdTRUE;
    3b82:	81 e0       	ldi	r24, 0x01	; 1
    3b84:	89 83       	std	Y+1, r24	; 0x01
    3b86:	01 c0       	rjmp	.+2      	; 0x3b8a <prvIsQueueEmpty+0x28>
		}
		else
		{
			xReturn = pdFALSE;
    3b88:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    3b8a:	0f 90       	pop	r0
    3b8c:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    3b8e:	89 81       	ldd	r24, Y+1	; 0x01
}
    3b90:	0f 90       	pop	r0
    3b92:	0f 90       	pop	r0
    3b94:	0f 90       	pop	r0
    3b96:	cf 91       	pop	r28
    3b98:	df 91       	pop	r29
    3b9a:	08 95       	ret

00003b9c <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
    3b9c:	df 93       	push	r29
    3b9e:	cf 93       	push	r28
    3ba0:	00 d0       	rcall	.+0      	; 0x3ba2 <xQueueIsQueueEmptyFromISR+0x6>
    3ba2:	00 d0       	rcall	.+0      	; 0x3ba4 <xQueueIsQueueEmptyFromISR+0x8>
    3ba4:	0f 92       	push	r0
    3ba6:	cd b7       	in	r28, 0x3d	; 61
    3ba8:	de b7       	in	r29, 0x3e	; 62
    3baa:	9d 83       	std	Y+5, r25	; 0x05
    3bac:	8c 83       	std	Y+4, r24	; 0x04
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;
    3bae:	8c 81       	ldd	r24, Y+4	; 0x04
    3bb0:	9d 81       	ldd	r25, Y+5	; 0x05
    3bb2:	9a 83       	std	Y+2, r25	; 0x02
    3bb4:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    3bb6:	e9 81       	ldd	r30, Y+1	; 0x01
    3bb8:	fa 81       	ldd	r31, Y+2	; 0x02
    3bba:	82 8d       	ldd	r24, Z+26	; 0x1a
    3bbc:	88 23       	and	r24, r24
    3bbe:	19 f4       	brne	.+6      	; 0x3bc6 <xQueueIsQueueEmptyFromISR+0x2a>
	{
		xReturn = pdTRUE;
    3bc0:	81 e0       	ldi	r24, 0x01	; 1
    3bc2:	8b 83       	std	Y+3, r24	; 0x03
    3bc4:	01 c0       	rjmp	.+2      	; 0x3bc8 <xQueueIsQueueEmptyFromISR+0x2c>
	}
	else
	{
		xReturn = pdFALSE;
    3bc6:	1b 82       	std	Y+3, r1	; 0x03
	}

	return xReturn;
    3bc8:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    3bca:	0f 90       	pop	r0
    3bcc:	0f 90       	pop	r0
    3bce:	0f 90       	pop	r0
    3bd0:	0f 90       	pop	r0
    3bd2:	0f 90       	pop	r0
    3bd4:	cf 91       	pop	r28
    3bd6:	df 91       	pop	r29
    3bd8:	08 95       	ret

00003bda <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
    3bda:	df 93       	push	r29
    3bdc:	cf 93       	push	r28
    3bde:	00 d0       	rcall	.+0      	; 0x3be0 <prvIsQueueFull+0x6>
    3be0:	0f 92       	push	r0
    3be2:	cd b7       	in	r28, 0x3d	; 61
    3be4:	de b7       	in	r29, 0x3e	; 62
    3be6:	9b 83       	std	Y+3, r25	; 0x03
    3be8:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    3bea:	0f b6       	in	r0, 0x3f	; 63
    3bec:	f8 94       	cli
    3bee:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    3bf0:	ea 81       	ldd	r30, Y+2	; 0x02
    3bf2:	fb 81       	ldd	r31, Y+3	; 0x03
    3bf4:	92 8d       	ldd	r25, Z+26	; 0x1a
    3bf6:	ea 81       	ldd	r30, Y+2	; 0x02
    3bf8:	fb 81       	ldd	r31, Y+3	; 0x03
    3bfa:	83 8d       	ldd	r24, Z+27	; 0x1b
    3bfc:	98 17       	cp	r25, r24
    3bfe:	19 f4       	brne	.+6      	; 0x3c06 <prvIsQueueFull+0x2c>
		{
			xReturn = pdTRUE;
    3c00:	81 e0       	ldi	r24, 0x01	; 1
    3c02:	89 83       	std	Y+1, r24	; 0x01
    3c04:	01 c0       	rjmp	.+2      	; 0x3c08 <prvIsQueueFull+0x2e>
		}
		else
		{
			xReturn = pdFALSE;
    3c06:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    3c08:	0f 90       	pop	r0
    3c0a:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    3c0c:	89 81       	ldd	r24, Y+1	; 0x01
}
    3c0e:	0f 90       	pop	r0
    3c10:	0f 90       	pop	r0
    3c12:	0f 90       	pop	r0
    3c14:	cf 91       	pop	r28
    3c16:	df 91       	pop	r29
    3c18:	08 95       	ret

00003c1a <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    3c1a:	df 93       	push	r29
    3c1c:	cf 93       	push	r28
    3c1e:	00 d0       	rcall	.+0      	; 0x3c20 <xQueueIsQueueFullFromISR+0x6>
    3c20:	00 d0       	rcall	.+0      	; 0x3c22 <xQueueIsQueueFullFromISR+0x8>
    3c22:	0f 92       	push	r0
    3c24:	cd b7       	in	r28, 0x3d	; 61
    3c26:	de b7       	in	r29, 0x3e	; 62
    3c28:	9d 83       	std	Y+5, r25	; 0x05
    3c2a:	8c 83       	std	Y+4, r24	; 0x04
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;
    3c2c:	8c 81       	ldd	r24, Y+4	; 0x04
    3c2e:	9d 81       	ldd	r25, Y+5	; 0x05
    3c30:	9a 83       	std	Y+2, r25	; 0x02
    3c32:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    3c34:	e9 81       	ldd	r30, Y+1	; 0x01
    3c36:	fa 81       	ldd	r31, Y+2	; 0x02
    3c38:	92 8d       	ldd	r25, Z+26	; 0x1a
    3c3a:	e9 81       	ldd	r30, Y+1	; 0x01
    3c3c:	fa 81       	ldd	r31, Y+2	; 0x02
    3c3e:	83 8d       	ldd	r24, Z+27	; 0x1b
    3c40:	98 17       	cp	r25, r24
    3c42:	19 f4       	brne	.+6      	; 0x3c4a <xQueueIsQueueFullFromISR+0x30>
	{
		xReturn = pdTRUE;
    3c44:	81 e0       	ldi	r24, 0x01	; 1
    3c46:	8b 83       	std	Y+3, r24	; 0x03
    3c48:	01 c0       	rjmp	.+2      	; 0x3c4c <xQueueIsQueueFullFromISR+0x32>
	}
	else
	{
		xReturn = pdFALSE;
    3c4a:	1b 82       	std	Y+3, r1	; 0x03
	}

	return xReturn;
    3c4c:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    3c4e:	0f 90       	pop	r0
    3c50:	0f 90       	pop	r0
    3c52:	0f 90       	pop	r0
    3c54:	0f 90       	pop	r0
    3c56:	0f 90       	pop	r0
    3c58:	cf 91       	pop	r28
    3c5a:	df 91       	pop	r29
    3c5c:	08 95       	ret

00003c5e <xStreamBufferGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	StreamBufferHandle_t xStreamBufferGenericCreate( size_t xBufferSizeBytes, size_t xTriggerLevelBytes, BaseType_t xIsMessageBuffer )
	{
    3c5e:	0f 93       	push	r16
    3c60:	df 93       	push	r29
    3c62:	cf 93       	push	r28
    3c64:	cd b7       	in	r28, 0x3d	; 61
    3c66:	de b7       	in	r29, 0x3e	; 62
    3c68:	28 97       	sbiw	r28, 0x08	; 8
    3c6a:	0f b6       	in	r0, 0x3f	; 63
    3c6c:	f8 94       	cli
    3c6e:	de bf       	out	0x3e, r29	; 62
    3c70:	0f be       	out	0x3f, r0	; 63
    3c72:	cd bf       	out	0x3d, r28	; 61
    3c74:	9d 83       	std	Y+5, r25	; 0x05
    3c76:	8c 83       	std	Y+4, r24	; 0x04
    3c78:	7f 83       	std	Y+7, r23	; 0x07
    3c7a:	6e 83       	std	Y+6, r22	; 0x06
    3c7c:	48 87       	std	Y+8, r20	; 0x08

		/* In case the stream buffer is going to be used as a message buffer
		(that is, it will hold discrete messages with a little meta data that
		says how big the next message is) check the buffer will be large enough
		to hold at least one message. */
		if( xIsMessageBuffer == pdTRUE )
    3c7e:	88 85       	ldd	r24, Y+8	; 0x08
    3c80:	81 30       	cpi	r24, 0x01	; 1
    3c82:	19 f4       	brne	.+6      	; 0x3c8a <xStreamBufferGenericCreate+0x2c>
		{
			/* Is a message buffer but not statically allocated. */
			ucFlags = sbFLAGS_IS_MESSAGE_BUFFER;
    3c84:	81 e0       	ldi	r24, 0x01	; 1
    3c86:	89 83       	std	Y+1, r24	; 0x01
    3c88:	01 c0       	rjmp	.+2      	; 0x3c8c <xStreamBufferGenericCreate+0x2e>
			configASSERT( xBufferSizeBytes > sbBYTES_TO_STORE_MESSAGE_LENGTH );
		}
		else
		{
			/* Not a message buffer and not statically allocated. */
			ucFlags = 0;
    3c8a:	19 82       	std	Y+1, r1	; 0x01
		}
		configASSERT( xTriggerLevelBytes <= xBufferSizeBytes );

		/* A trigger level of 0 would cause a waiting task to unblock even when
		the buffer was empty. */
		if( xTriggerLevelBytes == ( size_t ) 0 )
    3c8c:	8e 81       	ldd	r24, Y+6	; 0x06
    3c8e:	9f 81       	ldd	r25, Y+7	; 0x07
    3c90:	00 97       	sbiw	r24, 0x00	; 0
    3c92:	21 f4       	brne	.+8      	; 0x3c9c <xStreamBufferGenericCreate+0x3e>
		{
			xTriggerLevelBytes = ( size_t ) 1;
    3c94:	81 e0       	ldi	r24, 0x01	; 1
    3c96:	90 e0       	ldi	r25, 0x00	; 0
    3c98:	9f 83       	std	Y+7, r25	; 0x07
    3c9a:	8e 83       	std	Y+6, r24	; 0x06
		and the buffer follows immediately after.  The requested size is
		incremented so the free space is returned as the user would expect -
		this is a quirk of the implementation that means otherwise the free
		space would be reported as one byte smaller than would be logically
		expected. */
		xBufferSizeBytes++;
    3c9c:	8c 81       	ldd	r24, Y+4	; 0x04
    3c9e:	9d 81       	ldd	r25, Y+5	; 0x05
    3ca0:	01 96       	adiw	r24, 0x01	; 1
    3ca2:	9d 83       	std	Y+5, r25	; 0x05
    3ca4:	8c 83       	std	Y+4, r24	; 0x04
		pucAllocatedMemory = ( uint8_t * ) pvPortMalloc( xBufferSizeBytes + sizeof( StreamBuffer_t ) ); /*lint !e9079 malloc() only returns void*. */
    3ca6:	8c 81       	ldd	r24, Y+4	; 0x04
    3ca8:	9d 81       	ldd	r25, Y+5	; 0x05
    3caa:	0f 96       	adiw	r24, 0x0f	; 15
    3cac:	0e 94 33 0d 	call	0x1a66	; 0x1a66 <pvPortMalloc>
    3cb0:	9b 83       	std	Y+3, r25	; 0x03
    3cb2:	8a 83       	std	Y+2, r24	; 0x02

		if( pucAllocatedMemory != NULL )
    3cb4:	8a 81       	ldd	r24, Y+2	; 0x02
    3cb6:	9b 81       	ldd	r25, Y+3	; 0x03
    3cb8:	00 97       	sbiw	r24, 0x00	; 0
    3cba:	89 f0       	breq	.+34     	; 0x3cde <xStreamBufferGenericCreate+0x80>
		{
			prvInitialiseNewStreamBuffer( ( StreamBuffer_t * ) pucAllocatedMemory, /* Structure at the start of the allocated memory. */ /*lint !e9087 Safe cast as allocated memory is aligned. */ /*lint !e826 Area is not too small and alignment is guaranteed provided malloc() behaves as expected and returns aligned buffer. */
    3cbc:	6a 81       	ldd	r22, Y+2	; 0x02
    3cbe:	7b 81       	ldd	r23, Y+3	; 0x03
    3cc0:	8a 81       	ldd	r24, Y+2	; 0x02
    3cc2:	9b 81       	ldd	r25, Y+3	; 0x03
    3cc4:	9c 01       	movw	r18, r24
    3cc6:	21 5f       	subi	r18, 0xF1	; 241
    3cc8:	3f 4f       	sbci	r19, 0xFF	; 255
    3cca:	4c 81       	ldd	r20, Y+4	; 0x04
    3ccc:	5d 81       	ldd	r21, Y+5	; 0x05
    3cce:	ee 81       	ldd	r30, Y+6	; 0x06
    3cd0:	ff 81       	ldd	r31, Y+7	; 0x07
    3cd2:	cb 01       	movw	r24, r22
    3cd4:	b9 01       	movw	r22, r18
    3cd6:	9f 01       	movw	r18, r30
    3cd8:	09 81       	ldd	r16, Y+1	; 0x01
    3cda:	0e 94 87 25 	call	0x4b0e	; 0x4b0e <prvInitialiseNewStreamBuffer>
		else
		{
			traceSTREAM_BUFFER_CREATE_FAILED( xIsMessageBuffer );
		}

		return ( StreamBufferHandle_t ) pucAllocatedMemory; /*lint !e9087 !e826 Safe cast as allocated memory is aligned. */
    3cde:	8a 81       	ldd	r24, Y+2	; 0x02
    3ce0:	9b 81       	ldd	r25, Y+3	; 0x03
	}
    3ce2:	28 96       	adiw	r28, 0x08	; 8
    3ce4:	0f b6       	in	r0, 0x3f	; 63
    3ce6:	f8 94       	cli
    3ce8:	de bf       	out	0x3e, r29	; 62
    3cea:	0f be       	out	0x3f, r0	; 63
    3cec:	cd bf       	out	0x3d, r28	; 61
    3cee:	cf 91       	pop	r28
    3cf0:	df 91       	pop	r29
    3cf2:	0f 91       	pop	r16
    3cf4:	08 95       	ret

00003cf6 <vStreamBufferDelete>:

#endif /* ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
/*-----------------------------------------------------------*/

void vStreamBufferDelete( StreamBufferHandle_t xStreamBuffer )
{
    3cf6:	df 93       	push	r29
    3cf8:	cf 93       	push	r28
    3cfa:	00 d0       	rcall	.+0      	; 0x3cfc <vStreamBufferDelete+0x6>
    3cfc:	00 d0       	rcall	.+0      	; 0x3cfe <vStreamBufferDelete+0x8>
    3cfe:	cd b7       	in	r28, 0x3d	; 61
    3d00:	de b7       	in	r29, 0x3e	; 62
    3d02:	9c 83       	std	Y+4, r25	; 0x04
    3d04:	8b 83       	std	Y+3, r24	; 0x03
StreamBuffer_t * pxStreamBuffer = xStreamBuffer;
    3d06:	8b 81       	ldd	r24, Y+3	; 0x03
    3d08:	9c 81       	ldd	r25, Y+4	; 0x04
    3d0a:	9a 83       	std	Y+2, r25	; 0x02
    3d0c:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxStreamBuffer );

	traceSTREAM_BUFFER_DELETE( xStreamBuffer );

	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) pdFALSE )
    3d0e:	e9 81       	ldd	r30, Y+1	; 0x01
    3d10:	fa 81       	ldd	r31, Y+2	; 0x02
    3d12:	86 85       	ldd	r24, Z+14	; 0x0e
    3d14:	88 2f       	mov	r24, r24
    3d16:	90 e0       	ldi	r25, 0x00	; 0
    3d18:	82 70       	andi	r24, 0x02	; 2
    3d1a:	90 70       	andi	r25, 0x00	; 0
    3d1c:	00 97       	sbiw	r24, 0x00	; 0
    3d1e:	29 f4       	brne	.+10     	; 0x3d2a <vStreamBufferDelete+0x34>
	{
		#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
		{
			/* Both the structure and the buffer were allocated using a single call
			to pvPortMalloc(), hence only one call to vPortFree() is required. */
			vPortFree( ( void * ) pxStreamBuffer ); /*lint !e9087 Standard free() semantics require void *, plus pxStreamBuffer was allocated by pvPortMalloc(). */
    3d20:	89 81       	ldd	r24, Y+1	; 0x01
    3d22:	9a 81       	ldd	r25, Y+2	; 0x02
    3d24:	0e 94 89 0d 	call	0x1b12	; 0x1b12 <vPortFree>
    3d28:	08 c0       	rjmp	.+16     	; 0x3d3a <vStreamBufferDelete+0x44>
	}
	else
	{
		/* The structure and buffer were not allocated dynamically and cannot be
		freed - just scrub the structure so future use will assert. */
		( void ) memset( pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) );
    3d2a:	89 81       	ldd	r24, Y+1	; 0x01
    3d2c:	9a 81       	ldd	r25, Y+2	; 0x02
    3d2e:	60 e0       	ldi	r22, 0x00	; 0
    3d30:	70 e0       	ldi	r23, 0x00	; 0
    3d32:	4f e0       	ldi	r20, 0x0F	; 15
    3d34:	50 e0       	ldi	r21, 0x00	; 0
    3d36:	0e 94 1c 33 	call	0x6638	; 0x6638 <memset>
	}
}
    3d3a:	0f 90       	pop	r0
    3d3c:	0f 90       	pop	r0
    3d3e:	0f 90       	pop	r0
    3d40:	0f 90       	pop	r0
    3d42:	cf 91       	pop	r28
    3d44:	df 91       	pop	r29
    3d46:	08 95       	ret

00003d48 <xStreamBufferReset>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferReset( StreamBufferHandle_t xStreamBuffer )
{
    3d48:	0f 93       	push	r16
    3d4a:	df 93       	push	r29
    3d4c:	cf 93       	push	r28
    3d4e:	00 d0       	rcall	.+0      	; 0x3d50 <xStreamBufferReset+0x8>
    3d50:	00 d0       	rcall	.+0      	; 0x3d52 <xStreamBufferReset+0xa>
    3d52:	0f 92       	push	r0
    3d54:	cd b7       	in	r28, 0x3d	; 61
    3d56:	de b7       	in	r29, 0x3e	; 62
    3d58:	9d 83       	std	Y+5, r25	; 0x05
    3d5a:	8c 83       	std	Y+4, r24	; 0x04
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    3d5c:	8c 81       	ldd	r24, Y+4	; 0x04
    3d5e:	9d 81       	ldd	r25, Y+5	; 0x05
    3d60:	9b 83       	std	Y+3, r25	; 0x03
    3d62:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn = pdFAIL;
    3d64:	19 82       	std	Y+1, r1	; 0x01
		uxStreamBufferNumber = pxStreamBuffer->uxStreamBufferNumber;
	}
	#endif

	/* Can only reset a message buffer if there are no tasks blocked on it. */
	taskENTER_CRITICAL();
    3d66:	0f b6       	in	r0, 0x3f	; 63
    3d68:	f8 94       	cli
    3d6a:	0f 92       	push	r0
	{
		if( pxStreamBuffer->xTaskWaitingToReceive == NULL )
    3d6c:	ea 81       	ldd	r30, Y+2	; 0x02
    3d6e:	fb 81       	ldd	r31, Y+3	; 0x03
    3d70:	80 85       	ldd	r24, Z+8	; 0x08
    3d72:	91 85       	ldd	r25, Z+9	; 0x09
    3d74:	00 97       	sbiw	r24, 0x00	; 0
    3d76:	f1 f4       	brne	.+60     	; 0x3db4 <xStreamBufferReset+0x6c>
		{
			if( pxStreamBuffer->xTaskWaitingToSend == NULL )
    3d78:	ea 81       	ldd	r30, Y+2	; 0x02
    3d7a:	fb 81       	ldd	r31, Y+3	; 0x03
    3d7c:	82 85       	ldd	r24, Z+10	; 0x0a
    3d7e:	93 85       	ldd	r25, Z+11	; 0x0b
    3d80:	00 97       	sbiw	r24, 0x00	; 0
    3d82:	c1 f4       	brne	.+48     	; 0x3db4 <xStreamBufferReset+0x6c>
			{
				prvInitialiseNewStreamBuffer( pxStreamBuffer,
    3d84:	ea 81       	ldd	r30, Y+2	; 0x02
    3d86:	fb 81       	ldd	r31, Y+3	; 0x03
    3d88:	24 85       	ldd	r18, Z+12	; 0x0c
    3d8a:	35 85       	ldd	r19, Z+13	; 0x0d
    3d8c:	ea 81       	ldd	r30, Y+2	; 0x02
    3d8e:	fb 81       	ldd	r31, Y+3	; 0x03
    3d90:	44 81       	ldd	r20, Z+4	; 0x04
    3d92:	55 81       	ldd	r21, Z+5	; 0x05
    3d94:	ea 81       	ldd	r30, Y+2	; 0x02
    3d96:	fb 81       	ldd	r31, Y+3	; 0x03
    3d98:	a6 81       	ldd	r26, Z+6	; 0x06
    3d9a:	b7 81       	ldd	r27, Z+7	; 0x07
    3d9c:	ea 81       	ldd	r30, Y+2	; 0x02
    3d9e:	fb 81       	ldd	r31, Y+3	; 0x03
    3da0:	e6 85       	ldd	r30, Z+14	; 0x0e
    3da2:	8a 81       	ldd	r24, Y+2	; 0x02
    3da4:	9b 81       	ldd	r25, Y+3	; 0x03
    3da6:	b9 01       	movw	r22, r18
    3da8:	9d 01       	movw	r18, r26
    3daa:	0e 2f       	mov	r16, r30
    3dac:	0e 94 87 25 	call	0x4b0e	; 0x4b0e <prvInitialiseNewStreamBuffer>
											  pxStreamBuffer->pucBuffer,
											  pxStreamBuffer->xLength,
											  pxStreamBuffer->xTriggerLevelBytes,
											  pxStreamBuffer->ucFlags );
				xReturn = pdPASS;
    3db0:	81 e0       	ldi	r24, 0x01	; 1
    3db2:	89 83       	std	Y+1, r24	; 0x01

				traceSTREAM_BUFFER_RESET( xStreamBuffer );
			}
		}
	}
	taskEXIT_CRITICAL();
    3db4:	0f 90       	pop	r0
    3db6:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    3db8:	89 81       	ldd	r24, Y+1	; 0x01
}
    3dba:	0f 90       	pop	r0
    3dbc:	0f 90       	pop	r0
    3dbe:	0f 90       	pop	r0
    3dc0:	0f 90       	pop	r0
    3dc2:	0f 90       	pop	r0
    3dc4:	cf 91       	pop	r28
    3dc6:	df 91       	pop	r29
    3dc8:	0f 91       	pop	r16
    3dca:	08 95       	ret

00003dcc <xStreamBufferSetTriggerLevel>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferSetTriggerLevel( StreamBufferHandle_t xStreamBuffer, size_t xTriggerLevel )
{
    3dcc:	df 93       	push	r29
    3dce:	cf 93       	push	r28
    3dd0:	cd b7       	in	r28, 0x3d	; 61
    3dd2:	de b7       	in	r29, 0x3e	; 62
    3dd4:	27 97       	sbiw	r28, 0x07	; 7
    3dd6:	0f b6       	in	r0, 0x3f	; 63
    3dd8:	f8 94       	cli
    3dda:	de bf       	out	0x3e, r29	; 62
    3ddc:	0f be       	out	0x3f, r0	; 63
    3dde:	cd bf       	out	0x3d, r28	; 61
    3de0:	9d 83       	std	Y+5, r25	; 0x05
    3de2:	8c 83       	std	Y+4, r24	; 0x04
    3de4:	7f 83       	std	Y+7, r23	; 0x07
    3de6:	6e 83       	std	Y+6, r22	; 0x06
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    3de8:	8c 81       	ldd	r24, Y+4	; 0x04
    3dea:	9d 81       	ldd	r25, Y+5	; 0x05
    3dec:	9b 83       	std	Y+3, r25	; 0x03
    3dee:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	configASSERT( pxStreamBuffer );

	/* It is not valid for the trigger level to be 0. */
	if( xTriggerLevel == ( size_t ) 0 )
    3df0:	8e 81       	ldd	r24, Y+6	; 0x06
    3df2:	9f 81       	ldd	r25, Y+7	; 0x07
    3df4:	00 97       	sbiw	r24, 0x00	; 0
    3df6:	21 f4       	brne	.+8      	; 0x3e00 <xStreamBufferSetTriggerLevel+0x34>
	{
		xTriggerLevel = ( size_t ) 1;
    3df8:	81 e0       	ldi	r24, 0x01	; 1
    3dfa:	90 e0       	ldi	r25, 0x00	; 0
    3dfc:	9f 83       	std	Y+7, r25	; 0x07
    3dfe:	8e 83       	std	Y+6, r24	; 0x06
	}

	/* The trigger level is the number of bytes that must be in the stream
	buffer before a task that is waiting for data is unblocked. */
	if( xTriggerLevel <= pxStreamBuffer->xLength )
    3e00:	ea 81       	ldd	r30, Y+2	; 0x02
    3e02:	fb 81       	ldd	r31, Y+3	; 0x03
    3e04:	24 81       	ldd	r18, Z+4	; 0x04
    3e06:	35 81       	ldd	r19, Z+5	; 0x05
    3e08:	8e 81       	ldd	r24, Y+6	; 0x06
    3e0a:	9f 81       	ldd	r25, Y+7	; 0x07
    3e0c:	28 17       	cp	r18, r24
    3e0e:	39 07       	cpc	r19, r25
    3e10:	48 f0       	brcs	.+18     	; 0x3e24 <xStreamBufferSetTriggerLevel+0x58>
	{
		pxStreamBuffer->xTriggerLevelBytes = xTriggerLevel;
    3e12:	ea 81       	ldd	r30, Y+2	; 0x02
    3e14:	fb 81       	ldd	r31, Y+3	; 0x03
    3e16:	8e 81       	ldd	r24, Y+6	; 0x06
    3e18:	9f 81       	ldd	r25, Y+7	; 0x07
    3e1a:	97 83       	std	Z+7, r25	; 0x07
    3e1c:	86 83       	std	Z+6, r24	; 0x06
		xReturn = pdPASS;
    3e1e:	81 e0       	ldi	r24, 0x01	; 1
    3e20:	89 83       	std	Y+1, r24	; 0x01
    3e22:	01 c0       	rjmp	.+2      	; 0x3e26 <xStreamBufferSetTriggerLevel+0x5a>
	}
	else
	{
		xReturn = pdFALSE;
    3e24:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    3e26:	89 81       	ldd	r24, Y+1	; 0x01
}
    3e28:	27 96       	adiw	r28, 0x07	; 7
    3e2a:	0f b6       	in	r0, 0x3f	; 63
    3e2c:	f8 94       	cli
    3e2e:	de bf       	out	0x3e, r29	; 62
    3e30:	0f be       	out	0x3f, r0	; 63
    3e32:	cd bf       	out	0x3d, r28	; 61
    3e34:	cf 91       	pop	r28
    3e36:	df 91       	pop	r29
    3e38:	08 95       	ret

00003e3a <xStreamBufferSpacesAvailable>:
/*-----------------------------------------------------------*/

size_t xStreamBufferSpacesAvailable( StreamBufferHandle_t xStreamBuffer )
{
    3e3a:	df 93       	push	r29
    3e3c:	cf 93       	push	r28
    3e3e:	00 d0       	rcall	.+0      	; 0x3e40 <xStreamBufferSpacesAvailable+0x6>
    3e40:	00 d0       	rcall	.+0      	; 0x3e42 <xStreamBufferSpacesAvailable+0x8>
    3e42:	00 d0       	rcall	.+0      	; 0x3e44 <xStreamBufferSpacesAvailable+0xa>
    3e44:	cd b7       	in	r28, 0x3d	; 61
    3e46:	de b7       	in	r29, 0x3e	; 62
    3e48:	9e 83       	std	Y+6, r25	; 0x06
    3e4a:	8d 83       	std	Y+5, r24	; 0x05
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    3e4c:	8d 81       	ldd	r24, Y+5	; 0x05
    3e4e:	9e 81       	ldd	r25, Y+6	; 0x06
    3e50:	9c 83       	std	Y+4, r25	; 0x04
    3e52:	8b 83       	std	Y+3, r24	; 0x03
size_t xSpace;

	configASSERT( pxStreamBuffer );

	xSpace = pxStreamBuffer->xLength + pxStreamBuffer->xTail;
    3e54:	eb 81       	ldd	r30, Y+3	; 0x03
    3e56:	fc 81       	ldd	r31, Y+4	; 0x04
    3e58:	24 81       	ldd	r18, Z+4	; 0x04
    3e5a:	35 81       	ldd	r19, Z+5	; 0x05
    3e5c:	eb 81       	ldd	r30, Y+3	; 0x03
    3e5e:	fc 81       	ldd	r31, Y+4	; 0x04
    3e60:	80 81       	ld	r24, Z
    3e62:	91 81       	ldd	r25, Z+1	; 0x01
    3e64:	82 0f       	add	r24, r18
    3e66:	93 1f       	adc	r25, r19
    3e68:	9a 83       	std	Y+2, r25	; 0x02
    3e6a:	89 83       	std	Y+1, r24	; 0x01
	xSpace -= pxStreamBuffer->xHead;
    3e6c:	eb 81       	ldd	r30, Y+3	; 0x03
    3e6e:	fc 81       	ldd	r31, Y+4	; 0x04
    3e70:	22 81       	ldd	r18, Z+2	; 0x02
    3e72:	33 81       	ldd	r19, Z+3	; 0x03
    3e74:	89 81       	ldd	r24, Y+1	; 0x01
    3e76:	9a 81       	ldd	r25, Y+2	; 0x02
    3e78:	82 1b       	sub	r24, r18
    3e7a:	93 0b       	sbc	r25, r19
    3e7c:	9a 83       	std	Y+2, r25	; 0x02
    3e7e:	89 83       	std	Y+1, r24	; 0x01
	xSpace -= ( size_t ) 1;
    3e80:	89 81       	ldd	r24, Y+1	; 0x01
    3e82:	9a 81       	ldd	r25, Y+2	; 0x02
    3e84:	01 97       	sbiw	r24, 0x01	; 1
    3e86:	9a 83       	std	Y+2, r25	; 0x02
    3e88:	89 83       	std	Y+1, r24	; 0x01

	if( xSpace >= pxStreamBuffer->xLength )
    3e8a:	eb 81       	ldd	r30, Y+3	; 0x03
    3e8c:	fc 81       	ldd	r31, Y+4	; 0x04
    3e8e:	24 81       	ldd	r18, Z+4	; 0x04
    3e90:	35 81       	ldd	r19, Z+5	; 0x05
    3e92:	89 81       	ldd	r24, Y+1	; 0x01
    3e94:	9a 81       	ldd	r25, Y+2	; 0x02
    3e96:	82 17       	cp	r24, r18
    3e98:	93 07       	cpc	r25, r19
    3e9a:	50 f0       	brcs	.+20     	; 0x3eb0 <xStreamBufferSpacesAvailable+0x76>
	{
		xSpace -= pxStreamBuffer->xLength;
    3e9c:	eb 81       	ldd	r30, Y+3	; 0x03
    3e9e:	fc 81       	ldd	r31, Y+4	; 0x04
    3ea0:	24 81       	ldd	r18, Z+4	; 0x04
    3ea2:	35 81       	ldd	r19, Z+5	; 0x05
    3ea4:	89 81       	ldd	r24, Y+1	; 0x01
    3ea6:	9a 81       	ldd	r25, Y+2	; 0x02
    3ea8:	82 1b       	sub	r24, r18
    3eaa:	93 0b       	sbc	r25, r19
    3eac:	9a 83       	std	Y+2, r25	; 0x02
    3eae:	89 83       	std	Y+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xSpace;
    3eb0:	89 81       	ldd	r24, Y+1	; 0x01
    3eb2:	9a 81       	ldd	r25, Y+2	; 0x02
}
    3eb4:	26 96       	adiw	r28, 0x06	; 6
    3eb6:	0f b6       	in	r0, 0x3f	; 63
    3eb8:	f8 94       	cli
    3eba:	de bf       	out	0x3e, r29	; 62
    3ebc:	0f be       	out	0x3f, r0	; 63
    3ebe:	cd bf       	out	0x3d, r28	; 61
    3ec0:	cf 91       	pop	r28
    3ec2:	df 91       	pop	r29
    3ec4:	08 95       	ret

00003ec6 <xStreamBufferBytesAvailable>:
/*-----------------------------------------------------------*/

size_t xStreamBufferBytesAvailable( StreamBufferHandle_t xStreamBuffer )
{
    3ec6:	df 93       	push	r29
    3ec8:	cf 93       	push	r28
    3eca:	00 d0       	rcall	.+0      	; 0x3ecc <xStreamBufferBytesAvailable+0x6>
    3ecc:	00 d0       	rcall	.+0      	; 0x3ece <xStreamBufferBytesAvailable+0x8>
    3ece:	00 d0       	rcall	.+0      	; 0x3ed0 <xStreamBufferBytesAvailable+0xa>
    3ed0:	cd b7       	in	r28, 0x3d	; 61
    3ed2:	de b7       	in	r29, 0x3e	; 62
    3ed4:	9e 83       	std	Y+6, r25	; 0x06
    3ed6:	8d 83       	std	Y+5, r24	; 0x05
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    3ed8:	8d 81       	ldd	r24, Y+5	; 0x05
    3eda:	9e 81       	ldd	r25, Y+6	; 0x06
    3edc:	9c 83       	std	Y+4, r25	; 0x04
    3ede:	8b 83       	std	Y+3, r24	; 0x03
size_t xReturn;

	configASSERT( pxStreamBuffer );

	xReturn = prvBytesInBuffer( pxStreamBuffer );
    3ee0:	8b 81       	ldd	r24, Y+3	; 0x03
    3ee2:	9c 81       	ldd	r25, Y+4	; 0x04
    3ee4:	0e 94 4d 25 	call	0x4a9a	; 0x4a9a <prvBytesInBuffer>
    3ee8:	9a 83       	std	Y+2, r25	; 0x02
    3eea:	89 83       	std	Y+1, r24	; 0x01
	return xReturn;
    3eec:	89 81       	ldd	r24, Y+1	; 0x01
    3eee:	9a 81       	ldd	r25, Y+2	; 0x02
}
    3ef0:	26 96       	adiw	r28, 0x06	; 6
    3ef2:	0f b6       	in	r0, 0x3f	; 63
    3ef4:	f8 94       	cli
    3ef6:	de bf       	out	0x3e, r29	; 62
    3ef8:	0f be       	out	0x3f, r0	; 63
    3efa:	cd bf       	out	0x3d, r28	; 61
    3efc:	cf 91       	pop	r28
    3efe:	df 91       	pop	r29
    3f00:	08 95       	ret

00003f02 <xStreamBufferSend>:

size_t xStreamBufferSend( StreamBufferHandle_t xStreamBuffer,
						  const void *pvTxData,
						  size_t xDataLengthBytes,
						  TickType_t xTicksToWait )
{
    3f02:	ef 92       	push	r14
    3f04:	ff 92       	push	r15
    3f06:	0f 93       	push	r16
    3f08:	1f 93       	push	r17
    3f0a:	df 93       	push	r29
    3f0c:	cf 93       	push	r28
    3f0e:	cd b7       	in	r28, 0x3d	; 61
    3f10:	de b7       	in	r29, 0x3e	; 62
    3f12:	63 97       	sbiw	r28, 0x13	; 19
    3f14:	0f b6       	in	r0, 0x3f	; 63
    3f16:	f8 94       	cli
    3f18:	de bf       	out	0x3e, r29	; 62
    3f1a:	0f be       	out	0x3f, r0	; 63
    3f1c:	cd bf       	out	0x3d, r28	; 61
    3f1e:	9d 87       	std	Y+13, r25	; 0x0d
    3f20:	8c 87       	std	Y+12, r24	; 0x0c
    3f22:	7f 87       	std	Y+15, r23	; 0x0f
    3f24:	6e 87       	std	Y+14, r22	; 0x0e
    3f26:	59 8b       	std	Y+17, r21	; 0x11
    3f28:	48 8b       	std	Y+16, r20	; 0x10
    3f2a:	3b 8b       	std	Y+19, r19	; 0x13
    3f2c:	2a 8b       	std	Y+18, r18	; 0x12
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    3f2e:	8c 85       	ldd	r24, Y+12	; 0x0c
    3f30:	9d 85       	ldd	r25, Y+13	; 0x0d
    3f32:	98 87       	std	Y+8, r25	; 0x08
    3f34:	8f 83       	std	Y+7, r24	; 0x07
size_t xReturn, xSpace = 0;
    3f36:	1c 82       	std	Y+4, r1	; 0x04
    3f38:	1b 82       	std	Y+3, r1	; 0x03
size_t xRequiredSpace = xDataLengthBytes;
    3f3a:	88 89       	ldd	r24, Y+16	; 0x10
    3f3c:	99 89       	ldd	r25, Y+17	; 0x11
    3f3e:	9a 83       	std	Y+2, r25	; 0x02
    3f40:	89 83       	std	Y+1, r24	; 0x01

	/* This send function is used to write to both message buffers and stream
	buffers.  If this is a message buffer then the space needed must be
	increased by the amount of bytes needed to store the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    3f42:	ef 81       	ldd	r30, Y+7	; 0x07
    3f44:	f8 85       	ldd	r31, Y+8	; 0x08
    3f46:	86 85       	ldd	r24, Z+14	; 0x0e
    3f48:	88 2f       	mov	r24, r24
    3f4a:	90 e0       	ldi	r25, 0x00	; 0
    3f4c:	81 70       	andi	r24, 0x01	; 1
    3f4e:	90 70       	andi	r25, 0x00	; 0
    3f50:	88 23       	and	r24, r24
    3f52:	29 f0       	breq	.+10     	; 0x3f5e <xStreamBufferSend+0x5c>
	{
		xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
    3f54:	89 81       	ldd	r24, Y+1	; 0x01
    3f56:	9a 81       	ldd	r25, Y+2	; 0x02
    3f58:	02 96       	adiw	r24, 0x02	; 2
    3f5a:	9a 83       	std	Y+2, r25	; 0x02
    3f5c:	89 83       	std	Y+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	if( xTicksToWait != ( TickType_t ) 0 )
    3f5e:	8a 89       	ldd	r24, Y+18	; 0x12
    3f60:	9b 89       	ldd	r25, Y+19	; 0x13
    3f62:	00 97       	sbiw	r24, 0x00	; 0
    3f64:	09 f4       	brne	.+2      	; 0x3f68 <xStreamBufferSend+0x66>
    3f66:	40 c0       	rjmp	.+128    	; 0x3fe8 <xStreamBufferSend+0xe6>
	{
		vTaskSetTimeOutState( &xTimeOut );
    3f68:	ce 01       	movw	r24, r28
    3f6a:	09 96       	adiw	r24, 0x09	; 9
    3f6c:	0e 94 16 2d 	call	0x5a2c	; 0x5a2c <vTaskSetTimeOutState>

		do
		{
			/* Wait until the required number of bytes are free in the message
			buffer. */
			taskENTER_CRITICAL();
    3f70:	0f b6       	in	r0, 0x3f	; 63
    3f72:	f8 94       	cli
    3f74:	0f 92       	push	r0
			{
				xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    3f76:	8f 81       	ldd	r24, Y+7	; 0x07
    3f78:	98 85       	ldd	r25, Y+8	; 0x08
    3f7a:	0e 94 1d 1f 	call	0x3e3a	; 0x3e3a <xStreamBufferSpacesAvailable>
    3f7e:	9c 83       	std	Y+4, r25	; 0x04
    3f80:	8b 83       	std	Y+3, r24	; 0x03

				if( xSpace < xRequiredSpace )
    3f82:	2b 81       	ldd	r18, Y+3	; 0x03
    3f84:	3c 81       	ldd	r19, Y+4	; 0x04
    3f86:	89 81       	ldd	r24, Y+1	; 0x01
    3f88:	9a 81       	ldd	r25, Y+2	; 0x02
    3f8a:	28 17       	cp	r18, r24
    3f8c:	39 07       	cpc	r19, r25
    3f8e:	50 f5       	brcc	.+84     	; 0x3fe4 <xStreamBufferSend+0xe2>
				{
					/* Clear notification state as going to wait for space. */
					( void ) xTaskNotifyStateClear( NULL );
    3f90:	80 e0       	ldi	r24, 0x00	; 0
    3f92:	90 e0       	ldi	r25, 0x00	; 0
    3f94:	0e 94 26 32 	call	0x644c	; 0x644c <xTaskNotifyStateClear>

					/* Should only be one writer. */
					configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );
					pxStreamBuffer->xTaskWaitingToSend = xTaskGetCurrentTaskHandle();
    3f98:	0e 94 7f 2e 	call	0x5cfe	; 0x5cfe <xTaskGetCurrentTaskHandle>
    3f9c:	ef 81       	ldd	r30, Y+7	; 0x07
    3f9e:	f8 85       	ldd	r31, Y+8	; 0x08
    3fa0:	93 87       	std	Z+11, r25	; 0x0b
    3fa2:	82 87       	std	Z+10, r24	; 0x0a
				{
					taskEXIT_CRITICAL();
					break;
				}
			}
			taskEXIT_CRITICAL();
    3fa4:	0f 90       	pop	r0
    3fa6:	0f be       	out	0x3f, r0	; 63

			traceBLOCKING_ON_STREAM_BUFFER_SEND( xStreamBuffer );
			( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
    3fa8:	ea 89       	ldd	r30, Y+18	; 0x12
    3faa:	fb 89       	ldd	r31, Y+19	; 0x13
    3fac:	60 e0       	ldi	r22, 0x00	; 0
    3fae:	70 e0       	ldi	r23, 0x00	; 0
    3fb0:	80 e0       	ldi	r24, 0x00	; 0
    3fb2:	90 e0       	ldi	r25, 0x00	; 0
    3fb4:	20 e0       	ldi	r18, 0x00	; 0
    3fb6:	30 e0       	ldi	r19, 0x00	; 0
    3fb8:	40 e0       	ldi	r20, 0x00	; 0
    3fba:	50 e0       	ldi	r21, 0x00	; 0
    3fbc:	00 e0       	ldi	r16, 0x00	; 0
    3fbe:	10 e0       	ldi	r17, 0x00	; 0
    3fc0:	7f 01       	movw	r14, r30
    3fc2:	0e 94 2f 2f 	call	0x5e5e	; 0x5e5e <xTaskNotifyWait>
			pxStreamBuffer->xTaskWaitingToSend = NULL;
    3fc6:	ef 81       	ldd	r30, Y+7	; 0x07
    3fc8:	f8 85       	ldd	r31, Y+8	; 0x08
    3fca:	13 86       	std	Z+11, r1	; 0x0b
    3fcc:	12 86       	std	Z+10, r1	; 0x0a

		} while( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE );
    3fce:	ce 01       	movw	r24, r28
    3fd0:	09 96       	adiw	r24, 0x09	; 9
    3fd2:	9e 01       	movw	r18, r28
    3fd4:	2e 5e       	subi	r18, 0xEE	; 238
    3fd6:	3f 4f       	sbci	r19, 0xFF	; 255
    3fd8:	b9 01       	movw	r22, r18
    3fda:	0e 94 4d 2d 	call	0x5a9a	; 0x5a9a <xTaskCheckForTimeOut>
    3fde:	88 23       	and	r24, r24
    3fe0:	39 f2       	breq	.-114    	; 0x3f70 <xStreamBufferSend+0x6e>
    3fe2:	02 c0       	rjmp	.+4      	; 0x3fe8 <xStreamBufferSend+0xe6>
					configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );
					pxStreamBuffer->xTaskWaitingToSend = xTaskGetCurrentTaskHandle();
				}
				else
				{
					taskEXIT_CRITICAL();
    3fe4:	0f 90       	pop	r0
    3fe6:	0f be       	out	0x3f, r0	; 63
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	if( xSpace == ( size_t ) 0 )
    3fe8:	8b 81       	ldd	r24, Y+3	; 0x03
    3fea:	9c 81       	ldd	r25, Y+4	; 0x04
    3fec:	00 97       	sbiw	r24, 0x00	; 0
    3fee:	31 f4       	brne	.+12     	; 0x3ffc <xStreamBufferSend+0xfa>
	{
		xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    3ff0:	8f 81       	ldd	r24, Y+7	; 0x07
    3ff2:	98 85       	ldd	r25, Y+8	; 0x08
    3ff4:	0e 94 1d 1f 	call	0x3e3a	; 0x3e3a <xStreamBufferSpacesAvailable>
    3ff8:	9c 83       	std	Y+4, r25	; 0x04
    3ffa:	8b 83       	std	Y+3, r24	; 0x03
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
    3ffc:	8f 81       	ldd	r24, Y+7	; 0x07
    3ffe:	98 85       	ldd	r25, Y+8	; 0x08
    4000:	2e 85       	ldd	r18, Y+14	; 0x0e
    4002:	3f 85       	ldd	r19, Y+15	; 0x0f
    4004:	48 89       	ldd	r20, Y+16	; 0x10
    4006:	59 89       	ldd	r21, Y+17	; 0x11
    4008:	eb 81       	ldd	r30, Y+3	; 0x03
    400a:	fc 81       	ldd	r31, Y+4	; 0x04
    400c:	a9 81       	ldd	r26, Y+1	; 0x01
    400e:	ba 81       	ldd	r27, Y+2	; 0x02
    4010:	b9 01       	movw	r22, r18
    4012:	9f 01       	movw	r18, r30
    4014:	8d 01       	movw	r16, r26
    4016:	0e 94 c6 20 	call	0x418c	; 0x418c <prvWriteMessageToBuffer>
    401a:	9e 83       	std	Y+6, r25	; 0x06
    401c:	8d 83       	std	Y+5, r24	; 0x05

	if( xReturn > ( size_t ) 0 )
    401e:	8d 81       	ldd	r24, Y+5	; 0x05
    4020:	9e 81       	ldd	r25, Y+6	; 0x06
    4022:	00 97       	sbiw	r24, 0x00	; 0
    4024:	39 f1       	breq	.+78     	; 0x4074 <xStreamBufferSend+0x172>
	{
		traceSTREAM_BUFFER_SEND( xStreamBuffer, xReturn );

		/* Was a task waiting for the data? */
		if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
    4026:	8f 81       	ldd	r24, Y+7	; 0x07
    4028:	98 85       	ldd	r25, Y+8	; 0x08
    402a:	0e 94 4d 25 	call	0x4a9a	; 0x4a9a <prvBytesInBuffer>
    402e:	9c 01       	movw	r18, r24
    4030:	ef 81       	ldd	r30, Y+7	; 0x07
    4032:	f8 85       	ldd	r31, Y+8	; 0x08
    4034:	86 81       	ldd	r24, Z+6	; 0x06
    4036:	97 81       	ldd	r25, Z+7	; 0x07
    4038:	28 17       	cp	r18, r24
    403a:	39 07       	cpc	r19, r25
    403c:	d8 f0       	brcs	.+54     	; 0x4074 <xStreamBufferSend+0x172>
		{
			sbSEND_COMPLETED( pxStreamBuffer );
    403e:	0e 94 ae 29 	call	0x535c	; 0x535c <vTaskSuspendAll>
    4042:	ef 81       	ldd	r30, Y+7	; 0x07
    4044:	f8 85       	ldd	r31, Y+8	; 0x08
    4046:	80 85       	ldd	r24, Z+8	; 0x08
    4048:	91 85       	ldd	r25, Z+9	; 0x09
    404a:	00 97       	sbiw	r24, 0x00	; 0
    404c:	89 f0       	breq	.+34     	; 0x4070 <xStreamBufferSend+0x16e>
    404e:	ef 81       	ldd	r30, Y+7	; 0x07
    4050:	f8 85       	ldd	r31, Y+8	; 0x08
    4052:	80 85       	ldd	r24, Z+8	; 0x08
    4054:	91 85       	ldd	r25, Z+9	; 0x09
    4056:	40 e0       	ldi	r20, 0x00	; 0
    4058:	50 e0       	ldi	r21, 0x00	; 0
    405a:	60 e0       	ldi	r22, 0x00	; 0
    405c:	70 e0       	ldi	r23, 0x00	; 0
    405e:	20 e0       	ldi	r18, 0x00	; 0
    4060:	00 e0       	ldi	r16, 0x00	; 0
    4062:	10 e0       	ldi	r17, 0x00	; 0
    4064:	0e 94 cb 2f 	call	0x5f96	; 0x5f96 <xTaskGenericNotify>
    4068:	ef 81       	ldd	r30, Y+7	; 0x07
    406a:	f8 85       	ldd	r31, Y+8	; 0x08
    406c:	11 86       	std	Z+9, r1	; 0x09
    406e:	10 86       	std	Z+8, r1	; 0x08
    4070:	0e 94 ba 29 	call	0x5374	; 0x5374 <xTaskResumeAll>
	{
		mtCOVERAGE_TEST_MARKER();
		traceSTREAM_BUFFER_SEND_FAILED( xStreamBuffer );
	}

	return xReturn;
    4074:	8d 81       	ldd	r24, Y+5	; 0x05
    4076:	9e 81       	ldd	r25, Y+6	; 0x06
}
    4078:	63 96       	adiw	r28, 0x13	; 19
    407a:	0f b6       	in	r0, 0x3f	; 63
    407c:	f8 94       	cli
    407e:	de bf       	out	0x3e, r29	; 62
    4080:	0f be       	out	0x3f, r0	; 63
    4082:	cd bf       	out	0x3d, r28	; 61
    4084:	cf 91       	pop	r28
    4086:	df 91       	pop	r29
    4088:	1f 91       	pop	r17
    408a:	0f 91       	pop	r16
    408c:	ff 90       	pop	r15
    408e:	ef 90       	pop	r14
    4090:	08 95       	ret

00004092 <xStreamBufferSendFromISR>:

size_t xStreamBufferSendFromISR( StreamBufferHandle_t xStreamBuffer,
								 const void *pvTxData,
								 size_t xDataLengthBytes,
								 BaseType_t * const pxHigherPriorityTaskWoken )
{
    4092:	ef 92       	push	r14
    4094:	ff 92       	push	r15
    4096:	0f 93       	push	r16
    4098:	1f 93       	push	r17
    409a:	df 93       	push	r29
    409c:	cf 93       	push	r28
    409e:	cd b7       	in	r28, 0x3d	; 61
    40a0:	de b7       	in	r29, 0x3e	; 62
    40a2:	61 97       	sbiw	r28, 0x11	; 17
    40a4:	0f b6       	in	r0, 0x3f	; 63
    40a6:	f8 94       	cli
    40a8:	de bf       	out	0x3e, r29	; 62
    40aa:	0f be       	out	0x3f, r0	; 63
    40ac:	cd bf       	out	0x3d, r28	; 61
    40ae:	9b 87       	std	Y+11, r25	; 0x0b
    40b0:	8a 87       	std	Y+10, r24	; 0x0a
    40b2:	7d 87       	std	Y+13, r23	; 0x0d
    40b4:	6c 87       	std	Y+12, r22	; 0x0c
    40b6:	5f 87       	std	Y+15, r21	; 0x0f
    40b8:	4e 87       	std	Y+14, r20	; 0x0e
    40ba:	39 8b       	std	Y+17, r19	; 0x11
    40bc:	28 8b       	std	Y+16, r18	; 0x10
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    40be:	8a 85       	ldd	r24, Y+10	; 0x0a
    40c0:	9b 85       	ldd	r25, Y+11	; 0x0b
    40c2:	99 87       	std	Y+9, r25	; 0x09
    40c4:	88 87       	std	Y+8, r24	; 0x08
size_t xReturn, xSpace;
size_t xRequiredSpace = xDataLengthBytes;
    40c6:	8e 85       	ldd	r24, Y+14	; 0x0e
    40c8:	9f 85       	ldd	r25, Y+15	; 0x0f
    40ca:	9b 83       	std	Y+3, r25	; 0x03
    40cc:	8a 83       	std	Y+2, r24	; 0x02

	/* This send function is used to write to both message buffers and stream
	buffers.  If this is a message buffer then the space needed must be
	increased by the amount of bytes needed to store the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    40ce:	e8 85       	ldd	r30, Y+8	; 0x08
    40d0:	f9 85       	ldd	r31, Y+9	; 0x09
    40d2:	86 85       	ldd	r24, Z+14	; 0x0e
    40d4:	88 2f       	mov	r24, r24
    40d6:	90 e0       	ldi	r25, 0x00	; 0
    40d8:	81 70       	andi	r24, 0x01	; 1
    40da:	90 70       	andi	r25, 0x00	; 0
    40dc:	88 23       	and	r24, r24
    40de:	29 f0       	breq	.+10     	; 0x40ea <xStreamBufferSendFromISR+0x58>
	{
		xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
    40e0:	8a 81       	ldd	r24, Y+2	; 0x02
    40e2:	9b 81       	ldd	r25, Y+3	; 0x03
    40e4:	02 96       	adiw	r24, 0x02	; 2
    40e6:	9b 83       	std	Y+3, r25	; 0x03
    40e8:	8a 83       	std	Y+2, r24	; 0x02
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    40ea:	88 85       	ldd	r24, Y+8	; 0x08
    40ec:	99 85       	ldd	r25, Y+9	; 0x09
    40ee:	0e 94 1d 1f 	call	0x3e3a	; 0x3e3a <xStreamBufferSpacesAvailable>
    40f2:	9d 83       	std	Y+5, r25	; 0x05
    40f4:	8c 83       	std	Y+4, r24	; 0x04
	xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
    40f6:	88 85       	ldd	r24, Y+8	; 0x08
    40f8:	99 85       	ldd	r25, Y+9	; 0x09
    40fa:	2c 85       	ldd	r18, Y+12	; 0x0c
    40fc:	3d 85       	ldd	r19, Y+13	; 0x0d
    40fe:	4e 85       	ldd	r20, Y+14	; 0x0e
    4100:	5f 85       	ldd	r21, Y+15	; 0x0f
    4102:	ec 81       	ldd	r30, Y+4	; 0x04
    4104:	fd 81       	ldd	r31, Y+5	; 0x05
    4106:	aa 81       	ldd	r26, Y+2	; 0x02
    4108:	bb 81       	ldd	r27, Y+3	; 0x03
    410a:	b9 01       	movw	r22, r18
    410c:	9f 01       	movw	r18, r30
    410e:	8d 01       	movw	r16, r26
    4110:	0e 94 c6 20 	call	0x418c	; 0x418c <prvWriteMessageToBuffer>
    4114:	9f 83       	std	Y+7, r25	; 0x07
    4116:	8e 83       	std	Y+6, r24	; 0x06

	if( xReturn > ( size_t ) 0 )
    4118:	8e 81       	ldd	r24, Y+6	; 0x06
    411a:	9f 81       	ldd	r25, Y+7	; 0x07
    411c:	00 97       	sbiw	r24, 0x00	; 0
    411e:	39 f1       	breq	.+78     	; 0x416e <xStreamBufferSendFromISR+0xdc>
	{
		/* Was a task waiting for the data? */
		if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
    4120:	88 85       	ldd	r24, Y+8	; 0x08
    4122:	99 85       	ldd	r25, Y+9	; 0x09
    4124:	0e 94 4d 25 	call	0x4a9a	; 0x4a9a <prvBytesInBuffer>
    4128:	9c 01       	movw	r18, r24
    412a:	e8 85       	ldd	r30, Y+8	; 0x08
    412c:	f9 85       	ldd	r31, Y+9	; 0x09
    412e:	86 81       	ldd	r24, Z+6	; 0x06
    4130:	97 81       	ldd	r25, Z+7	; 0x07
    4132:	28 17       	cp	r18, r24
    4134:	39 07       	cpc	r19, r25
    4136:	d8 f0       	brcs	.+54     	; 0x416e <xStreamBufferSendFromISR+0xdc>
		{
			sbSEND_COMPLETE_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
    4138:	19 82       	std	Y+1, r1	; 0x01
    413a:	e8 85       	ldd	r30, Y+8	; 0x08
    413c:	f9 85       	ldd	r31, Y+9	; 0x09
    413e:	80 85       	ldd	r24, Z+8	; 0x08
    4140:	91 85       	ldd	r25, Z+9	; 0x09
    4142:	00 97       	sbiw	r24, 0x00	; 0
    4144:	a1 f0       	breq	.+40     	; 0x416e <xStreamBufferSendFromISR+0xdc>
    4146:	e8 85       	ldd	r30, Y+8	; 0x08
    4148:	f9 85       	ldd	r31, Y+9	; 0x09
    414a:	80 85       	ldd	r24, Z+8	; 0x08
    414c:	91 85       	ldd	r25, Z+9	; 0x09
    414e:	e8 89       	ldd	r30, Y+16	; 0x10
    4150:	f9 89       	ldd	r31, Y+17	; 0x11
    4152:	40 e0       	ldi	r20, 0x00	; 0
    4154:	50 e0       	ldi	r21, 0x00	; 0
    4156:	60 e0       	ldi	r22, 0x00	; 0
    4158:	70 e0       	ldi	r23, 0x00	; 0
    415a:	20 e0       	ldi	r18, 0x00	; 0
    415c:	00 e0       	ldi	r16, 0x00	; 0
    415e:	10 e0       	ldi	r17, 0x00	; 0
    4160:	7f 01       	movw	r14, r30
    4162:	0e 94 a8 30 	call	0x6150	; 0x6150 <xTaskGenericNotifyFromISR>
    4166:	e8 85       	ldd	r30, Y+8	; 0x08
    4168:	f9 85       	ldd	r31, Y+9	; 0x09
    416a:	11 86       	std	Z+9, r1	; 0x09
    416c:	10 86       	std	Z+8, r1	; 0x08
		mtCOVERAGE_TEST_MARKER();
	}

	traceSTREAM_BUFFER_SEND_FROM_ISR( xStreamBuffer, xReturn );

	return xReturn;
    416e:	8e 81       	ldd	r24, Y+6	; 0x06
    4170:	9f 81       	ldd	r25, Y+7	; 0x07
}
    4172:	61 96       	adiw	r28, 0x11	; 17
    4174:	0f b6       	in	r0, 0x3f	; 63
    4176:	f8 94       	cli
    4178:	de bf       	out	0x3e, r29	; 62
    417a:	0f be       	out	0x3f, r0	; 63
    417c:	cd bf       	out	0x3d, r28	; 61
    417e:	cf 91       	pop	r28
    4180:	df 91       	pop	r29
    4182:	1f 91       	pop	r17
    4184:	0f 91       	pop	r16
    4186:	ff 90       	pop	r15
    4188:	ef 90       	pop	r14
    418a:	08 95       	ret

0000418c <prvWriteMessageToBuffer>:
static size_t prvWriteMessageToBuffer( StreamBuffer_t * const pxStreamBuffer,
									   const void * pvTxData,
									   size_t xDataLengthBytes,
									   size_t xSpace,
									   size_t xRequiredSpace )
{
    418c:	0f 93       	push	r16
    418e:	1f 93       	push	r17
    4190:	df 93       	push	r29
    4192:	cf 93       	push	r28
    4194:	cd b7       	in	r28, 0x3d	; 61
    4196:	de b7       	in	r29, 0x3e	; 62
    4198:	61 97       	sbiw	r28, 0x11	; 17
    419a:	0f b6       	in	r0, 0x3f	; 63
    419c:	f8 94       	cli
    419e:	de bf       	out	0x3e, r29	; 62
    41a0:	0f be       	out	0x3f, r0	; 63
    41a2:	cd bf       	out	0x3d, r28	; 61
    41a4:	9d 83       	std	Y+5, r25	; 0x05
    41a6:	8c 83       	std	Y+4, r24	; 0x04
    41a8:	7f 83       	std	Y+7, r23	; 0x07
    41aa:	6e 83       	std	Y+6, r22	; 0x06
    41ac:	59 87       	std	Y+9, r21	; 0x09
    41ae:	48 87       	std	Y+8, r20	; 0x08
    41b0:	3b 87       	std	Y+11, r19	; 0x0b
    41b2:	2a 87       	std	Y+10, r18	; 0x0a
    41b4:	1d 87       	std	Y+13, r17	; 0x0d
    41b6:	0c 87       	std	Y+12, r16	; 0x0c
	BaseType_t xShouldWrite;
	size_t xReturn;

	if( xSpace == ( size_t ) 0 )
    41b8:	8a 85       	ldd	r24, Y+10	; 0x0a
    41ba:	9b 85       	ldd	r25, Y+11	; 0x0b
    41bc:	00 97       	sbiw	r24, 0x00	; 0
    41be:	11 f4       	brne	.+4      	; 0x41c4 <prvWriteMessageToBuffer+0x38>
	{
		/* Doesn't matter if this is a stream buffer or a message buffer, there
		is no space to write. */
		xShouldWrite = pdFALSE;
    41c0:	1b 82       	std	Y+3, r1	; 0x03
    41c2:	38 c0       	rjmp	.+112    	; 0x4234 <prvWriteMessageToBuffer+0xa8>
	}
	else if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) == ( uint8_t ) 0 )
    41c4:	ec 81       	ldd	r30, Y+4	; 0x04
    41c6:	fd 81       	ldd	r31, Y+5	; 0x05
    41c8:	86 85       	ldd	r24, Z+14	; 0x0e
    41ca:	88 2f       	mov	r24, r24
    41cc:	90 e0       	ldi	r25, 0x00	; 0
    41ce:	81 70       	andi	r24, 0x01	; 1
    41d0:	90 70       	andi	r25, 0x00	; 0
    41d2:	00 97       	sbiw	r24, 0x00	; 0
    41d4:	d1 f4       	brne	.+52     	; 0x420a <prvWriteMessageToBuffer+0x7e>
	{
		/* This is a stream buffer, as opposed to a message buffer, so writing a
		stream of bytes rather than discrete messages.  Write as many bytes as
		possible. */
		xShouldWrite = pdTRUE;
    41d6:	81 e0       	ldi	r24, 0x01	; 1
    41d8:	8b 83       	std	Y+3, r24	; 0x03
		xDataLengthBytes = configMIN( xDataLengthBytes, xSpace );
    41da:	28 85       	ldd	r18, Y+8	; 0x08
    41dc:	39 85       	ldd	r19, Y+9	; 0x09
    41de:	39 8b       	std	Y+17, r19	; 0x11
    41e0:	28 8b       	std	Y+16, r18	; 0x10
    41e2:	8a 85       	ldd	r24, Y+10	; 0x0a
    41e4:	9b 85       	ldd	r25, Y+11	; 0x0b
    41e6:	9f 87       	std	Y+15, r25	; 0x0f
    41e8:	8e 87       	std	Y+14, r24	; 0x0e
    41ea:	2e 85       	ldd	r18, Y+14	; 0x0e
    41ec:	3f 85       	ldd	r19, Y+15	; 0x0f
    41ee:	88 89       	ldd	r24, Y+16	; 0x10
    41f0:	99 89       	ldd	r25, Y+17	; 0x11
    41f2:	82 17       	cp	r24, r18
    41f4:	93 07       	cpc	r25, r19
    41f6:	20 f4       	brcc	.+8      	; 0x4200 <prvWriteMessageToBuffer+0x74>
    41f8:	28 89       	ldd	r18, Y+16	; 0x10
    41fa:	39 89       	ldd	r19, Y+17	; 0x11
    41fc:	3f 87       	std	Y+15, r19	; 0x0f
    41fe:	2e 87       	std	Y+14, r18	; 0x0e
    4200:	8e 85       	ldd	r24, Y+14	; 0x0e
    4202:	9f 85       	ldd	r25, Y+15	; 0x0f
    4204:	99 87       	std	Y+9, r25	; 0x09
    4206:	88 87       	std	Y+8, r24	; 0x08
    4208:	15 c0       	rjmp	.+42     	; 0x4234 <prvWriteMessageToBuffer+0xa8>
	}
	else if( xSpace >= xRequiredSpace )
    420a:	2a 85       	ldd	r18, Y+10	; 0x0a
    420c:	3b 85       	ldd	r19, Y+11	; 0x0b
    420e:	8c 85       	ldd	r24, Y+12	; 0x0c
    4210:	9d 85       	ldd	r25, Y+13	; 0x0d
    4212:	28 17       	cp	r18, r24
    4214:	39 07       	cpc	r19, r25
    4216:	68 f0       	brcs	.+26     	; 0x4232 <prvWriteMessageToBuffer+0xa6>
	{
		/* This is a message buffer, as opposed to a stream buffer, and there
		is enough space to write both the message length and the message itself
		into the buffer.  Start by writing the length of the data, the data
		itself will be written later in this function. */
		xShouldWrite = pdTRUE;
    4218:	81 e0       	ldi	r24, 0x01	; 1
    421a:	8b 83       	std	Y+3, r24	; 0x03
		( void ) prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) &( xDataLengthBytes ), sbBYTES_TO_STORE_MESSAGE_LENGTH );
    421c:	9e 01       	movw	r18, r28
    421e:	28 5f       	subi	r18, 0xF8	; 248
    4220:	3f 4f       	sbci	r19, 0xFF	; 255
    4222:	8c 81       	ldd	r24, Y+4	; 0x04
    4224:	9d 81       	ldd	r25, Y+5	; 0x05
    4226:	b9 01       	movw	r22, r18
    4228:	42 e0       	ldi	r20, 0x02	; 2
    422a:	50 e0       	ldi	r21, 0x00	; 0
    422c:	0e 94 13 24 	call	0x4826	; 0x4826 <prvWriteBytesToBuffer>
    4230:	01 c0       	rjmp	.+2      	; 0x4234 <prvWriteMessageToBuffer+0xa8>
	}
	else
	{
		/* There is space available, but not enough space. */
		xShouldWrite = pdFALSE;
    4232:	1b 82       	std	Y+3, r1	; 0x03
	}

	if( xShouldWrite != pdFALSE )
    4234:	8b 81       	ldd	r24, Y+3	; 0x03
    4236:	88 23       	and	r24, r24
    4238:	61 f0       	breq	.+24     	; 0x4252 <prvWriteMessageToBuffer+0xc6>
	{
		/* Writes the data itself. */
		xReturn = prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) pvTxData, xDataLengthBytes ); /*lint !e9079 Storage buffer is implemented as uint8_t for ease of sizing, alighment and access. */
    423a:	2e 81       	ldd	r18, Y+6	; 0x06
    423c:	3f 81       	ldd	r19, Y+7	; 0x07
    423e:	48 85       	ldd	r20, Y+8	; 0x08
    4240:	59 85       	ldd	r21, Y+9	; 0x09
    4242:	8c 81       	ldd	r24, Y+4	; 0x04
    4244:	9d 81       	ldd	r25, Y+5	; 0x05
    4246:	b9 01       	movw	r22, r18
    4248:	0e 94 13 24 	call	0x4826	; 0x4826 <prvWriteBytesToBuffer>
    424c:	9a 83       	std	Y+2, r25	; 0x02
    424e:	89 83       	std	Y+1, r24	; 0x01
    4250:	02 c0       	rjmp	.+4      	; 0x4256 <prvWriteMessageToBuffer+0xca>
	}
	else
	{
		xReturn = 0;
    4252:	1a 82       	std	Y+2, r1	; 0x02
    4254:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    4256:	89 81       	ldd	r24, Y+1	; 0x01
    4258:	9a 81       	ldd	r25, Y+2	; 0x02
}
    425a:	61 96       	adiw	r28, 0x11	; 17
    425c:	0f b6       	in	r0, 0x3f	; 63
    425e:	f8 94       	cli
    4260:	de bf       	out	0x3e, r29	; 62
    4262:	0f be       	out	0x3f, r0	; 63
    4264:	cd bf       	out	0x3d, r28	; 61
    4266:	cf 91       	pop	r28
    4268:	df 91       	pop	r29
    426a:	1f 91       	pop	r17
    426c:	0f 91       	pop	r16
    426e:	08 95       	ret

00004270 <xStreamBufferReceive>:

size_t xStreamBufferReceive( StreamBufferHandle_t xStreamBuffer,
							 void *pvRxData,
							 size_t xBufferLengthBytes,
							 TickType_t xTicksToWait )
{
    4270:	ef 92       	push	r14
    4272:	ff 92       	push	r15
    4274:	0f 93       	push	r16
    4276:	1f 93       	push	r17
    4278:	df 93       	push	r29
    427a:	cf 93       	push	r28
    427c:	cd b7       	in	r28, 0x3d	; 61
    427e:	de b7       	in	r29, 0x3e	; 62
    4280:	60 97       	sbiw	r28, 0x10	; 16
    4282:	0f b6       	in	r0, 0x3f	; 63
    4284:	f8 94       	cli
    4286:	de bf       	out	0x3e, r29	; 62
    4288:	0f be       	out	0x3f, r0	; 63
    428a:	cd bf       	out	0x3d, r28	; 61
    428c:	9a 87       	std	Y+10, r25	; 0x0a
    428e:	89 87       	std	Y+9, r24	; 0x09
    4290:	7c 87       	std	Y+12, r23	; 0x0c
    4292:	6b 87       	std	Y+11, r22	; 0x0b
    4294:	5e 87       	std	Y+14, r21	; 0x0e
    4296:	4d 87       	std	Y+13, r20	; 0x0d
    4298:	38 8b       	std	Y+16, r19	; 0x10
    429a:	2f 87       	std	Y+15, r18	; 0x0f
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    429c:	89 85       	ldd	r24, Y+9	; 0x09
    429e:	9a 85       	ldd	r25, Y+10	; 0x0a
    42a0:	98 87       	std	Y+8, r25	; 0x08
    42a2:	8f 83       	std	Y+7, r24	; 0x07
size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
    42a4:	1e 82       	std	Y+6, r1	; 0x06
    42a6:	1d 82       	std	Y+5, r1	; 0x05
	/* This receive function is used by both message buffers, which store
	discrete messages, and stream buffers, which store a continuous stream of
	bytes.  Discrete messages include an additional
	sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    42a8:	ef 81       	ldd	r30, Y+7	; 0x07
    42aa:	f8 85       	ldd	r31, Y+8	; 0x08
    42ac:	86 85       	ldd	r24, Z+14	; 0x0e
    42ae:	88 2f       	mov	r24, r24
    42b0:	90 e0       	ldi	r25, 0x00	; 0
    42b2:	81 70       	andi	r24, 0x01	; 1
    42b4:	90 70       	andi	r25, 0x00	; 0
    42b6:	88 23       	and	r24, r24
    42b8:	29 f0       	breq	.+10     	; 0x42c4 <xStreamBufferReceive+0x54>
	{
		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
    42ba:	82 e0       	ldi	r24, 0x02	; 2
    42bc:	90 e0       	ldi	r25, 0x00	; 0
    42be:	9a 83       	std	Y+2, r25	; 0x02
    42c0:	89 83       	std	Y+1, r24	; 0x01
    42c2:	02 c0       	rjmp	.+4      	; 0x42c8 <xStreamBufferReceive+0x58>
	}
	else
	{
		xBytesToStoreMessageLength = 0;
    42c4:	1a 82       	std	Y+2, r1	; 0x02
    42c6:	19 82       	std	Y+1, r1	; 0x01
	}

	if( xTicksToWait != ( TickType_t ) 0 )
    42c8:	8f 85       	ldd	r24, Y+15	; 0x0f
    42ca:	98 89       	ldd	r25, Y+16	; 0x10
    42cc:	00 97       	sbiw	r24, 0x00	; 0
    42ce:	09 f4       	brne	.+2      	; 0x42d2 <xStreamBufferReceive+0x62>
    42d0:	3d c0       	rjmp	.+122    	; 0x434c <xStreamBufferReceive+0xdc>
	{
		/* Checking if there is data and clearing the notification state must be
		performed atomically. */
		taskENTER_CRITICAL();
    42d2:	0f b6       	in	r0, 0x3f	; 63
    42d4:	f8 94       	cli
    42d6:	0f 92       	push	r0
		{
			xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    42d8:	8f 81       	ldd	r24, Y+7	; 0x07
    42da:	98 85       	ldd	r25, Y+8	; 0x08
    42dc:	0e 94 4d 25 	call	0x4a9a	; 0x4a9a <prvBytesInBuffer>
    42e0:	9c 83       	std	Y+4, r25	; 0x04
    42e2:	8b 83       	std	Y+3, r24	; 0x03
			/* If this function was invoked by a message buffer read then
			xBytesToStoreMessageLength holds the number of bytes used to hold
			the length of the next discrete message.  If this function was
			invoked by a stream buffer read then xBytesToStoreMessageLength will
			be 0. */
			if( xBytesAvailable <= xBytesToStoreMessageLength )
    42e4:	2b 81       	ldd	r18, Y+3	; 0x03
    42e6:	3c 81       	ldd	r19, Y+4	; 0x04
    42e8:	89 81       	ldd	r24, Y+1	; 0x01
    42ea:	9a 81       	ldd	r25, Y+2	; 0x02
    42ec:	82 17       	cp	r24, r18
    42ee:	93 07       	cpc	r25, r19
    42f0:	50 f0       	brcs	.+20     	; 0x4306 <xStreamBufferReceive+0x96>
			{
				/* Clear notification state as going to wait for data. */
				( void ) xTaskNotifyStateClear( NULL );
    42f2:	80 e0       	ldi	r24, 0x00	; 0
    42f4:	90 e0       	ldi	r25, 0x00	; 0
    42f6:	0e 94 26 32 	call	0x644c	; 0x644c <xTaskNotifyStateClear>

				/* Should only be one reader. */
				configASSERT( pxStreamBuffer->xTaskWaitingToReceive == NULL );
				pxStreamBuffer->xTaskWaitingToReceive = xTaskGetCurrentTaskHandle();
    42fa:	0e 94 7f 2e 	call	0x5cfe	; 0x5cfe <xTaskGetCurrentTaskHandle>
    42fe:	ef 81       	ldd	r30, Y+7	; 0x07
    4300:	f8 85       	ldd	r31, Y+8	; 0x08
    4302:	91 87       	std	Z+9, r25	; 0x09
    4304:	80 87       	std	Z+8, r24	; 0x08
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    4306:	0f 90       	pop	r0
    4308:	0f be       	out	0x3f, r0	; 63

		if( xBytesAvailable <= xBytesToStoreMessageLength )
    430a:	2b 81       	ldd	r18, Y+3	; 0x03
    430c:	3c 81       	ldd	r19, Y+4	; 0x04
    430e:	89 81       	ldd	r24, Y+1	; 0x01
    4310:	9a 81       	ldd	r25, Y+2	; 0x02
    4312:	82 17       	cp	r24, r18
    4314:	93 07       	cpc	r25, r19
    4316:	00 f1       	brcs	.+64     	; 0x4358 <xStreamBufferReceive+0xe8>
		{
			/* Wait for data to be available. */
			traceBLOCKING_ON_STREAM_BUFFER_RECEIVE( xStreamBuffer );
			( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
    4318:	ef 85       	ldd	r30, Y+15	; 0x0f
    431a:	f8 89       	ldd	r31, Y+16	; 0x10
    431c:	60 e0       	ldi	r22, 0x00	; 0
    431e:	70 e0       	ldi	r23, 0x00	; 0
    4320:	80 e0       	ldi	r24, 0x00	; 0
    4322:	90 e0       	ldi	r25, 0x00	; 0
    4324:	20 e0       	ldi	r18, 0x00	; 0
    4326:	30 e0       	ldi	r19, 0x00	; 0
    4328:	40 e0       	ldi	r20, 0x00	; 0
    432a:	50 e0       	ldi	r21, 0x00	; 0
    432c:	00 e0       	ldi	r16, 0x00	; 0
    432e:	10 e0       	ldi	r17, 0x00	; 0
    4330:	7f 01       	movw	r14, r30
    4332:	0e 94 2f 2f 	call	0x5e5e	; 0x5e5e <xTaskNotifyWait>
			pxStreamBuffer->xTaskWaitingToReceive = NULL;
    4336:	ef 81       	ldd	r30, Y+7	; 0x07
    4338:	f8 85       	ldd	r31, Y+8	; 0x08
    433a:	11 86       	std	Z+9, r1	; 0x09
    433c:	10 86       	std	Z+8, r1	; 0x08

			/* Recheck the data available after blocking. */
			xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    433e:	8f 81       	ldd	r24, Y+7	; 0x07
    4340:	98 85       	ldd	r25, Y+8	; 0x08
    4342:	0e 94 4d 25 	call	0x4a9a	; 0x4a9a <prvBytesInBuffer>
    4346:	9c 83       	std	Y+4, r25	; 0x04
    4348:	8b 83       	std	Y+3, r24	; 0x03
    434a:	06 c0       	rjmp	.+12     	; 0x4358 <xStreamBufferReceive+0xe8>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    434c:	8f 81       	ldd	r24, Y+7	; 0x07
    434e:	98 85       	ldd	r25, Y+8	; 0x08
    4350:	0e 94 4d 25 	call	0x4a9a	; 0x4a9a <prvBytesInBuffer>
    4354:	9c 83       	std	Y+4, r25	; 0x04
    4356:	8b 83       	std	Y+3, r24	; 0x03
	/* Whether receiving a discrete message (where xBytesToStoreMessageLength
	holds the number of bytes used to store the message length) or a stream of
	bytes (where xBytesToStoreMessageLength is zero), the number of bytes
	available must be greater than xBytesToStoreMessageLength to be able to
	read bytes from the buffer. */
	if( xBytesAvailable > xBytesToStoreMessageLength )
    4358:	2b 81       	ldd	r18, Y+3	; 0x03
    435a:	3c 81       	ldd	r19, Y+4	; 0x04
    435c:	89 81       	ldd	r24, Y+1	; 0x01
    435e:	9a 81       	ldd	r25, Y+2	; 0x02
    4360:	82 17       	cp	r24, r18
    4362:	93 07       	cpc	r25, r19
    4364:	80 f5       	brcc	.+96     	; 0x43c6 <xStreamBufferReceive+0x156>
	{
		xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable, xBytesToStoreMessageLength );
    4366:	8f 81       	ldd	r24, Y+7	; 0x07
    4368:	98 85       	ldd	r25, Y+8	; 0x08
    436a:	2b 85       	ldd	r18, Y+11	; 0x0b
    436c:	3c 85       	ldd	r19, Y+12	; 0x0c
    436e:	4d 85       	ldd	r20, Y+13	; 0x0d
    4370:	5e 85       	ldd	r21, Y+14	; 0x0e
    4372:	eb 81       	ldd	r30, Y+3	; 0x03
    4374:	fc 81       	ldd	r31, Y+4	; 0x04
    4376:	a9 81       	ldd	r26, Y+1	; 0x01
    4378:	ba 81       	ldd	r27, Y+2	; 0x02
    437a:	b9 01       	movw	r22, r18
    437c:	9f 01       	movw	r18, r30
    437e:	8d 01       	movw	r16, r26
    4380:	0e 94 bc 22 	call	0x4578	; 0x4578 <prvReadMessageFromBuffer>
    4384:	9e 83       	std	Y+6, r25	; 0x06
    4386:	8d 83       	std	Y+5, r24	; 0x05

		/* Was a task waiting for space in the buffer? */
		if( xReceivedLength != ( size_t ) 0 )
    4388:	8d 81       	ldd	r24, Y+5	; 0x05
    438a:	9e 81       	ldd	r25, Y+6	; 0x06
    438c:	00 97       	sbiw	r24, 0x00	; 0
    438e:	d9 f0       	breq	.+54     	; 0x43c6 <xStreamBufferReceive+0x156>
		{
			traceSTREAM_BUFFER_RECEIVE( xStreamBuffer, xReceivedLength );
			sbRECEIVE_COMPLETED( pxStreamBuffer );
    4390:	0e 94 ae 29 	call	0x535c	; 0x535c <vTaskSuspendAll>
    4394:	ef 81       	ldd	r30, Y+7	; 0x07
    4396:	f8 85       	ldd	r31, Y+8	; 0x08
    4398:	82 85       	ldd	r24, Z+10	; 0x0a
    439a:	93 85       	ldd	r25, Z+11	; 0x0b
    439c:	00 97       	sbiw	r24, 0x00	; 0
    439e:	89 f0       	breq	.+34     	; 0x43c2 <xStreamBufferReceive+0x152>
    43a0:	ef 81       	ldd	r30, Y+7	; 0x07
    43a2:	f8 85       	ldd	r31, Y+8	; 0x08
    43a4:	82 85       	ldd	r24, Z+10	; 0x0a
    43a6:	93 85       	ldd	r25, Z+11	; 0x0b
    43a8:	40 e0       	ldi	r20, 0x00	; 0
    43aa:	50 e0       	ldi	r21, 0x00	; 0
    43ac:	60 e0       	ldi	r22, 0x00	; 0
    43ae:	70 e0       	ldi	r23, 0x00	; 0
    43b0:	20 e0       	ldi	r18, 0x00	; 0
    43b2:	00 e0       	ldi	r16, 0x00	; 0
    43b4:	10 e0       	ldi	r17, 0x00	; 0
    43b6:	0e 94 cb 2f 	call	0x5f96	; 0x5f96 <xTaskGenericNotify>
    43ba:	ef 81       	ldd	r30, Y+7	; 0x07
    43bc:	f8 85       	ldd	r31, Y+8	; 0x08
    43be:	13 86       	std	Z+11, r1	; 0x0b
    43c0:	12 86       	std	Z+10, r1	; 0x0a
    43c2:	0e 94 ba 29 	call	0x5374	; 0x5374 <xTaskResumeAll>
	{
		traceSTREAM_BUFFER_RECEIVE_FAILED( xStreamBuffer );
		mtCOVERAGE_TEST_MARKER();
	}

	return xReceivedLength;
    43c6:	8d 81       	ldd	r24, Y+5	; 0x05
    43c8:	9e 81       	ldd	r25, Y+6	; 0x06
}
    43ca:	60 96       	adiw	r28, 0x10	; 16
    43cc:	0f b6       	in	r0, 0x3f	; 63
    43ce:	f8 94       	cli
    43d0:	de bf       	out	0x3e, r29	; 62
    43d2:	0f be       	out	0x3f, r0	; 63
    43d4:	cd bf       	out	0x3d, r28	; 61
    43d6:	cf 91       	pop	r28
    43d8:	df 91       	pop	r29
    43da:	1f 91       	pop	r17
    43dc:	0f 91       	pop	r16
    43de:	ff 90       	pop	r15
    43e0:	ef 90       	pop	r14
    43e2:	08 95       	ret

000043e4 <xStreamBufferNextMessageLengthBytes>:
/*-----------------------------------------------------------*/

size_t xStreamBufferNextMessageLengthBytes( StreamBufferHandle_t xStreamBuffer )
{
    43e4:	df 93       	push	r29
    43e6:	cf 93       	push	r28
    43e8:	cd b7       	in	r28, 0x3d	; 61
    43ea:	de b7       	in	r29, 0x3e	; 62
    43ec:	2c 97       	sbiw	r28, 0x0c	; 12
    43ee:	0f b6       	in	r0, 0x3f	; 63
    43f0:	f8 94       	cli
    43f2:	de bf       	out	0x3e, r29	; 62
    43f4:	0f be       	out	0x3f, r0	; 63
    43f6:	cd bf       	out	0x3d, r28	; 61
    43f8:	9c 87       	std	Y+12, r25	; 0x0c
    43fa:	8b 87       	std	Y+11, r24	; 0x0b
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    43fc:	8b 85       	ldd	r24, Y+11	; 0x0b
    43fe:	9c 85       	ldd	r25, Y+12	; 0x0c
    4400:	98 87       	std	Y+8, r25	; 0x08
    4402:	8f 83       	std	Y+7, r24	; 0x07
configMESSAGE_BUFFER_LENGTH_TYPE xTempReturn;

	configASSERT( pxStreamBuffer );

	/* Ensure the stream buffer is being used as a message buffer. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    4404:	ef 81       	ldd	r30, Y+7	; 0x07
    4406:	f8 85       	ldd	r31, Y+8	; 0x08
    4408:	86 85       	ldd	r24, Z+14	; 0x0e
    440a:	88 2f       	mov	r24, r24
    440c:	90 e0       	ldi	r25, 0x00	; 0
    440e:	81 70       	andi	r24, 0x01	; 1
    4410:	90 70       	andi	r25, 0x00	; 0
    4412:	88 23       	and	r24, r24
    4414:	61 f1       	breq	.+88     	; 0x446e <xStreamBufferNextMessageLengthBytes+0x8a>
	{
		xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    4416:	8f 81       	ldd	r24, Y+7	; 0x07
    4418:	98 85       	ldd	r25, Y+8	; 0x08
    441a:	0e 94 4d 25 	call	0x4a9a	; 0x4a9a <prvBytesInBuffer>
    441e:	9c 83       	std	Y+4, r25	; 0x04
    4420:	8b 83       	std	Y+3, r24	; 0x03
		if( xBytesAvailable > sbBYTES_TO_STORE_MESSAGE_LENGTH )
    4422:	8b 81       	ldd	r24, Y+3	; 0x03
    4424:	9c 81       	ldd	r25, Y+4	; 0x04
    4426:	83 30       	cpi	r24, 0x03	; 3
    4428:	91 05       	cpc	r25, r1
    442a:	f0 f0       	brcs	.+60     	; 0x4468 <xStreamBufferNextMessageLengthBytes+0x84>
			required to hold the length of the next message, so another message
			is available.  Return its length without removing the length bytes
			from the buffer.  A copy of the tail is stored so the buffer can be
			returned to its prior state as the message is not actually being
			removed from the buffer. */
			xOriginalTail = pxStreamBuffer->xTail;
    442c:	ef 81       	ldd	r30, Y+7	; 0x07
    442e:	f8 85       	ldd	r31, Y+8	; 0x08
    4430:	80 81       	ld	r24, Z
    4432:	91 81       	ldd	r25, Z+1	; 0x01
    4434:	9a 83       	std	Y+2, r25	; 0x02
    4436:	89 83       	std	Y+1, r24	; 0x01
			( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempReturn, sbBYTES_TO_STORE_MESSAGE_LENGTH, xBytesAvailable );
    4438:	9e 01       	movw	r18, r28
    443a:	27 5f       	subi	r18, 0xF7	; 247
    443c:	3f 4f       	sbci	r19, 0xFF	; 255
    443e:	8f 81       	ldd	r24, Y+7	; 0x07
    4440:	98 85       	ldd	r25, Y+8	; 0x08
    4442:	eb 81       	ldd	r30, Y+3	; 0x03
    4444:	fc 81       	ldd	r31, Y+4	; 0x04
    4446:	b9 01       	movw	r22, r18
    4448:	42 e0       	ldi	r20, 0x02	; 2
    444a:	50 e0       	ldi	r21, 0x00	; 0
    444c:	9f 01       	movw	r18, r30
    444e:	0e 94 a0 24 	call	0x4940	; 0x4940 <prvReadBytesFromBuffer>
			xReturn = ( size_t ) xTempReturn;
    4452:	89 85       	ldd	r24, Y+9	; 0x09
    4454:	9a 85       	ldd	r25, Y+10	; 0x0a
    4456:	9e 83       	std	Y+6, r25	; 0x06
    4458:	8d 83       	std	Y+5, r24	; 0x05
			pxStreamBuffer->xTail = xOriginalTail;
    445a:	ef 81       	ldd	r30, Y+7	; 0x07
    445c:	f8 85       	ldd	r31, Y+8	; 0x08
    445e:	89 81       	ldd	r24, Y+1	; 0x01
    4460:	9a 81       	ldd	r25, Y+2	; 0x02
    4462:	91 83       	std	Z+1, r25	; 0x01
    4464:	80 83       	st	Z, r24
    4466:	05 c0       	rjmp	.+10     	; 0x4472 <xStreamBufferNextMessageLengthBytes+0x8e>
			/* The minimum amount of bytes in a message buffer is
			( sbBYTES_TO_STORE_MESSAGE_LENGTH + 1 ), so if xBytesAvailable is
			less than sbBYTES_TO_STORE_MESSAGE_LENGTH the only other valid
			value is 0. */
			configASSERT( xBytesAvailable == 0 );
			xReturn = 0;
    4468:	1e 82       	std	Y+6, r1	; 0x06
    446a:	1d 82       	std	Y+5, r1	; 0x05
    446c:	02 c0       	rjmp	.+4      	; 0x4472 <xStreamBufferNextMessageLengthBytes+0x8e>
		}
	}
	else
	{
		xReturn = 0;
    446e:	1e 82       	std	Y+6, r1	; 0x06
    4470:	1d 82       	std	Y+5, r1	; 0x05
	}

	return xReturn;
    4472:	8d 81       	ldd	r24, Y+5	; 0x05
    4474:	9e 81       	ldd	r25, Y+6	; 0x06
}
    4476:	2c 96       	adiw	r28, 0x0c	; 12
    4478:	0f b6       	in	r0, 0x3f	; 63
    447a:	f8 94       	cli
    447c:	de bf       	out	0x3e, r29	; 62
    447e:	0f be       	out	0x3f, r0	; 63
    4480:	cd bf       	out	0x3d, r28	; 61
    4482:	cf 91       	pop	r28
    4484:	df 91       	pop	r29
    4486:	08 95       	ret

00004488 <xStreamBufferReceiveFromISR>:

size_t xStreamBufferReceiveFromISR( StreamBufferHandle_t xStreamBuffer,
									void *pvRxData,
									size_t xBufferLengthBytes,
									BaseType_t * const pxHigherPriorityTaskWoken )
{
    4488:	ef 92       	push	r14
    448a:	ff 92       	push	r15
    448c:	0f 93       	push	r16
    448e:	1f 93       	push	r17
    4490:	df 93       	push	r29
    4492:	cf 93       	push	r28
    4494:	cd b7       	in	r28, 0x3d	; 61
    4496:	de b7       	in	r29, 0x3e	; 62
    4498:	61 97       	sbiw	r28, 0x11	; 17
    449a:	0f b6       	in	r0, 0x3f	; 63
    449c:	f8 94       	cli
    449e:	de bf       	out	0x3e, r29	; 62
    44a0:	0f be       	out	0x3f, r0	; 63
    44a2:	cd bf       	out	0x3d, r28	; 61
    44a4:	9b 87       	std	Y+11, r25	; 0x0b
    44a6:	8a 87       	std	Y+10, r24	; 0x0a
    44a8:	7d 87       	std	Y+13, r23	; 0x0d
    44aa:	6c 87       	std	Y+12, r22	; 0x0c
    44ac:	5f 87       	std	Y+15, r21	; 0x0f
    44ae:	4e 87       	std	Y+14, r20	; 0x0e
    44b0:	39 8b       	std	Y+17, r19	; 0x11
    44b2:	28 8b       	std	Y+16, r18	; 0x10
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    44b4:	8a 85       	ldd	r24, Y+10	; 0x0a
    44b6:	9b 85       	ldd	r25, Y+11	; 0x0b
    44b8:	99 87       	std	Y+9, r25	; 0x09
    44ba:	88 87       	std	Y+8, r24	; 0x08
size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
    44bc:	1f 82       	std	Y+7, r1	; 0x07
    44be:	1e 82       	std	Y+6, r1	; 0x06
	/* This receive function is used by both message buffers, which store
	discrete messages, and stream buffers, which store a continuous stream of
	bytes.  Discrete messages include an additional
	sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    44c0:	e8 85       	ldd	r30, Y+8	; 0x08
    44c2:	f9 85       	ldd	r31, Y+9	; 0x09
    44c4:	86 85       	ldd	r24, Z+14	; 0x0e
    44c6:	88 2f       	mov	r24, r24
    44c8:	90 e0       	ldi	r25, 0x00	; 0
    44ca:	81 70       	andi	r24, 0x01	; 1
    44cc:	90 70       	andi	r25, 0x00	; 0
    44ce:	88 23       	and	r24, r24
    44d0:	29 f0       	breq	.+10     	; 0x44dc <xStreamBufferReceiveFromISR+0x54>
	{
		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
    44d2:	82 e0       	ldi	r24, 0x02	; 2
    44d4:	90 e0       	ldi	r25, 0x00	; 0
    44d6:	9b 83       	std	Y+3, r25	; 0x03
    44d8:	8a 83       	std	Y+2, r24	; 0x02
    44da:	02 c0       	rjmp	.+4      	; 0x44e0 <xStreamBufferReceiveFromISR+0x58>
	}
	else
	{
		xBytesToStoreMessageLength = 0;
    44dc:	1b 82       	std	Y+3, r1	; 0x03
    44de:	1a 82       	std	Y+2, r1	; 0x02
	}

	xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    44e0:	88 85       	ldd	r24, Y+8	; 0x08
    44e2:	99 85       	ldd	r25, Y+9	; 0x09
    44e4:	0e 94 4d 25 	call	0x4a9a	; 0x4a9a <prvBytesInBuffer>
    44e8:	9d 83       	std	Y+5, r25	; 0x05
    44ea:	8c 83       	std	Y+4, r24	; 0x04
	/* Whether receiving a discrete message (where xBytesToStoreMessageLength
	holds the number of bytes used to store the message length) or a stream of
	bytes (where xBytesToStoreMessageLength is zero), the number of bytes
	available must be greater than xBytesToStoreMessageLength to be able to
	read bytes from the buffer. */
	if( xBytesAvailable > xBytesToStoreMessageLength )
    44ec:	2c 81       	ldd	r18, Y+4	; 0x04
    44ee:	3d 81       	ldd	r19, Y+5	; 0x05
    44f0:	8a 81       	ldd	r24, Y+2	; 0x02
    44f2:	9b 81       	ldd	r25, Y+3	; 0x03
    44f4:	82 17       	cp	r24, r18
    44f6:	93 07       	cpc	r25, r19
    44f8:	80 f5       	brcc	.+96     	; 0x455a <xStreamBufferReceiveFromISR+0xd2>
	{
		xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable, xBytesToStoreMessageLength );
    44fa:	88 85       	ldd	r24, Y+8	; 0x08
    44fc:	99 85       	ldd	r25, Y+9	; 0x09
    44fe:	2c 85       	ldd	r18, Y+12	; 0x0c
    4500:	3d 85       	ldd	r19, Y+13	; 0x0d
    4502:	4e 85       	ldd	r20, Y+14	; 0x0e
    4504:	5f 85       	ldd	r21, Y+15	; 0x0f
    4506:	ec 81       	ldd	r30, Y+4	; 0x04
    4508:	fd 81       	ldd	r31, Y+5	; 0x05
    450a:	aa 81       	ldd	r26, Y+2	; 0x02
    450c:	bb 81       	ldd	r27, Y+3	; 0x03
    450e:	b9 01       	movw	r22, r18
    4510:	9f 01       	movw	r18, r30
    4512:	8d 01       	movw	r16, r26
    4514:	0e 94 bc 22 	call	0x4578	; 0x4578 <prvReadMessageFromBuffer>
    4518:	9f 83       	std	Y+7, r25	; 0x07
    451a:	8e 83       	std	Y+6, r24	; 0x06

		/* Was a task waiting for space in the buffer? */
		if( xReceivedLength != ( size_t ) 0 )
    451c:	8e 81       	ldd	r24, Y+6	; 0x06
    451e:	9f 81       	ldd	r25, Y+7	; 0x07
    4520:	00 97       	sbiw	r24, 0x00	; 0
    4522:	d9 f0       	breq	.+54     	; 0x455a <xStreamBufferReceiveFromISR+0xd2>
		{
			sbRECEIVE_COMPLETED_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
    4524:	19 82       	std	Y+1, r1	; 0x01
    4526:	e8 85       	ldd	r30, Y+8	; 0x08
    4528:	f9 85       	ldd	r31, Y+9	; 0x09
    452a:	82 85       	ldd	r24, Z+10	; 0x0a
    452c:	93 85       	ldd	r25, Z+11	; 0x0b
    452e:	00 97       	sbiw	r24, 0x00	; 0
    4530:	a1 f0       	breq	.+40     	; 0x455a <xStreamBufferReceiveFromISR+0xd2>
    4532:	e8 85       	ldd	r30, Y+8	; 0x08
    4534:	f9 85       	ldd	r31, Y+9	; 0x09
    4536:	82 85       	ldd	r24, Z+10	; 0x0a
    4538:	93 85       	ldd	r25, Z+11	; 0x0b
    453a:	e8 89       	ldd	r30, Y+16	; 0x10
    453c:	f9 89       	ldd	r31, Y+17	; 0x11
    453e:	40 e0       	ldi	r20, 0x00	; 0
    4540:	50 e0       	ldi	r21, 0x00	; 0
    4542:	60 e0       	ldi	r22, 0x00	; 0
    4544:	70 e0       	ldi	r23, 0x00	; 0
    4546:	20 e0       	ldi	r18, 0x00	; 0
    4548:	00 e0       	ldi	r16, 0x00	; 0
    454a:	10 e0       	ldi	r17, 0x00	; 0
    454c:	7f 01       	movw	r14, r30
    454e:	0e 94 a8 30 	call	0x6150	; 0x6150 <xTaskGenericNotifyFromISR>
    4552:	e8 85       	ldd	r30, Y+8	; 0x08
    4554:	f9 85       	ldd	r31, Y+9	; 0x09
    4556:	13 86       	std	Z+11, r1	; 0x0b
    4558:	12 86       	std	Z+10, r1	; 0x0a
		mtCOVERAGE_TEST_MARKER();
	}

	traceSTREAM_BUFFER_RECEIVE_FROM_ISR( xStreamBuffer, xReceivedLength );

	return xReceivedLength;
    455a:	8e 81       	ldd	r24, Y+6	; 0x06
    455c:	9f 81       	ldd	r25, Y+7	; 0x07
}
    455e:	61 96       	adiw	r28, 0x11	; 17
    4560:	0f b6       	in	r0, 0x3f	; 63
    4562:	f8 94       	cli
    4564:	de bf       	out	0x3e, r29	; 62
    4566:	0f be       	out	0x3f, r0	; 63
    4568:	cd bf       	out	0x3d, r28	; 61
    456a:	cf 91       	pop	r28
    456c:	df 91       	pop	r29
    456e:	1f 91       	pop	r17
    4570:	0f 91       	pop	r16
    4572:	ff 90       	pop	r15
    4574:	ef 90       	pop	r14
    4576:	08 95       	ret

00004578 <prvReadMessageFromBuffer>:
static size_t prvReadMessageFromBuffer( StreamBuffer_t *pxStreamBuffer,
										void *pvRxData,
										size_t xBufferLengthBytes,
										size_t xBytesAvailable,
										size_t xBytesToStoreMessageLength )
{
    4578:	0f 93       	push	r16
    457a:	1f 93       	push	r17
    457c:	df 93       	push	r29
    457e:	cf 93       	push	r28
    4580:	cd b7       	in	r28, 0x3d	; 61
    4582:	de b7       	in	r29, 0x3e	; 62
    4584:	62 97       	sbiw	r28, 0x12	; 18
    4586:	0f b6       	in	r0, 0x3f	; 63
    4588:	f8 94       	cli
    458a:	de bf       	out	0x3e, r29	; 62
    458c:	0f be       	out	0x3f, r0	; 63
    458e:	cd bf       	out	0x3d, r28	; 61
    4590:	9a 87       	std	Y+10, r25	; 0x0a
    4592:	89 87       	std	Y+9, r24	; 0x09
    4594:	7c 87       	std	Y+12, r23	; 0x0c
    4596:	6b 87       	std	Y+11, r22	; 0x0b
    4598:	5e 87       	std	Y+14, r21	; 0x0e
    459a:	4d 87       	std	Y+13, r20	; 0x0d
    459c:	38 8b       	std	Y+16, r19	; 0x10
    459e:	2f 87       	std	Y+15, r18	; 0x0f
    45a0:	1a 8b       	std	Y+18, r17	; 0x12
    45a2:	09 8b       	std	Y+17, r16	; 0x11
size_t xOriginalTail, xReceivedLength, xNextMessageLength;
configMESSAGE_BUFFER_LENGTH_TYPE xTempNextMessageLength;

	if( xBytesToStoreMessageLength != ( size_t ) 0 )
    45a4:	89 89       	ldd	r24, Y+17	; 0x11
    45a6:	9a 89       	ldd	r25, Y+18	; 0x12
    45a8:	00 97       	sbiw	r24, 0x00	; 0
    45aa:	91 f1       	breq	.+100    	; 0x4610 <prvReadMessageFromBuffer+0x98>
	{
		/* A discrete message is being received.  First receive the length
		of the message.  A copy of the tail is stored so the buffer can be
		returned to its prior state if the length of the message is too
		large for the provided buffer. */
		xOriginalTail = pxStreamBuffer->xTail;
    45ac:	e9 85       	ldd	r30, Y+9	; 0x09
    45ae:	fa 85       	ldd	r31, Y+10	; 0x0a
    45b0:	80 81       	ld	r24, Z
    45b2:	91 81       	ldd	r25, Z+1	; 0x01
    45b4:	9e 83       	std	Y+6, r25	; 0x06
    45b6:	8d 83       	std	Y+5, r24	; 0x05
		( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempNextMessageLength, xBytesToStoreMessageLength, xBytesAvailable );
    45b8:	ae 01       	movw	r20, r28
    45ba:	49 5f       	subi	r20, 0xF9	; 249
    45bc:	5f 4f       	sbci	r21, 0xFF	; 255
    45be:	89 85       	ldd	r24, Y+9	; 0x09
    45c0:	9a 85       	ldd	r25, Y+10	; 0x0a
    45c2:	29 89       	ldd	r18, Y+17	; 0x11
    45c4:	3a 89       	ldd	r19, Y+18	; 0x12
    45c6:	ef 85       	ldd	r30, Y+15	; 0x0f
    45c8:	f8 89       	ldd	r31, Y+16	; 0x10
    45ca:	ba 01       	movw	r22, r20
    45cc:	a9 01       	movw	r20, r18
    45ce:	9f 01       	movw	r18, r30
    45d0:	0e 94 a0 24 	call	0x4940	; 0x4940 <prvReadBytesFromBuffer>
		xNextMessageLength = ( size_t ) xTempNextMessageLength;
    45d4:	8f 81       	ldd	r24, Y+7	; 0x07
    45d6:	98 85       	ldd	r25, Y+8	; 0x08
    45d8:	9a 83       	std	Y+2, r25	; 0x02
    45da:	89 83       	std	Y+1, r24	; 0x01

		/* Reduce the number of bytes available by the number of bytes just
		read out. */
		xBytesAvailable -= xBytesToStoreMessageLength;
    45dc:	2f 85       	ldd	r18, Y+15	; 0x0f
    45de:	38 89       	ldd	r19, Y+16	; 0x10
    45e0:	89 89       	ldd	r24, Y+17	; 0x11
    45e2:	9a 89       	ldd	r25, Y+18	; 0x12
    45e4:	a9 01       	movw	r20, r18
    45e6:	48 1b       	sub	r20, r24
    45e8:	59 0b       	sbc	r21, r25
    45ea:	ca 01       	movw	r24, r20
    45ec:	98 8b       	std	Y+16, r25	; 0x10
    45ee:	8f 87       	std	Y+15, r24	; 0x0f

		/* Check there is enough space in the buffer provided by the
		user. */
		if( xNextMessageLength > xBufferLengthBytes )
    45f0:	29 81       	ldd	r18, Y+1	; 0x01
    45f2:	3a 81       	ldd	r19, Y+2	; 0x02
    45f4:	8d 85       	ldd	r24, Y+13	; 0x0d
    45f6:	9e 85       	ldd	r25, Y+14	; 0x0e
    45f8:	82 17       	cp	r24, r18
    45fa:	93 07       	cpc	r25, r19
    45fc:	68 f4       	brcc	.+26     	; 0x4618 <prvReadMessageFromBuffer+0xa0>
		{
			/* The user has provided insufficient space to read the message
			so return the buffer to its previous state (so the length of
			the message is in the buffer again). */
			pxStreamBuffer->xTail = xOriginalTail;
    45fe:	e9 85       	ldd	r30, Y+9	; 0x09
    4600:	fa 85       	ldd	r31, Y+10	; 0x0a
    4602:	8d 81       	ldd	r24, Y+5	; 0x05
    4604:	9e 81       	ldd	r25, Y+6	; 0x06
    4606:	91 83       	std	Z+1, r25	; 0x01
    4608:	80 83       	st	Z, r24
			xNextMessageLength = 0;
    460a:	1a 82       	std	Y+2, r1	; 0x02
    460c:	19 82       	std	Y+1, r1	; 0x01
    460e:	04 c0       	rjmp	.+8      	; 0x4618 <prvReadMessageFromBuffer+0xa0>
	}
	else
	{
		/* A stream of bytes is being received (as opposed to a discrete
		message), so read as many bytes as possible. */
		xNextMessageLength = xBufferLengthBytes;
    4610:	8d 85       	ldd	r24, Y+13	; 0x0d
    4612:	9e 85       	ldd	r25, Y+14	; 0x0e
    4614:	9a 83       	std	Y+2, r25	; 0x02
    4616:	89 83       	std	Y+1, r24	; 0x01
	}

	/* Read the actual data. */
	xReceivedLength = prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) pvRxData, xNextMessageLength, xBytesAvailable ); /*lint !e9079 Data storage area is implemented as uint8_t array for ease of sizing, indexing and alignment. */
    4618:	4b 85       	ldd	r20, Y+11	; 0x0b
    461a:	5c 85       	ldd	r21, Y+12	; 0x0c
    461c:	89 85       	ldd	r24, Y+9	; 0x09
    461e:	9a 85       	ldd	r25, Y+10	; 0x0a
    4620:	29 81       	ldd	r18, Y+1	; 0x01
    4622:	3a 81       	ldd	r19, Y+2	; 0x02
    4624:	ef 85       	ldd	r30, Y+15	; 0x0f
    4626:	f8 89       	ldd	r31, Y+16	; 0x10
    4628:	ba 01       	movw	r22, r20
    462a:	a9 01       	movw	r20, r18
    462c:	9f 01       	movw	r18, r30
    462e:	0e 94 a0 24 	call	0x4940	; 0x4940 <prvReadBytesFromBuffer>
    4632:	9c 83       	std	Y+4, r25	; 0x04
    4634:	8b 83       	std	Y+3, r24	; 0x03

	return xReceivedLength;
    4636:	8b 81       	ldd	r24, Y+3	; 0x03
    4638:	9c 81       	ldd	r25, Y+4	; 0x04
}
    463a:	62 96       	adiw	r28, 0x12	; 18
    463c:	0f b6       	in	r0, 0x3f	; 63
    463e:	f8 94       	cli
    4640:	de bf       	out	0x3e, r29	; 62
    4642:	0f be       	out	0x3f, r0	; 63
    4644:	cd bf       	out	0x3d, r28	; 61
    4646:	cf 91       	pop	r28
    4648:	df 91       	pop	r29
    464a:	1f 91       	pop	r17
    464c:	0f 91       	pop	r16
    464e:	08 95       	ret

00004650 <xStreamBufferIsEmpty>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferIsEmpty( StreamBufferHandle_t xStreamBuffer )
{
    4650:	df 93       	push	r29
    4652:	cf 93       	push	r28
    4654:	cd b7       	in	r28, 0x3d	; 61
    4656:	de b7       	in	r29, 0x3e	; 62
    4658:	27 97       	sbiw	r28, 0x07	; 7
    465a:	0f b6       	in	r0, 0x3f	; 63
    465c:	f8 94       	cli
    465e:	de bf       	out	0x3e, r29	; 62
    4660:	0f be       	out	0x3f, r0	; 63
    4662:	cd bf       	out	0x3d, r28	; 61
    4664:	9f 83       	std	Y+7, r25	; 0x07
    4666:	8e 83       	std	Y+6, r24	; 0x06
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    4668:	8e 81       	ldd	r24, Y+6	; 0x06
    466a:	9f 81       	ldd	r25, Y+7	; 0x07
    466c:	9d 83       	std	Y+5, r25	; 0x05
    466e:	8c 83       	std	Y+4, r24	; 0x04
size_t xTail;

	configASSERT( pxStreamBuffer );

	/* True if no bytes are available. */
	xTail = pxStreamBuffer->xTail;
    4670:	ec 81       	ldd	r30, Y+4	; 0x04
    4672:	fd 81       	ldd	r31, Y+5	; 0x05
    4674:	80 81       	ld	r24, Z
    4676:	91 81       	ldd	r25, Z+1	; 0x01
    4678:	9a 83       	std	Y+2, r25	; 0x02
    467a:	89 83       	std	Y+1, r24	; 0x01
	if( pxStreamBuffer->xHead == xTail )
    467c:	ec 81       	ldd	r30, Y+4	; 0x04
    467e:	fd 81       	ldd	r31, Y+5	; 0x05
    4680:	22 81       	ldd	r18, Z+2	; 0x02
    4682:	33 81       	ldd	r19, Z+3	; 0x03
    4684:	89 81       	ldd	r24, Y+1	; 0x01
    4686:	9a 81       	ldd	r25, Y+2	; 0x02
    4688:	28 17       	cp	r18, r24
    468a:	39 07       	cpc	r19, r25
    468c:	19 f4       	brne	.+6      	; 0x4694 <xStreamBufferIsEmpty+0x44>
	{
		xReturn = pdTRUE;
    468e:	81 e0       	ldi	r24, 0x01	; 1
    4690:	8b 83       	std	Y+3, r24	; 0x03
    4692:	01 c0       	rjmp	.+2      	; 0x4696 <xStreamBufferIsEmpty+0x46>
	}
	else
	{
		xReturn = pdFALSE;
    4694:	1b 82       	std	Y+3, r1	; 0x03
	}

	return xReturn;
    4696:	8b 81       	ldd	r24, Y+3	; 0x03
}
    4698:	27 96       	adiw	r28, 0x07	; 7
    469a:	0f b6       	in	r0, 0x3f	; 63
    469c:	f8 94       	cli
    469e:	de bf       	out	0x3e, r29	; 62
    46a0:	0f be       	out	0x3f, r0	; 63
    46a2:	cd bf       	out	0x3d, r28	; 61
    46a4:	cf 91       	pop	r28
    46a6:	df 91       	pop	r29
    46a8:	08 95       	ret

000046aa <xStreamBufferIsFull>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferIsFull( StreamBufferHandle_t xStreamBuffer )
{
    46aa:	df 93       	push	r29
    46ac:	cf 93       	push	r28
    46ae:	cd b7       	in	r28, 0x3d	; 61
    46b0:	de b7       	in	r29, 0x3e	; 62
    46b2:	27 97       	sbiw	r28, 0x07	; 7
    46b4:	0f b6       	in	r0, 0x3f	; 63
    46b6:	f8 94       	cli
    46b8:	de bf       	out	0x3e, r29	; 62
    46ba:	0f be       	out	0x3f, r0	; 63
    46bc:	cd bf       	out	0x3d, r28	; 61
    46be:	9f 83       	std	Y+7, r25	; 0x07
    46c0:	8e 83       	std	Y+6, r24	; 0x06
BaseType_t xReturn;
size_t xBytesToStoreMessageLength;
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    46c2:	8e 81       	ldd	r24, Y+6	; 0x06
    46c4:	9f 81       	ldd	r25, Y+7	; 0x07
    46c6:	9a 83       	std	Y+2, r25	; 0x02
    46c8:	89 83       	std	Y+1, r24	; 0x01

	/* This generic version of the receive function is used by both message
	buffers, which store discrete messages, and stream buffers, which store a
	continuous stream of bytes.  Discrete messages include an additional
	sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    46ca:	e9 81       	ldd	r30, Y+1	; 0x01
    46cc:	fa 81       	ldd	r31, Y+2	; 0x02
    46ce:	86 85       	ldd	r24, Z+14	; 0x0e
    46d0:	88 2f       	mov	r24, r24
    46d2:	90 e0       	ldi	r25, 0x00	; 0
    46d4:	81 70       	andi	r24, 0x01	; 1
    46d6:	90 70       	andi	r25, 0x00	; 0
    46d8:	88 23       	and	r24, r24
    46da:	29 f0       	breq	.+10     	; 0x46e6 <xStreamBufferIsFull+0x3c>
	{
		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
    46dc:	82 e0       	ldi	r24, 0x02	; 2
    46de:	90 e0       	ldi	r25, 0x00	; 0
    46e0:	9c 83       	std	Y+4, r25	; 0x04
    46e2:	8b 83       	std	Y+3, r24	; 0x03
    46e4:	02 c0       	rjmp	.+4      	; 0x46ea <xStreamBufferIsFull+0x40>
	}
	else
	{
		xBytesToStoreMessageLength = 0;
    46e6:	1c 82       	std	Y+4, r1	; 0x04
    46e8:	1b 82       	std	Y+3, r1	; 0x03
	}

	/* True if the available space equals zero. */
	if( xStreamBufferSpacesAvailable( xStreamBuffer ) <= xBytesToStoreMessageLength )
    46ea:	8e 81       	ldd	r24, Y+6	; 0x06
    46ec:	9f 81       	ldd	r25, Y+7	; 0x07
    46ee:	0e 94 1d 1f 	call	0x3e3a	; 0x3e3a <xStreamBufferSpacesAvailable>
    46f2:	9c 01       	movw	r18, r24
    46f4:	8b 81       	ldd	r24, Y+3	; 0x03
    46f6:	9c 81       	ldd	r25, Y+4	; 0x04
    46f8:	82 17       	cp	r24, r18
    46fa:	93 07       	cpc	r25, r19
    46fc:	18 f0       	brcs	.+6      	; 0x4704 <xStreamBufferIsFull+0x5a>
	{
		xReturn = pdTRUE;
    46fe:	81 e0       	ldi	r24, 0x01	; 1
    4700:	8d 83       	std	Y+5, r24	; 0x05
    4702:	01 c0       	rjmp	.+2      	; 0x4706 <xStreamBufferIsFull+0x5c>
	}
	else
	{
		xReturn = pdFALSE;
    4704:	1d 82       	std	Y+5, r1	; 0x05
	}

	return xReturn;
    4706:	8d 81       	ldd	r24, Y+5	; 0x05
}
    4708:	27 96       	adiw	r28, 0x07	; 7
    470a:	0f b6       	in	r0, 0x3f	; 63
    470c:	f8 94       	cli
    470e:	de bf       	out	0x3e, r29	; 62
    4710:	0f be       	out	0x3f, r0	; 63
    4712:	cd bf       	out	0x3d, r28	; 61
    4714:	cf 91       	pop	r28
    4716:	df 91       	pop	r29
    4718:	08 95       	ret

0000471a <xStreamBufferSendCompletedFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferSendCompletedFromISR( StreamBufferHandle_t xStreamBuffer, BaseType_t *pxHigherPriorityTaskWoken )
{
    471a:	ef 92       	push	r14
    471c:	ff 92       	push	r15
    471e:	0f 93       	push	r16
    4720:	1f 93       	push	r17
    4722:	df 93       	push	r29
    4724:	cf 93       	push	r28
    4726:	cd b7       	in	r28, 0x3d	; 61
    4728:	de b7       	in	r29, 0x3e	; 62
    472a:	28 97       	sbiw	r28, 0x08	; 8
    472c:	0f b6       	in	r0, 0x3f	; 63
    472e:	f8 94       	cli
    4730:	de bf       	out	0x3e, r29	; 62
    4732:	0f be       	out	0x3f, r0	; 63
    4734:	cd bf       	out	0x3d, r28	; 61
    4736:	9e 83       	std	Y+6, r25	; 0x06
    4738:	8d 83       	std	Y+5, r24	; 0x05
    473a:	78 87       	std	Y+8, r23	; 0x08
    473c:	6f 83       	std	Y+7, r22	; 0x07
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    473e:	8d 81       	ldd	r24, Y+5	; 0x05
    4740:	9e 81       	ldd	r25, Y+6	; 0x06
    4742:	9c 83       	std	Y+4, r25	; 0x04
    4744:	8b 83       	std	Y+3, r24	; 0x03
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;

	configASSERT( pxStreamBuffer );

	uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
    4746:	19 82       	std	Y+1, r1	; 0x01
	{
		if( ( pxStreamBuffer )->xTaskWaitingToReceive != NULL )
    4748:	eb 81       	ldd	r30, Y+3	; 0x03
    474a:	fc 81       	ldd	r31, Y+4	; 0x04
    474c:	80 85       	ldd	r24, Z+8	; 0x08
    474e:	91 85       	ldd	r25, Z+9	; 0x09
    4750:	00 97       	sbiw	r24, 0x00	; 0
    4752:	b9 f0       	breq	.+46     	; 0x4782 <xStreamBufferSendCompletedFromISR+0x68>
		{
			( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToReceive,
    4754:	eb 81       	ldd	r30, Y+3	; 0x03
    4756:	fc 81       	ldd	r31, Y+4	; 0x04
    4758:	80 85       	ldd	r24, Z+8	; 0x08
    475a:	91 85       	ldd	r25, Z+9	; 0x09
    475c:	ef 81       	ldd	r30, Y+7	; 0x07
    475e:	f8 85       	ldd	r31, Y+8	; 0x08
    4760:	40 e0       	ldi	r20, 0x00	; 0
    4762:	50 e0       	ldi	r21, 0x00	; 0
    4764:	60 e0       	ldi	r22, 0x00	; 0
    4766:	70 e0       	ldi	r23, 0x00	; 0
    4768:	20 e0       	ldi	r18, 0x00	; 0
    476a:	00 e0       	ldi	r16, 0x00	; 0
    476c:	10 e0       	ldi	r17, 0x00	; 0
    476e:	7f 01       	movw	r14, r30
    4770:	0e 94 a8 30 	call	0x6150	; 0x6150 <xTaskGenericNotifyFromISR>
										 ( uint32_t ) 0,
										 eNoAction,
										 pxHigherPriorityTaskWoken );
			( pxStreamBuffer )->xTaskWaitingToReceive = NULL;
    4774:	eb 81       	ldd	r30, Y+3	; 0x03
    4776:	fc 81       	ldd	r31, Y+4	; 0x04
    4778:	11 86       	std	Z+9, r1	; 0x09
    477a:	10 86       	std	Z+8, r1	; 0x08
			xReturn = pdTRUE;
    477c:	81 e0       	ldi	r24, 0x01	; 1
    477e:	8a 83       	std	Y+2, r24	; 0x02
    4780:	01 c0       	rjmp	.+2      	; 0x4784 <xStreamBufferSendCompletedFromISR+0x6a>
		}
		else
		{
			xReturn = pdFALSE;
    4782:	1a 82       	std	Y+2, r1	; 0x02
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    4784:	8a 81       	ldd	r24, Y+2	; 0x02
}
    4786:	28 96       	adiw	r28, 0x08	; 8
    4788:	0f b6       	in	r0, 0x3f	; 63
    478a:	f8 94       	cli
    478c:	de bf       	out	0x3e, r29	; 62
    478e:	0f be       	out	0x3f, r0	; 63
    4790:	cd bf       	out	0x3d, r28	; 61
    4792:	cf 91       	pop	r28
    4794:	df 91       	pop	r29
    4796:	1f 91       	pop	r17
    4798:	0f 91       	pop	r16
    479a:	ff 90       	pop	r15
    479c:	ef 90       	pop	r14
    479e:	08 95       	ret

000047a0 <xStreamBufferReceiveCompletedFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferReceiveCompletedFromISR( StreamBufferHandle_t xStreamBuffer, BaseType_t *pxHigherPriorityTaskWoken )
{
    47a0:	ef 92       	push	r14
    47a2:	ff 92       	push	r15
    47a4:	0f 93       	push	r16
    47a6:	1f 93       	push	r17
    47a8:	df 93       	push	r29
    47aa:	cf 93       	push	r28
    47ac:	cd b7       	in	r28, 0x3d	; 61
    47ae:	de b7       	in	r29, 0x3e	; 62
    47b0:	28 97       	sbiw	r28, 0x08	; 8
    47b2:	0f b6       	in	r0, 0x3f	; 63
    47b4:	f8 94       	cli
    47b6:	de bf       	out	0x3e, r29	; 62
    47b8:	0f be       	out	0x3f, r0	; 63
    47ba:	cd bf       	out	0x3d, r28	; 61
    47bc:	9e 83       	std	Y+6, r25	; 0x06
    47be:	8d 83       	std	Y+5, r24	; 0x05
    47c0:	78 87       	std	Y+8, r23	; 0x08
    47c2:	6f 83       	std	Y+7, r22	; 0x07
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    47c4:	8d 81       	ldd	r24, Y+5	; 0x05
    47c6:	9e 81       	ldd	r25, Y+6	; 0x06
    47c8:	9c 83       	std	Y+4, r25	; 0x04
    47ca:	8b 83       	std	Y+3, r24	; 0x03
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;

	configASSERT( pxStreamBuffer );

	uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
    47cc:	19 82       	std	Y+1, r1	; 0x01
	{
		if( ( pxStreamBuffer )->xTaskWaitingToSend != NULL )
    47ce:	eb 81       	ldd	r30, Y+3	; 0x03
    47d0:	fc 81       	ldd	r31, Y+4	; 0x04
    47d2:	82 85       	ldd	r24, Z+10	; 0x0a
    47d4:	93 85       	ldd	r25, Z+11	; 0x0b
    47d6:	00 97       	sbiw	r24, 0x00	; 0
    47d8:	b9 f0       	breq	.+46     	; 0x4808 <xStreamBufferReceiveCompletedFromISR+0x68>
		{
			( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToSend,
    47da:	eb 81       	ldd	r30, Y+3	; 0x03
    47dc:	fc 81       	ldd	r31, Y+4	; 0x04
    47de:	82 85       	ldd	r24, Z+10	; 0x0a
    47e0:	93 85       	ldd	r25, Z+11	; 0x0b
    47e2:	ef 81       	ldd	r30, Y+7	; 0x07
    47e4:	f8 85       	ldd	r31, Y+8	; 0x08
    47e6:	40 e0       	ldi	r20, 0x00	; 0
    47e8:	50 e0       	ldi	r21, 0x00	; 0
    47ea:	60 e0       	ldi	r22, 0x00	; 0
    47ec:	70 e0       	ldi	r23, 0x00	; 0
    47ee:	20 e0       	ldi	r18, 0x00	; 0
    47f0:	00 e0       	ldi	r16, 0x00	; 0
    47f2:	10 e0       	ldi	r17, 0x00	; 0
    47f4:	7f 01       	movw	r14, r30
    47f6:	0e 94 a8 30 	call	0x6150	; 0x6150 <xTaskGenericNotifyFromISR>
										 ( uint32_t ) 0,
										 eNoAction,
										 pxHigherPriorityTaskWoken );
			( pxStreamBuffer )->xTaskWaitingToSend = NULL;
    47fa:	eb 81       	ldd	r30, Y+3	; 0x03
    47fc:	fc 81       	ldd	r31, Y+4	; 0x04
    47fe:	13 86       	std	Z+11, r1	; 0x0b
    4800:	12 86       	std	Z+10, r1	; 0x0a
			xReturn = pdTRUE;
    4802:	81 e0       	ldi	r24, 0x01	; 1
    4804:	8a 83       	std	Y+2, r24	; 0x02
    4806:	01 c0       	rjmp	.+2      	; 0x480a <xStreamBufferReceiveCompletedFromISR+0x6a>
		}
		else
		{
			xReturn = pdFALSE;
    4808:	1a 82       	std	Y+2, r1	; 0x02
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    480a:	8a 81       	ldd	r24, Y+2	; 0x02
}
    480c:	28 96       	adiw	r28, 0x08	; 8
    480e:	0f b6       	in	r0, 0x3f	; 63
    4810:	f8 94       	cli
    4812:	de bf       	out	0x3e, r29	; 62
    4814:	0f be       	out	0x3f, r0	; 63
    4816:	cd bf       	out	0x3d, r28	; 61
    4818:	cf 91       	pop	r28
    481a:	df 91       	pop	r29
    481c:	1f 91       	pop	r17
    481e:	0f 91       	pop	r16
    4820:	ff 90       	pop	r15
    4822:	ef 90       	pop	r14
    4824:	08 95       	ret

00004826 <prvWriteBytesToBuffer>:
/*-----------------------------------------------------------*/

static size_t prvWriteBytesToBuffer( StreamBuffer_t * const pxStreamBuffer, const uint8_t *pucData, size_t xCount )
{
    4826:	df 93       	push	r29
    4828:	cf 93       	push	r28
    482a:	cd b7       	in	r28, 0x3d	; 61
    482c:	de b7       	in	r29, 0x3e	; 62
    482e:	2e 97       	sbiw	r28, 0x0e	; 14
    4830:	0f b6       	in	r0, 0x3f	; 63
    4832:	f8 94       	cli
    4834:	de bf       	out	0x3e, r29	; 62
    4836:	0f be       	out	0x3f, r0	; 63
    4838:	cd bf       	out	0x3d, r28	; 61
    483a:	9e 83       	std	Y+6, r25	; 0x06
    483c:	8d 83       	std	Y+5, r24	; 0x05
    483e:	78 87       	std	Y+8, r23	; 0x08
    4840:	6f 83       	std	Y+7, r22	; 0x07
    4842:	5a 87       	std	Y+10, r21	; 0x0a
    4844:	49 87       	std	Y+9, r20	; 0x09
size_t xNextHead, xFirstLength;

	configASSERT( xCount > ( size_t ) 0 );

	xNextHead = pxStreamBuffer->xHead;
    4846:	ed 81       	ldd	r30, Y+5	; 0x05
    4848:	fe 81       	ldd	r31, Y+6	; 0x06
    484a:	82 81       	ldd	r24, Z+2	; 0x02
    484c:	93 81       	ldd	r25, Z+3	; 0x03
    484e:	9c 83       	std	Y+4, r25	; 0x04
    4850:	8b 83       	std	Y+3, r24	; 0x03

	/* Calculate the number of bytes that can be added in the first write -
	which may be less than the total number of bytes that need to be added if
	the buffer will wrap back to the beginning. */
	xFirstLength = configMIN( pxStreamBuffer->xLength - xNextHead, xCount );
    4852:	ed 81       	ldd	r30, Y+5	; 0x05
    4854:	fe 81       	ldd	r31, Y+6	; 0x06
    4856:	24 81       	ldd	r18, Z+4	; 0x04
    4858:	35 81       	ldd	r19, Z+5	; 0x05
    485a:	8b 81       	ldd	r24, Y+3	; 0x03
    485c:	9c 81       	ldd	r25, Y+4	; 0x04
    485e:	a9 01       	movw	r20, r18
    4860:	48 1b       	sub	r20, r24
    4862:	59 0b       	sbc	r21, r25
    4864:	ca 01       	movw	r24, r20
    4866:	29 85       	ldd	r18, Y+9	; 0x09
    4868:	3a 85       	ldd	r19, Y+10	; 0x0a
    486a:	3e 87       	std	Y+14, r19	; 0x0e
    486c:	2d 87       	std	Y+13, r18	; 0x0d
    486e:	9c 87       	std	Y+12, r25	; 0x0c
    4870:	8b 87       	std	Y+11, r24	; 0x0b
    4872:	4b 85       	ldd	r20, Y+11	; 0x0b
    4874:	5c 85       	ldd	r21, Y+12	; 0x0c
    4876:	8d 85       	ldd	r24, Y+13	; 0x0d
    4878:	9e 85       	ldd	r25, Y+14	; 0x0e
    487a:	84 17       	cp	r24, r20
    487c:	95 07       	cpc	r25, r21
    487e:	20 f4       	brcc	.+8      	; 0x4888 <prvWriteBytesToBuffer+0x62>
    4880:	2d 85       	ldd	r18, Y+13	; 0x0d
    4882:	3e 85       	ldd	r19, Y+14	; 0x0e
    4884:	3c 87       	std	Y+12, r19	; 0x0c
    4886:	2b 87       	std	Y+11, r18	; 0x0b
    4888:	4b 85       	ldd	r20, Y+11	; 0x0b
    488a:	5c 85       	ldd	r21, Y+12	; 0x0c
    488c:	5a 83       	std	Y+2, r21	; 0x02
    488e:	49 83       	std	Y+1, r20	; 0x01

	/* Write as many bytes as can be written in the first write. */
	configASSERT( ( xNextHead + xFirstLength ) <= pxStreamBuffer->xLength );
	( void ) memcpy( ( void* ) ( &( pxStreamBuffer->pucBuffer[ xNextHead ] ) ), ( const void * ) pucData, xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    4890:	ed 81       	ldd	r30, Y+5	; 0x05
    4892:	fe 81       	ldd	r31, Y+6	; 0x06
    4894:	24 85       	ldd	r18, Z+12	; 0x0c
    4896:	35 85       	ldd	r19, Z+13	; 0x0d
    4898:	8b 81       	ldd	r24, Y+3	; 0x03
    489a:	9c 81       	ldd	r25, Y+4	; 0x04
    489c:	82 0f       	add	r24, r18
    489e:	93 1f       	adc	r25, r19
    48a0:	2f 81       	ldd	r18, Y+7	; 0x07
    48a2:	38 85       	ldd	r19, Y+8	; 0x08
    48a4:	49 81       	ldd	r20, Y+1	; 0x01
    48a6:	5a 81       	ldd	r21, Y+2	; 0x02
    48a8:	b9 01       	movw	r22, r18
    48aa:	0e 94 13 33 	call	0x6626	; 0x6626 <memcpy>

	/* If the number of bytes written was less than the number that could be
	written in the first write... */
	if( xCount > xFirstLength )
    48ae:	29 85       	ldd	r18, Y+9	; 0x09
    48b0:	3a 85       	ldd	r19, Y+10	; 0x0a
    48b2:	89 81       	ldd	r24, Y+1	; 0x01
    48b4:	9a 81       	ldd	r25, Y+2	; 0x02
    48b6:	82 17       	cp	r24, r18
    48b8:	93 07       	cpc	r25, r19
    48ba:	b0 f4       	brcc	.+44     	; 0x48e8 <prvWriteBytesToBuffer+0xc2>
	{
		/* ...then write the remaining bytes to the start of the buffer. */
		configASSERT( ( xCount - xFirstLength ) <= pxStreamBuffer->xLength );
		( void ) memcpy( ( void * ) pxStreamBuffer->pucBuffer, ( const void * ) &( pucData[ xFirstLength ] ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    48bc:	ed 81       	ldd	r30, Y+5	; 0x05
    48be:	fe 81       	ldd	r31, Y+6	; 0x06
    48c0:	64 85       	ldd	r22, Z+12	; 0x0c
    48c2:	75 85       	ldd	r23, Z+13	; 0x0d
    48c4:	2f 81       	ldd	r18, Y+7	; 0x07
    48c6:	38 85       	ldd	r19, Y+8	; 0x08
    48c8:	89 81       	ldd	r24, Y+1	; 0x01
    48ca:	9a 81       	ldd	r25, Y+2	; 0x02
    48cc:	a9 01       	movw	r20, r18
    48ce:	48 0f       	add	r20, r24
    48d0:	59 1f       	adc	r21, r25
    48d2:	29 85       	ldd	r18, Y+9	; 0x09
    48d4:	3a 85       	ldd	r19, Y+10	; 0x0a
    48d6:	89 81       	ldd	r24, Y+1	; 0x01
    48d8:	9a 81       	ldd	r25, Y+2	; 0x02
    48da:	28 1b       	sub	r18, r24
    48dc:	39 0b       	sbc	r19, r25
    48de:	cb 01       	movw	r24, r22
    48e0:	ba 01       	movw	r22, r20
    48e2:	a9 01       	movw	r20, r18
    48e4:	0e 94 13 33 	call	0x6626	; 0x6626 <memcpy>
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	xNextHead += xCount;
    48e8:	2b 81       	ldd	r18, Y+3	; 0x03
    48ea:	3c 81       	ldd	r19, Y+4	; 0x04
    48ec:	89 85       	ldd	r24, Y+9	; 0x09
    48ee:	9a 85       	ldd	r25, Y+10	; 0x0a
    48f0:	82 0f       	add	r24, r18
    48f2:	93 1f       	adc	r25, r19
    48f4:	9c 83       	std	Y+4, r25	; 0x04
    48f6:	8b 83       	std	Y+3, r24	; 0x03
	if( xNextHead >= pxStreamBuffer->xLength )
    48f8:	ed 81       	ldd	r30, Y+5	; 0x05
    48fa:	fe 81       	ldd	r31, Y+6	; 0x06
    48fc:	24 81       	ldd	r18, Z+4	; 0x04
    48fe:	35 81       	ldd	r19, Z+5	; 0x05
    4900:	8b 81       	ldd	r24, Y+3	; 0x03
    4902:	9c 81       	ldd	r25, Y+4	; 0x04
    4904:	82 17       	cp	r24, r18
    4906:	93 07       	cpc	r25, r19
    4908:	50 f0       	brcs	.+20     	; 0x491e <prvWriteBytesToBuffer+0xf8>
	{
		xNextHead -= pxStreamBuffer->xLength;
    490a:	ed 81       	ldd	r30, Y+5	; 0x05
    490c:	fe 81       	ldd	r31, Y+6	; 0x06
    490e:	24 81       	ldd	r18, Z+4	; 0x04
    4910:	35 81       	ldd	r19, Z+5	; 0x05
    4912:	8b 81       	ldd	r24, Y+3	; 0x03
    4914:	9c 81       	ldd	r25, Y+4	; 0x04
    4916:	82 1b       	sub	r24, r18
    4918:	93 0b       	sbc	r25, r19
    491a:	9c 83       	std	Y+4, r25	; 0x04
    491c:	8b 83       	std	Y+3, r24	; 0x03
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxStreamBuffer->xHead = xNextHead;
    491e:	ed 81       	ldd	r30, Y+5	; 0x05
    4920:	fe 81       	ldd	r31, Y+6	; 0x06
    4922:	8b 81       	ldd	r24, Y+3	; 0x03
    4924:	9c 81       	ldd	r25, Y+4	; 0x04
    4926:	93 83       	std	Z+3, r25	; 0x03
    4928:	82 83       	std	Z+2, r24	; 0x02

	return xCount;
    492a:	89 85       	ldd	r24, Y+9	; 0x09
    492c:	9a 85       	ldd	r25, Y+10	; 0x0a
}
    492e:	2e 96       	adiw	r28, 0x0e	; 14
    4930:	0f b6       	in	r0, 0x3f	; 63
    4932:	f8 94       	cli
    4934:	de bf       	out	0x3e, r29	; 62
    4936:	0f be       	out	0x3f, r0	; 63
    4938:	cd bf       	out	0x3d, r28	; 61
    493a:	cf 91       	pop	r28
    493c:	df 91       	pop	r29
    493e:	08 95       	ret

00004940 <prvReadBytesFromBuffer>:
/*-----------------------------------------------------------*/

static size_t prvReadBytesFromBuffer( StreamBuffer_t *pxStreamBuffer, uint8_t *pucData, size_t xMaxCount, size_t xBytesAvailable )
{
    4940:	df 93       	push	r29
    4942:	cf 93       	push	r28
    4944:	cd b7       	in	r28, 0x3d	; 61
    4946:	de b7       	in	r29, 0x3e	; 62
    4948:	66 97       	sbiw	r28, 0x16	; 22
    494a:	0f b6       	in	r0, 0x3f	; 63
    494c:	f8 94       	cli
    494e:	de bf       	out	0x3e, r29	; 62
    4950:	0f be       	out	0x3f, r0	; 63
    4952:	cd bf       	out	0x3d, r28	; 61
    4954:	98 87       	std	Y+8, r25	; 0x08
    4956:	8f 83       	std	Y+7, r24	; 0x07
    4958:	7a 87       	std	Y+10, r23	; 0x0a
    495a:	69 87       	std	Y+9, r22	; 0x09
    495c:	5c 87       	std	Y+12, r21	; 0x0c
    495e:	4b 87       	std	Y+11, r20	; 0x0b
    4960:	3e 87       	std	Y+14, r19	; 0x0e
    4962:	2d 87       	std	Y+13, r18	; 0x0d
size_t xCount, xFirstLength, xNextTail;

	/* Use the minimum of the wanted bytes and the available bytes. */
	xCount = configMIN( xBytesAvailable, xMaxCount );
    4964:	2d 85       	ldd	r18, Y+13	; 0x0d
    4966:	3e 85       	ldd	r19, Y+14	; 0x0e
    4968:	3a 8b       	std	Y+18, r19	; 0x12
    496a:	29 8b       	std	Y+17, r18	; 0x11
    496c:	4b 85       	ldd	r20, Y+11	; 0x0b
    496e:	5c 85       	ldd	r21, Y+12	; 0x0c
    4970:	58 8b       	std	Y+16, r21	; 0x10
    4972:	4f 87       	std	Y+15, r20	; 0x0f
    4974:	8f 85       	ldd	r24, Y+15	; 0x0f
    4976:	98 89       	ldd	r25, Y+16	; 0x10
    4978:	29 89       	ldd	r18, Y+17	; 0x11
    497a:	3a 89       	ldd	r19, Y+18	; 0x12
    497c:	28 17       	cp	r18, r24
    497e:	39 07       	cpc	r19, r25
    4980:	20 f4       	brcc	.+8      	; 0x498a <prvReadBytesFromBuffer+0x4a>
    4982:	49 89       	ldd	r20, Y+17	; 0x11
    4984:	5a 89       	ldd	r21, Y+18	; 0x12
    4986:	58 8b       	std	Y+16, r21	; 0x10
    4988:	4f 87       	std	Y+15, r20	; 0x0f
    498a:	8f 85       	ldd	r24, Y+15	; 0x0f
    498c:	98 89       	ldd	r25, Y+16	; 0x10
    498e:	9e 83       	std	Y+6, r25	; 0x06
    4990:	8d 83       	std	Y+5, r24	; 0x05

	if( xCount > ( size_t ) 0 )
    4992:	8d 81       	ldd	r24, Y+5	; 0x05
    4994:	9e 81       	ldd	r25, Y+6	; 0x06
    4996:	00 97       	sbiw	r24, 0x00	; 0
    4998:	09 f4       	brne	.+2      	; 0x499c <prvReadBytesFromBuffer+0x5c>
    499a:	74 c0       	rjmp	.+232    	; 0x4a84 <prvReadBytesFromBuffer+0x144>
	{
		xNextTail = pxStreamBuffer->xTail;
    499c:	ef 81       	ldd	r30, Y+7	; 0x07
    499e:	f8 85       	ldd	r31, Y+8	; 0x08
    49a0:	80 81       	ld	r24, Z
    49a2:	91 81       	ldd	r25, Z+1	; 0x01
    49a4:	9a 83       	std	Y+2, r25	; 0x02
    49a6:	89 83       	std	Y+1, r24	; 0x01

		/* Calculate the number of bytes that can be read - which may be
		less than the number wanted if the data wraps around to the start of
		the buffer. */
		xFirstLength = configMIN( pxStreamBuffer->xLength - xNextTail, xCount );
    49a8:	ef 81       	ldd	r30, Y+7	; 0x07
    49aa:	f8 85       	ldd	r31, Y+8	; 0x08
    49ac:	24 81       	ldd	r18, Z+4	; 0x04
    49ae:	35 81       	ldd	r19, Z+5	; 0x05
    49b0:	89 81       	ldd	r24, Y+1	; 0x01
    49b2:	9a 81       	ldd	r25, Y+2	; 0x02
    49b4:	a9 01       	movw	r20, r18
    49b6:	48 1b       	sub	r20, r24
    49b8:	59 0b       	sbc	r21, r25
    49ba:	ca 01       	movw	r24, r20
    49bc:	2d 81       	ldd	r18, Y+5	; 0x05
    49be:	3e 81       	ldd	r19, Y+6	; 0x06
    49c0:	3e 8b       	std	Y+22, r19	; 0x16
    49c2:	2d 8b       	std	Y+21, r18	; 0x15
    49c4:	9c 8b       	std	Y+20, r25	; 0x14
    49c6:	8b 8b       	std	Y+19, r24	; 0x13
    49c8:	4b 89       	ldd	r20, Y+19	; 0x13
    49ca:	5c 89       	ldd	r21, Y+20	; 0x14
    49cc:	8d 89       	ldd	r24, Y+21	; 0x15
    49ce:	9e 89       	ldd	r25, Y+22	; 0x16
    49d0:	84 17       	cp	r24, r20
    49d2:	95 07       	cpc	r25, r21
    49d4:	20 f4       	brcc	.+8      	; 0x49de <prvReadBytesFromBuffer+0x9e>
    49d6:	2d 89       	ldd	r18, Y+21	; 0x15
    49d8:	3e 89       	ldd	r19, Y+22	; 0x16
    49da:	3c 8b       	std	Y+20, r19	; 0x14
    49dc:	2b 8b       	std	Y+19, r18	; 0x13
    49de:	4b 89       	ldd	r20, Y+19	; 0x13
    49e0:	5c 89       	ldd	r21, Y+20	; 0x14
    49e2:	5c 83       	std	Y+4, r21	; 0x04
    49e4:	4b 83       	std	Y+3, r20	; 0x03

		/* Obtain the number of bytes it is possible to obtain in the first
		read.  Asserts check bounds of read and write. */
		configASSERT( xFirstLength <= xMaxCount );
		configASSERT( ( xNextTail + xFirstLength ) <= pxStreamBuffer->xLength );
		( void ) memcpy( ( void * ) pucData, ( const void * ) &( pxStreamBuffer->pucBuffer[ xNextTail ] ), xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    49e6:	ef 81       	ldd	r30, Y+7	; 0x07
    49e8:	f8 85       	ldd	r31, Y+8	; 0x08
    49ea:	24 85       	ldd	r18, Z+12	; 0x0c
    49ec:	35 85       	ldd	r19, Z+13	; 0x0d
    49ee:	89 81       	ldd	r24, Y+1	; 0x01
    49f0:	9a 81       	ldd	r25, Y+2	; 0x02
    49f2:	a9 01       	movw	r20, r18
    49f4:	48 0f       	add	r20, r24
    49f6:	59 1f       	adc	r21, r25
    49f8:	89 85       	ldd	r24, Y+9	; 0x09
    49fa:	9a 85       	ldd	r25, Y+10	; 0x0a
    49fc:	2b 81       	ldd	r18, Y+3	; 0x03
    49fe:	3c 81       	ldd	r19, Y+4	; 0x04
    4a00:	ba 01       	movw	r22, r20
    4a02:	a9 01       	movw	r20, r18
    4a04:	0e 94 13 33 	call	0x6626	; 0x6626 <memcpy>

		/* If the total number of wanted bytes is greater than the number
		that could be read in the first read... */
		if( xCount > xFirstLength )
    4a08:	2d 81       	ldd	r18, Y+5	; 0x05
    4a0a:	3e 81       	ldd	r19, Y+6	; 0x06
    4a0c:	8b 81       	ldd	r24, Y+3	; 0x03
    4a0e:	9c 81       	ldd	r25, Y+4	; 0x04
    4a10:	82 17       	cp	r24, r18
    4a12:	93 07       	cpc	r25, r19
    4a14:	b0 f4       	brcc	.+44     	; 0x4a42 <prvReadBytesFromBuffer+0x102>
		{
			/*...then read the remaining bytes from the start of the buffer. */
			configASSERT( xCount <= xMaxCount );
			( void ) memcpy( ( void * ) &( pucData[ xFirstLength ] ), ( void * ) ( pxStreamBuffer->pucBuffer ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    4a16:	29 85       	ldd	r18, Y+9	; 0x09
    4a18:	3a 85       	ldd	r19, Y+10	; 0x0a
    4a1a:	8b 81       	ldd	r24, Y+3	; 0x03
    4a1c:	9c 81       	ldd	r25, Y+4	; 0x04
    4a1e:	b9 01       	movw	r22, r18
    4a20:	68 0f       	add	r22, r24
    4a22:	79 1f       	adc	r23, r25
    4a24:	ef 81       	ldd	r30, Y+7	; 0x07
    4a26:	f8 85       	ldd	r31, Y+8	; 0x08
    4a28:	44 85       	ldd	r20, Z+12	; 0x0c
    4a2a:	55 85       	ldd	r21, Z+13	; 0x0d
    4a2c:	2d 81       	ldd	r18, Y+5	; 0x05
    4a2e:	3e 81       	ldd	r19, Y+6	; 0x06
    4a30:	8b 81       	ldd	r24, Y+3	; 0x03
    4a32:	9c 81       	ldd	r25, Y+4	; 0x04
    4a34:	28 1b       	sub	r18, r24
    4a36:	39 0b       	sbc	r19, r25
    4a38:	cb 01       	movw	r24, r22
    4a3a:	ba 01       	movw	r22, r20
    4a3c:	a9 01       	movw	r20, r18
    4a3e:	0e 94 13 33 	call	0x6626	; 0x6626 <memcpy>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Move the tail pointer to effectively remove the data read from
		the buffer. */
		xNextTail += xCount;
    4a42:	29 81       	ldd	r18, Y+1	; 0x01
    4a44:	3a 81       	ldd	r19, Y+2	; 0x02
    4a46:	8d 81       	ldd	r24, Y+5	; 0x05
    4a48:	9e 81       	ldd	r25, Y+6	; 0x06
    4a4a:	82 0f       	add	r24, r18
    4a4c:	93 1f       	adc	r25, r19
    4a4e:	9a 83       	std	Y+2, r25	; 0x02
    4a50:	89 83       	std	Y+1, r24	; 0x01

		if( xNextTail >= pxStreamBuffer->xLength )
    4a52:	ef 81       	ldd	r30, Y+7	; 0x07
    4a54:	f8 85       	ldd	r31, Y+8	; 0x08
    4a56:	24 81       	ldd	r18, Z+4	; 0x04
    4a58:	35 81       	ldd	r19, Z+5	; 0x05
    4a5a:	89 81       	ldd	r24, Y+1	; 0x01
    4a5c:	9a 81       	ldd	r25, Y+2	; 0x02
    4a5e:	82 17       	cp	r24, r18
    4a60:	93 07       	cpc	r25, r19
    4a62:	50 f0       	brcs	.+20     	; 0x4a78 <prvReadBytesFromBuffer+0x138>
		{
			xNextTail -= pxStreamBuffer->xLength;
    4a64:	ef 81       	ldd	r30, Y+7	; 0x07
    4a66:	f8 85       	ldd	r31, Y+8	; 0x08
    4a68:	24 81       	ldd	r18, Z+4	; 0x04
    4a6a:	35 81       	ldd	r19, Z+5	; 0x05
    4a6c:	89 81       	ldd	r24, Y+1	; 0x01
    4a6e:	9a 81       	ldd	r25, Y+2	; 0x02
    4a70:	82 1b       	sub	r24, r18
    4a72:	93 0b       	sbc	r25, r19
    4a74:	9a 83       	std	Y+2, r25	; 0x02
    4a76:	89 83       	std	Y+1, r24	; 0x01
		}

		pxStreamBuffer->xTail = xNextTail;
    4a78:	ef 81       	ldd	r30, Y+7	; 0x07
    4a7a:	f8 85       	ldd	r31, Y+8	; 0x08
    4a7c:	89 81       	ldd	r24, Y+1	; 0x01
    4a7e:	9a 81       	ldd	r25, Y+2	; 0x02
    4a80:	91 83       	std	Z+1, r25	; 0x01
    4a82:	80 83       	st	Z, r24
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xCount;
    4a84:	8d 81       	ldd	r24, Y+5	; 0x05
    4a86:	9e 81       	ldd	r25, Y+6	; 0x06
}
    4a88:	66 96       	adiw	r28, 0x16	; 22
    4a8a:	0f b6       	in	r0, 0x3f	; 63
    4a8c:	f8 94       	cli
    4a8e:	de bf       	out	0x3e, r29	; 62
    4a90:	0f be       	out	0x3f, r0	; 63
    4a92:	cd bf       	out	0x3d, r28	; 61
    4a94:	cf 91       	pop	r28
    4a96:	df 91       	pop	r29
    4a98:	08 95       	ret

00004a9a <prvBytesInBuffer>:
/*-----------------------------------------------------------*/

static size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer )
{
    4a9a:	df 93       	push	r29
    4a9c:	cf 93       	push	r28
    4a9e:	00 d0       	rcall	.+0      	; 0x4aa0 <prvBytesInBuffer+0x6>
    4aa0:	00 d0       	rcall	.+0      	; 0x4aa2 <prvBytesInBuffer+0x8>
    4aa2:	cd b7       	in	r28, 0x3d	; 61
    4aa4:	de b7       	in	r29, 0x3e	; 62
    4aa6:	9c 83       	std	Y+4, r25	; 0x04
    4aa8:	8b 83       	std	Y+3, r24	; 0x03
/* Returns the distance between xTail and xHead. */
size_t xCount;

	xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
    4aaa:	eb 81       	ldd	r30, Y+3	; 0x03
    4aac:	fc 81       	ldd	r31, Y+4	; 0x04
    4aae:	24 81       	ldd	r18, Z+4	; 0x04
    4ab0:	35 81       	ldd	r19, Z+5	; 0x05
    4ab2:	eb 81       	ldd	r30, Y+3	; 0x03
    4ab4:	fc 81       	ldd	r31, Y+4	; 0x04
    4ab6:	82 81       	ldd	r24, Z+2	; 0x02
    4ab8:	93 81       	ldd	r25, Z+3	; 0x03
    4aba:	82 0f       	add	r24, r18
    4abc:	93 1f       	adc	r25, r19
    4abe:	9a 83       	std	Y+2, r25	; 0x02
    4ac0:	89 83       	std	Y+1, r24	; 0x01
	xCount -= pxStreamBuffer->xTail;
    4ac2:	eb 81       	ldd	r30, Y+3	; 0x03
    4ac4:	fc 81       	ldd	r31, Y+4	; 0x04
    4ac6:	20 81       	ld	r18, Z
    4ac8:	31 81       	ldd	r19, Z+1	; 0x01
    4aca:	89 81       	ldd	r24, Y+1	; 0x01
    4acc:	9a 81       	ldd	r25, Y+2	; 0x02
    4ace:	82 1b       	sub	r24, r18
    4ad0:	93 0b       	sbc	r25, r19
    4ad2:	9a 83       	std	Y+2, r25	; 0x02
    4ad4:	89 83       	std	Y+1, r24	; 0x01
	if ( xCount >= pxStreamBuffer->xLength )
    4ad6:	eb 81       	ldd	r30, Y+3	; 0x03
    4ad8:	fc 81       	ldd	r31, Y+4	; 0x04
    4ada:	24 81       	ldd	r18, Z+4	; 0x04
    4adc:	35 81       	ldd	r19, Z+5	; 0x05
    4ade:	89 81       	ldd	r24, Y+1	; 0x01
    4ae0:	9a 81       	ldd	r25, Y+2	; 0x02
    4ae2:	82 17       	cp	r24, r18
    4ae4:	93 07       	cpc	r25, r19
    4ae6:	50 f0       	brcs	.+20     	; 0x4afc <prvBytesInBuffer+0x62>
	{
		xCount -= pxStreamBuffer->xLength;
    4ae8:	eb 81       	ldd	r30, Y+3	; 0x03
    4aea:	fc 81       	ldd	r31, Y+4	; 0x04
    4aec:	24 81       	ldd	r18, Z+4	; 0x04
    4aee:	35 81       	ldd	r19, Z+5	; 0x05
    4af0:	89 81       	ldd	r24, Y+1	; 0x01
    4af2:	9a 81       	ldd	r25, Y+2	; 0x02
    4af4:	82 1b       	sub	r24, r18
    4af6:	93 0b       	sbc	r25, r19
    4af8:	9a 83       	std	Y+2, r25	; 0x02
    4afa:	89 83       	std	Y+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xCount;
    4afc:	89 81       	ldd	r24, Y+1	; 0x01
    4afe:	9a 81       	ldd	r25, Y+2	; 0x02
}
    4b00:	0f 90       	pop	r0
    4b02:	0f 90       	pop	r0
    4b04:	0f 90       	pop	r0
    4b06:	0f 90       	pop	r0
    4b08:	cf 91       	pop	r28
    4b0a:	df 91       	pop	r29
    4b0c:	08 95       	ret

00004b0e <prvInitialiseNewStreamBuffer>:
static void prvInitialiseNewStreamBuffer( StreamBuffer_t * const pxStreamBuffer,
										  uint8_t * const pucBuffer,
										  size_t xBufferSizeBytes,
										  size_t xTriggerLevelBytes,
										  uint8_t ucFlags )
{
    4b0e:	0f 93       	push	r16
    4b10:	df 93       	push	r29
    4b12:	cf 93       	push	r28
    4b14:	cd b7       	in	r28, 0x3d	; 61
    4b16:	de b7       	in	r29, 0x3e	; 62
    4b18:	29 97       	sbiw	r28, 0x09	; 9
    4b1a:	0f b6       	in	r0, 0x3f	; 63
    4b1c:	f8 94       	cli
    4b1e:	de bf       	out	0x3e, r29	; 62
    4b20:	0f be       	out	0x3f, r0	; 63
    4b22:	cd bf       	out	0x3d, r28	; 61
    4b24:	9a 83       	std	Y+2, r25	; 0x02
    4b26:	89 83       	std	Y+1, r24	; 0x01
    4b28:	7c 83       	std	Y+4, r23	; 0x04
    4b2a:	6b 83       	std	Y+3, r22	; 0x03
    4b2c:	5e 83       	std	Y+6, r21	; 0x06
    4b2e:	4d 83       	std	Y+5, r20	; 0x05
    4b30:	38 87       	std	Y+8, r19	; 0x08
    4b32:	2f 83       	std	Y+7, r18	; 0x07
    4b34:	09 87       	std	Y+9, r16	; 0x09
		const BaseType_t xWriteValue = 0x55;
		configASSERT( memset( pucBuffer, ( int ) xWriteValue, xBufferSizeBytes ) == pucBuffer );
	} /*lint !e529 !e438 xWriteValue is only used if configASSERT() is defined. */
	#endif

	( void ) memset( ( void * ) pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) ); /*lint !e9087 memset() requires void *. */
    4b36:	89 81       	ldd	r24, Y+1	; 0x01
    4b38:	9a 81       	ldd	r25, Y+2	; 0x02
    4b3a:	60 e0       	ldi	r22, 0x00	; 0
    4b3c:	70 e0       	ldi	r23, 0x00	; 0
    4b3e:	4f e0       	ldi	r20, 0x0F	; 15
    4b40:	50 e0       	ldi	r21, 0x00	; 0
    4b42:	0e 94 1c 33 	call	0x6638	; 0x6638 <memset>
	pxStreamBuffer->pucBuffer = pucBuffer;
    4b46:	e9 81       	ldd	r30, Y+1	; 0x01
    4b48:	fa 81       	ldd	r31, Y+2	; 0x02
    4b4a:	8b 81       	ldd	r24, Y+3	; 0x03
    4b4c:	9c 81       	ldd	r25, Y+4	; 0x04
    4b4e:	95 87       	std	Z+13, r25	; 0x0d
    4b50:	84 87       	std	Z+12, r24	; 0x0c
	pxStreamBuffer->xLength = xBufferSizeBytes;
    4b52:	e9 81       	ldd	r30, Y+1	; 0x01
    4b54:	fa 81       	ldd	r31, Y+2	; 0x02
    4b56:	8d 81       	ldd	r24, Y+5	; 0x05
    4b58:	9e 81       	ldd	r25, Y+6	; 0x06
    4b5a:	95 83       	std	Z+5, r25	; 0x05
    4b5c:	84 83       	std	Z+4, r24	; 0x04
	pxStreamBuffer->xTriggerLevelBytes = xTriggerLevelBytes;
    4b5e:	e9 81       	ldd	r30, Y+1	; 0x01
    4b60:	fa 81       	ldd	r31, Y+2	; 0x02
    4b62:	8f 81       	ldd	r24, Y+7	; 0x07
    4b64:	98 85       	ldd	r25, Y+8	; 0x08
    4b66:	97 83       	std	Z+7, r25	; 0x07
    4b68:	86 83       	std	Z+6, r24	; 0x06
	pxStreamBuffer->ucFlags = ucFlags;
    4b6a:	e9 81       	ldd	r30, Y+1	; 0x01
    4b6c:	fa 81       	ldd	r31, Y+2	; 0x02
    4b6e:	89 85       	ldd	r24, Y+9	; 0x09
    4b70:	86 87       	std	Z+14, r24	; 0x0e
}
    4b72:	29 96       	adiw	r28, 0x09	; 9
    4b74:	0f b6       	in	r0, 0x3f	; 63
    4b76:	f8 94       	cli
    4b78:	de bf       	out	0x3e, r29	; 62
    4b7a:	0f be       	out	0x3f, r0	; 63
    4b7c:	cd bf       	out	0x3d, r28	; 61
    4b7e:	cf 91       	pop	r28
    4b80:	df 91       	pop	r29
    4b82:	0f 91       	pop	r16
    4b84:	08 95       	ret

00004b86 <xTaskCreate>:
							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
							const configSTACK_DEPTH_TYPE usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask )
	{
    4b86:	8f 92       	push	r8
    4b88:	9f 92       	push	r9
    4b8a:	af 92       	push	r10
    4b8c:	bf 92       	push	r11
    4b8e:	cf 92       	push	r12
    4b90:	df 92       	push	r13
    4b92:	ef 92       	push	r14
    4b94:	ff 92       	push	r15
    4b96:	0f 93       	push	r16
    4b98:	1f 93       	push	r17
    4b9a:	df 93       	push	r29
    4b9c:	cf 93       	push	r28
    4b9e:	cd b7       	in	r28, 0x3d	; 61
    4ba0:	de b7       	in	r29, 0x3e	; 62
    4ba2:	60 97       	sbiw	r28, 0x10	; 16
    4ba4:	0f b6       	in	r0, 0x3f	; 63
    4ba6:	f8 94       	cli
    4ba8:	de bf       	out	0x3e, r29	; 62
    4baa:	0f be       	out	0x3f, r0	; 63
    4bac:	cd bf       	out	0x3d, r28	; 61
    4bae:	9f 83       	std	Y+7, r25	; 0x07
    4bb0:	8e 83       	std	Y+6, r24	; 0x06
    4bb2:	79 87       	std	Y+9, r23	; 0x09
    4bb4:	68 87       	std	Y+8, r22	; 0x08
    4bb6:	5b 87       	std	Y+11, r21	; 0x0b
    4bb8:	4a 87       	std	Y+10, r20	; 0x0a
    4bba:	3d 87       	std	Y+13, r19	; 0x0d
    4bbc:	2c 87       	std	Y+12, r18	; 0x0c
    4bbe:	0e 87       	std	Y+14, r16	; 0x0e
    4bc0:	f8 8a       	std	Y+16, r15	; 0x10
    4bc2:	ef 86       	std	Y+15, r14	; 0x0f
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
    4bc4:	8a 85       	ldd	r24, Y+10	; 0x0a
    4bc6:	9b 85       	ldd	r25, Y+11	; 0x0b
    4bc8:	0e 94 33 0d 	call	0x1a66	; 0x1a66 <pvPortMalloc>
    4bcc:	9a 83       	std	Y+2, r25	; 0x02
    4bce:	89 83       	std	Y+1, r24	; 0x01

			if( pxStack != NULL )
    4bd0:	89 81       	ldd	r24, Y+1	; 0x01
    4bd2:	9a 81       	ldd	r25, Y+2	; 0x02
    4bd4:	00 97       	sbiw	r24, 0x00	; 0
    4bd6:	b1 f0       	breq	.+44     	; 0x4c04 <xTaskCreate+0x7e>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
    4bd8:	86 e2       	ldi	r24, 0x26	; 38
    4bda:	90 e0       	ldi	r25, 0x00	; 0
    4bdc:	0e 94 33 0d 	call	0x1a66	; 0x1a66 <pvPortMalloc>
    4be0:	9d 83       	std	Y+5, r25	; 0x05
    4be2:	8c 83       	std	Y+4, r24	; 0x04

				if( pxNewTCB != NULL )
    4be4:	8c 81       	ldd	r24, Y+4	; 0x04
    4be6:	9d 81       	ldd	r25, Y+5	; 0x05
    4be8:	00 97       	sbiw	r24, 0x00	; 0
    4bea:	39 f0       	breq	.+14     	; 0x4bfa <xTaskCreate+0x74>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
    4bec:	ec 81       	ldd	r30, Y+4	; 0x04
    4bee:	fd 81       	ldd	r31, Y+5	; 0x05
    4bf0:	89 81       	ldd	r24, Y+1	; 0x01
    4bf2:	9a 81       	ldd	r25, Y+2	; 0x02
    4bf4:	90 8f       	std	Z+24, r25	; 0x18
    4bf6:	87 8b       	std	Z+23, r24	; 0x17
    4bf8:	07 c0       	rjmp	.+14     	; 0x4c08 <xTaskCreate+0x82>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
    4bfa:	89 81       	ldd	r24, Y+1	; 0x01
    4bfc:	9a 81       	ldd	r25, Y+2	; 0x02
    4bfe:	0e 94 89 0d 	call	0x1b12	; 0x1b12 <vPortFree>
    4c02:	02 c0       	rjmp	.+4      	; 0x4c08 <xTaskCreate+0x82>
				}
			}
			else
			{
				pxNewTCB = NULL;
    4c04:	1d 82       	std	Y+5, r1	; 0x05
    4c06:	1c 82       	std	Y+4, r1	; 0x04
			}
		}
		#endif /* portSTACK_GROWTH */

		if( pxNewTCB != NULL )
    4c08:	8c 81       	ldd	r24, Y+4	; 0x04
    4c0a:	9d 81       	ldd	r25, Y+5	; 0x05
    4c0c:	00 97       	sbiw	r24, 0x00	; 0
    4c0e:	e9 f0       	breq	.+58     	; 0x4c4a <xTaskCreate+0xc4>
				task was created dynamically in case it is later deleted. */
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
			}
			#endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
    4c10:	8a 85       	ldd	r24, Y+10	; 0x0a
    4c12:	9b 85       	ldd	r25, Y+11	; 0x0b
    4c14:	9c 01       	movw	r18, r24
    4c16:	40 e0       	ldi	r20, 0x00	; 0
    4c18:	50 e0       	ldi	r21, 0x00	; 0
    4c1a:	8e 81       	ldd	r24, Y+6	; 0x06
    4c1c:	9f 81       	ldd	r25, Y+7	; 0x07
    4c1e:	68 85       	ldd	r22, Y+8	; 0x08
    4c20:	79 85       	ldd	r23, Y+9	; 0x09
    4c22:	ec 85       	ldd	r30, Y+12	; 0x0c
    4c24:	fd 85       	ldd	r31, Y+13	; 0x0d
    4c26:	af 85       	ldd	r26, Y+15	; 0x0f
    4c28:	b8 89       	ldd	r27, Y+16	; 0x10
    4c2a:	ac 80       	ldd	r10, Y+4	; 0x04
    4c2c:	bd 80       	ldd	r11, Y+5	; 0x05
    4c2e:	8f 01       	movw	r16, r30
    4c30:	ee 84       	ldd	r14, Y+14	; 0x0e
    4c32:	6d 01       	movw	r12, r26
    4c34:	88 24       	eor	r8, r8
    4c36:	99 24       	eor	r9, r9
    4c38:	0e 94 3b 26 	call	0x4c76	; 0x4c76 <prvInitialiseNewTask>
			prvAddNewTaskToReadyList( pxNewTCB );
    4c3c:	8c 81       	ldd	r24, Y+4	; 0x04
    4c3e:	9d 81       	ldd	r25, Y+5	; 0x05
    4c40:	0e 94 f7 26 	call	0x4dee	; 0x4dee <prvAddNewTaskToReadyList>
			xReturn = pdPASS;
    4c44:	81 e0       	ldi	r24, 0x01	; 1
    4c46:	8b 83       	std	Y+3, r24	; 0x03
    4c48:	02 c0       	rjmp	.+4      	; 0x4c4e <xTaskCreate+0xc8>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    4c4a:	8f ef       	ldi	r24, 0xFF	; 255
    4c4c:	8b 83       	std	Y+3, r24	; 0x03
		}

		return xReturn;
    4c4e:	8b 81       	ldd	r24, Y+3	; 0x03
	}
    4c50:	60 96       	adiw	r28, 0x10	; 16
    4c52:	0f b6       	in	r0, 0x3f	; 63
    4c54:	f8 94       	cli
    4c56:	de bf       	out	0x3e, r29	; 62
    4c58:	0f be       	out	0x3f, r0	; 63
    4c5a:	cd bf       	out	0x3d, r28	; 61
    4c5c:	cf 91       	pop	r28
    4c5e:	df 91       	pop	r29
    4c60:	1f 91       	pop	r17
    4c62:	0f 91       	pop	r16
    4c64:	ff 90       	pop	r15
    4c66:	ef 90       	pop	r14
    4c68:	df 90       	pop	r13
    4c6a:	cf 90       	pop	r12
    4c6c:	bf 90       	pop	r11
    4c6e:	af 90       	pop	r10
    4c70:	9f 90       	pop	r9
    4c72:	8f 90       	pop	r8
    4c74:	08 95       	ret

00004c76 <prvInitialiseNewTask>:
									void * const pvParameters,
									UBaseType_t uxPriority,
									TaskHandle_t * const pxCreatedTask,
									TCB_t *pxNewTCB,
									const MemoryRegion_t * const xRegions )
{
    4c76:	8f 92       	push	r8
    4c78:	9f 92       	push	r9
    4c7a:	af 92       	push	r10
    4c7c:	bf 92       	push	r11
    4c7e:	cf 92       	push	r12
    4c80:	df 92       	push	r13
    4c82:	ef 92       	push	r14
    4c84:	0f 93       	push	r16
    4c86:	1f 93       	push	r17
    4c88:	df 93       	push	r29
    4c8a:	cf 93       	push	r28
    4c8c:	cd b7       	in	r28, 0x3d	; 61
    4c8e:	de b7       	in	r29, 0x3e	; 62
    4c90:	64 97       	sbiw	r28, 0x14	; 20
    4c92:	0f b6       	in	r0, 0x3f	; 63
    4c94:	f8 94       	cli
    4c96:	de bf       	out	0x3e, r29	; 62
    4c98:	0f be       	out	0x3f, r0	; 63
    4c9a:	cd bf       	out	0x3d, r28	; 61
    4c9c:	9d 83       	std	Y+5, r25	; 0x05
    4c9e:	8c 83       	std	Y+4, r24	; 0x04
    4ca0:	7f 83       	std	Y+7, r23	; 0x07
    4ca2:	6e 83       	std	Y+6, r22	; 0x06
    4ca4:	28 87       	std	Y+8, r18	; 0x08
    4ca6:	39 87       	std	Y+9, r19	; 0x09
    4ca8:	4a 87       	std	Y+10, r20	; 0x0a
    4caa:	5b 87       	std	Y+11, r21	; 0x0b
    4cac:	1d 87       	std	Y+13, r17	; 0x0d
    4cae:	0c 87       	std	Y+12, r16	; 0x0c
    4cb0:	ee 86       	std	Y+14, r14	; 0x0e
    4cb2:	d8 8a       	std	Y+16, r13	; 0x10
    4cb4:	cf 86       	std	Y+15, r12	; 0x0f
    4cb6:	ba 8a       	std	Y+18, r11	; 0x12
    4cb8:	a9 8a       	std	Y+17, r10	; 0x11
    4cba:	9c 8a       	std	Y+20, r9	; 0x14
    4cbc:	8b 8a       	std	Y+19, r8	; 0x13
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
    4cbe:	e9 89       	ldd	r30, Y+17	; 0x11
    4cc0:	fa 89       	ldd	r31, Y+18	; 0x12
    4cc2:	27 89       	ldd	r18, Z+23	; 0x17
    4cc4:	30 8d       	ldd	r19, Z+24	; 0x18
    4cc6:	88 85       	ldd	r24, Y+8	; 0x08
    4cc8:	99 85       	ldd	r25, Y+9	; 0x09
    4cca:	01 97       	sbiw	r24, 0x01	; 1
    4ccc:	82 0f       	add	r24, r18
    4cce:	93 1f       	adc	r25, r19
    4cd0:	9b 83       	std	Y+3, r25	; 0x03
    4cd2:	8a 83       	std	Y+2, r24	; 0x02
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
    4cd4:	8e 81       	ldd	r24, Y+6	; 0x06
    4cd6:	9f 81       	ldd	r25, Y+7	; 0x07
    4cd8:	00 97       	sbiw	r24, 0x00	; 0
    4cda:	51 f1       	breq	.+84     	; 0x4d30 <prvInitialiseNewTask+0xba>
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    4cdc:	19 82       	std	Y+1, r1	; 0x01
    4cde:	21 c0       	rjmp	.+66     	; 0x4d22 <prvInitialiseNewTask+0xac>
		{
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    4ce0:	89 81       	ldd	r24, Y+1	; 0x01
    4ce2:	48 2f       	mov	r20, r24
    4ce4:	50 e0       	ldi	r21, 0x00	; 0
    4ce6:	89 81       	ldd	r24, Y+1	; 0x01
    4ce8:	28 2f       	mov	r18, r24
    4cea:	30 e0       	ldi	r19, 0x00	; 0
    4cec:	8e 81       	ldd	r24, Y+6	; 0x06
    4cee:	9f 81       	ldd	r25, Y+7	; 0x07
    4cf0:	fc 01       	movw	r30, r24
    4cf2:	e2 0f       	add	r30, r18
    4cf4:	f3 1f       	adc	r31, r19
    4cf6:	20 81       	ld	r18, Z
    4cf8:	89 89       	ldd	r24, Y+17	; 0x11
    4cfa:	9a 89       	ldd	r25, Y+18	; 0x12
    4cfc:	84 0f       	add	r24, r20
    4cfe:	95 1f       	adc	r25, r21
    4d00:	fc 01       	movw	r30, r24
    4d02:	79 96       	adiw	r30, 0x19	; 25
    4d04:	20 83       	st	Z, r18

			/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
			configMAX_TASK_NAME_LEN characters just in case the memory after the
			string is not accessible (extremely unlikely). */
			if( pcName[ x ] == ( char ) 0x00 )
    4d06:	89 81       	ldd	r24, Y+1	; 0x01
    4d08:	28 2f       	mov	r18, r24
    4d0a:	30 e0       	ldi	r19, 0x00	; 0
    4d0c:	8e 81       	ldd	r24, Y+6	; 0x06
    4d0e:	9f 81       	ldd	r25, Y+7	; 0x07
    4d10:	fc 01       	movw	r30, r24
    4d12:	e2 0f       	add	r30, r18
    4d14:	f3 1f       	adc	r31, r19
    4d16:	80 81       	ld	r24, Z
    4d18:	88 23       	and	r24, r24
    4d1a:	31 f0       	breq	.+12     	; 0x4d28 <prvInitialiseNewTask+0xb2>
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    4d1c:	89 81       	ldd	r24, Y+1	; 0x01
    4d1e:	8f 5f       	subi	r24, 0xFF	; 255
    4d20:	89 83       	std	Y+1, r24	; 0x01
    4d22:	89 81       	ldd	r24, Y+1	; 0x01
    4d24:	88 30       	cpi	r24, 0x08	; 8
    4d26:	e0 f2       	brcs	.-72     	; 0x4ce0 <prvInitialiseNewTask+0x6a>
			}
		}

		/* Ensure the name string is terminated in the case that the string length
		was greater or equal to configMAX_TASK_NAME_LEN. */
		pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    4d28:	e9 89       	ldd	r30, Y+17	; 0x11
    4d2a:	fa 89       	ldd	r31, Y+18	; 0x12
    4d2c:	10 a2       	std	Z+32, r1	; 0x20
    4d2e:	03 c0       	rjmp	.+6      	; 0x4d36 <prvInitialiseNewTask+0xc0>
	}
	else
	{
		/* The task has not been given a name, so just ensure there is a NULL
		terminator when it is read out. */
		pxNewTCB->pcTaskName[ 0 ] = 0x00;
    4d30:	e9 89       	ldd	r30, Y+17	; 0x11
    4d32:	fa 89       	ldd	r31, Y+18	; 0x12
    4d34:	11 8e       	std	Z+25, r1	; 0x19
	}

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    4d36:	8e 85       	ldd	r24, Y+14	; 0x0e
    4d38:	84 30       	cpi	r24, 0x04	; 4
    4d3a:	10 f0       	brcs	.+4      	; 0x4d40 <prvInitialiseNewTask+0xca>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    4d3c:	83 e0       	ldi	r24, 0x03	; 3
    4d3e:	8e 87       	std	Y+14, r24	; 0x0e
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
    4d40:	e9 89       	ldd	r30, Y+17	; 0x11
    4d42:	fa 89       	ldd	r31, Y+18	; 0x12
    4d44:	8e 85       	ldd	r24, Y+14	; 0x0e
    4d46:	86 8b       	std	Z+22, r24	; 0x16
		pxNewTCB->uxBasePriority = uxPriority;
		pxNewTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    4d48:	89 89       	ldd	r24, Y+17	; 0x11
    4d4a:	9a 89       	ldd	r25, Y+18	; 0x12
    4d4c:	02 96       	adiw	r24, 0x02	; 2
    4d4e:	0e 94 53 11 	call	0x22a6	; 0x22a6 <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    4d52:	89 89       	ldd	r24, Y+17	; 0x11
    4d54:	9a 89       	ldd	r25, Y+18	; 0x12
    4d56:	0c 96       	adiw	r24, 0x0c	; 12
    4d58:	0e 94 53 11 	call	0x22a6	; 0x22a6 <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    4d5c:	e9 89       	ldd	r30, Y+17	; 0x11
    4d5e:	fa 89       	ldd	r31, Y+18	; 0x12
    4d60:	89 89       	ldd	r24, Y+17	; 0x11
    4d62:	9a 89       	ldd	r25, Y+18	; 0x12
    4d64:	91 87       	std	Z+9, r25	; 0x09
    4d66:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    4d68:	8e 85       	ldd	r24, Y+14	; 0x0e
    4d6a:	28 2f       	mov	r18, r24
    4d6c:	30 e0       	ldi	r19, 0x00	; 0
    4d6e:	84 e0       	ldi	r24, 0x04	; 4
    4d70:	90 e0       	ldi	r25, 0x00	; 0
    4d72:	82 1b       	sub	r24, r18
    4d74:	93 0b       	sbc	r25, r19
    4d76:	e9 89       	ldd	r30, Y+17	; 0x11
    4d78:	fa 89       	ldd	r31, Y+18	; 0x12
    4d7a:	95 87       	std	Z+13, r25	; 0x0d
    4d7c:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    4d7e:	e9 89       	ldd	r30, Y+17	; 0x11
    4d80:	fa 89       	ldd	r31, Y+18	; 0x12
    4d82:	89 89       	ldd	r24, Y+17	; 0x11
    4d84:	9a 89       	ldd	r25, Y+18	; 0x12
    4d86:	93 8b       	std	Z+19, r25	; 0x13
    4d88:	82 8b       	std	Z+18, r24	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
    4d8a:	e9 89       	ldd	r30, Y+17	; 0x11
    4d8c:	fa 89       	ldd	r31, Y+18	; 0x12
    4d8e:	11 a2       	std	Z+33, r1	; 0x21
    4d90:	12 a2       	std	Z+34, r1	; 0x22
    4d92:	13 a2       	std	Z+35, r1	; 0x23
    4d94:	14 a2       	std	Z+36, r1	; 0x24
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    4d96:	e9 89       	ldd	r30, Y+17	; 0x11
    4d98:	fa 89       	ldd	r31, Y+18	; 0x12
    4d9a:	15 a2       	std	Z+37, r1	; 0x25
			}
			#endif /* portSTACK_GROWTH */
		}
		#else /* portHAS_STACK_OVERFLOW_CHECKING */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    4d9c:	8a 81       	ldd	r24, Y+2	; 0x02
    4d9e:	9b 81       	ldd	r25, Y+3	; 0x03
    4da0:	2c 81       	ldd	r18, Y+4	; 0x04
    4da2:	3d 81       	ldd	r19, Y+5	; 0x05
    4da4:	4c 85       	ldd	r20, Y+12	; 0x0c
    4da6:	5d 85       	ldd	r21, Y+13	; 0x0d
    4da8:	b9 01       	movw	r22, r18
    4daa:	0e 94 19 14 	call	0x2832	; 0x2832 <pxPortInitialiseStack>
    4dae:	e9 89       	ldd	r30, Y+17	; 0x11
    4db0:	fa 89       	ldd	r31, Y+18	; 0x12
    4db2:	91 83       	std	Z+1, r25	; 0x01
    4db4:	80 83       	st	Z, r24
		}
		#endif /* portHAS_STACK_OVERFLOW_CHECKING */
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( pxCreatedTask != NULL )
    4db6:	8f 85       	ldd	r24, Y+15	; 0x0f
    4db8:	98 89       	ldd	r25, Y+16	; 0x10
    4dba:	00 97       	sbiw	r24, 0x00	; 0
    4dbc:	31 f0       	breq	.+12     	; 0x4dca <prvInitialiseNewTask+0x154>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    4dbe:	ef 85       	ldd	r30, Y+15	; 0x0f
    4dc0:	f8 89       	ldd	r31, Y+16	; 0x10
    4dc2:	89 89       	ldd	r24, Y+17	; 0x11
    4dc4:	9a 89       	ldd	r25, Y+18	; 0x12
    4dc6:	91 83       	std	Z+1, r25	; 0x01
    4dc8:	80 83       	st	Z, r24
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    4dca:	64 96       	adiw	r28, 0x14	; 20
    4dcc:	0f b6       	in	r0, 0x3f	; 63
    4dce:	f8 94       	cli
    4dd0:	de bf       	out	0x3e, r29	; 62
    4dd2:	0f be       	out	0x3f, r0	; 63
    4dd4:	cd bf       	out	0x3d, r28	; 61
    4dd6:	cf 91       	pop	r28
    4dd8:	df 91       	pop	r29
    4dda:	1f 91       	pop	r17
    4ddc:	0f 91       	pop	r16
    4dde:	ef 90       	pop	r14
    4de0:	df 90       	pop	r13
    4de2:	cf 90       	pop	r12
    4de4:	bf 90       	pop	r11
    4de6:	af 90       	pop	r10
    4de8:	9f 90       	pop	r9
    4dea:	8f 90       	pop	r8
    4dec:	08 95       	ret

00004dee <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
    4dee:	df 93       	push	r29
    4df0:	cf 93       	push	r28
    4df2:	00 d0       	rcall	.+0      	; 0x4df4 <prvAddNewTaskToReadyList+0x6>
    4df4:	cd b7       	in	r28, 0x3d	; 61
    4df6:	de b7       	in	r29, 0x3e	; 62
    4df8:	9a 83       	std	Y+2, r25	; 0x02
    4dfa:	89 83       	std	Y+1, r24	; 0x01
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
    4dfc:	0f b6       	in	r0, 0x3f	; 63
    4dfe:	f8 94       	cli
    4e00:	0f 92       	push	r0
	{
		uxCurrentNumberOfTasks++;
    4e02:	80 91 ac 06 	lds	r24, 0x06AC
    4e06:	8f 5f       	subi	r24, 0xFF	; 255
    4e08:	80 93 ac 06 	sts	0x06AC, r24
		if( pxCurrentTCB == NULL )
    4e0c:	80 91 a9 06 	lds	r24, 0x06A9
    4e10:	90 91 aa 06 	lds	r25, 0x06AA
    4e14:	00 97       	sbiw	r24, 0x00	; 0
    4e16:	69 f4       	brne	.+26     	; 0x4e32 <prvAddNewTaskToReadyList+0x44>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
    4e18:	89 81       	ldd	r24, Y+1	; 0x01
    4e1a:	9a 81       	ldd	r25, Y+2	; 0x02
    4e1c:	90 93 aa 06 	sts	0x06AA, r25
    4e20:	80 93 a9 06 	sts	0x06A9, r24

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    4e24:	80 91 ac 06 	lds	r24, 0x06AC
    4e28:	81 30       	cpi	r24, 0x01	; 1
    4e2a:	b9 f4       	brne	.+46     	; 0x4e5a <prvAddNewTaskToReadyList+0x6c>
			{
				/* This is the first task to be created so do the preliminary
				initialisation required.  We will not recover if this call
				fails, but we will report the failure. */
				prvInitialiseTaskLists();
    4e2c:	0e 94 ce 2d 	call	0x5b9c	; 0x5b9c <prvInitialiseTaskLists>
    4e30:	14 c0       	rjmp	.+40     	; 0x4e5a <prvAddNewTaskToReadyList+0x6c>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
    4e32:	80 91 b0 06 	lds	r24, 0x06B0
    4e36:	88 23       	and	r24, r24
    4e38:	81 f4       	brne	.+32     	; 0x4e5a <prvAddNewTaskToReadyList+0x6c>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    4e3a:	e0 91 a9 06 	lds	r30, 0x06A9
    4e3e:	f0 91 aa 06 	lds	r31, 0x06AA
    4e42:	96 89       	ldd	r25, Z+22	; 0x16
    4e44:	e9 81       	ldd	r30, Y+1	; 0x01
    4e46:	fa 81       	ldd	r31, Y+2	; 0x02
    4e48:	86 89       	ldd	r24, Z+22	; 0x16
    4e4a:	89 17       	cp	r24, r25
    4e4c:	30 f0       	brcs	.+12     	; 0x4e5a <prvAddNewTaskToReadyList+0x6c>
				{
					pxCurrentTCB = pxNewTCB;
    4e4e:	89 81       	ldd	r24, Y+1	; 0x01
    4e50:	9a 81       	ldd	r25, Y+2	; 0x02
    4e52:	90 93 aa 06 	sts	0x06AA, r25
    4e56:	80 93 a9 06 	sts	0x06A9, r24
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
    4e5a:	80 91 b4 06 	lds	r24, 0x06B4
    4e5e:	8f 5f       	subi	r24, 0xFF	; 255
    4e60:	80 93 b4 06 	sts	0x06B4, r24
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
    4e64:	e9 81       	ldd	r30, Y+1	; 0x01
    4e66:	fa 81       	ldd	r31, Y+2	; 0x02
    4e68:	96 89       	ldd	r25, Z+22	; 0x16
    4e6a:	80 91 af 06 	lds	r24, 0x06AF
    4e6e:	89 17       	cp	r24, r25
    4e70:	28 f4       	brcc	.+10     	; 0x4e7c <prvAddNewTaskToReadyList+0x8e>
    4e72:	e9 81       	ldd	r30, Y+1	; 0x01
    4e74:	fa 81       	ldd	r31, Y+2	; 0x02
    4e76:	86 89       	ldd	r24, Z+22	; 0x16
    4e78:	80 93 af 06 	sts	0x06AF, r24
    4e7c:	e9 81       	ldd	r30, Y+1	; 0x01
    4e7e:	fa 81       	ldd	r31, Y+2	; 0x02
    4e80:	86 89       	ldd	r24, Z+22	; 0x16
    4e82:	28 2f       	mov	r18, r24
    4e84:	30 e0       	ldi	r19, 0x00	; 0
    4e86:	c9 01       	movw	r24, r18
    4e88:	88 0f       	add	r24, r24
    4e8a:	99 1f       	adc	r25, r25
    4e8c:	88 0f       	add	r24, r24
    4e8e:	99 1f       	adc	r25, r25
    4e90:	88 0f       	add	r24, r24
    4e92:	99 1f       	adc	r25, r25
    4e94:	82 0f       	add	r24, r18
    4e96:	93 1f       	adc	r25, r19
    4e98:	ac 01       	movw	r20, r24
    4e9a:	46 54       	subi	r20, 0x46	; 70
    4e9c:	59 4f       	sbci	r21, 0xF9	; 249
    4e9e:	89 81       	ldd	r24, Y+1	; 0x01
    4ea0:	9a 81       	ldd	r25, Y+2	; 0x02
    4ea2:	9c 01       	movw	r18, r24
    4ea4:	2e 5f       	subi	r18, 0xFE	; 254
    4ea6:	3f 4f       	sbci	r19, 0xFF	; 255
    4ea8:	ca 01       	movw	r24, r20
    4eaa:	b9 01       	movw	r22, r18
    4eac:	0e 94 63 11 	call	0x22c6	; 0x22c6 <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
    4eb0:	0f 90       	pop	r0
    4eb2:	0f be       	out	0x3f, r0	; 63

	if( xSchedulerRunning != pdFALSE )
    4eb4:	80 91 b0 06 	lds	r24, 0x06B0
    4eb8:	88 23       	and	r24, r24
    4eba:	61 f0       	breq	.+24     	; 0x4ed4 <prvAddNewTaskToReadyList+0xe6>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    4ebc:	e0 91 a9 06 	lds	r30, 0x06A9
    4ec0:	f0 91 aa 06 	lds	r31, 0x06AA
    4ec4:	96 89       	ldd	r25, Z+22	; 0x16
    4ec6:	e9 81       	ldd	r30, Y+1	; 0x01
    4ec8:	fa 81       	ldd	r31, Y+2	; 0x02
    4eca:	86 89       	ldd	r24, Z+22	; 0x16
    4ecc:	98 17       	cp	r25, r24
    4ece:	10 f4       	brcc	.+4      	; 0x4ed4 <prvAddNewTaskToReadyList+0xe6>
		{
			taskYIELD_IF_USING_PREEMPTION();
    4ed0:	0e 94 d8 15 	call	0x2bb0	; 0x2bb0 <vPortYield>
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    4ed4:	0f 90       	pop	r0
    4ed6:	0f 90       	pop	r0
    4ed8:	cf 91       	pop	r28
    4eda:	df 91       	pop	r29
    4edc:	08 95       	ret

00004ede <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
    4ede:	df 93       	push	r29
    4ee0:	cf 93       	push	r28
    4ee2:	00 d0       	rcall	.+0      	; 0x4ee4 <vTaskDelete+0x6>
    4ee4:	00 d0       	rcall	.+0      	; 0x4ee6 <vTaskDelete+0x8>
    4ee6:	00 d0       	rcall	.+0      	; 0x4ee8 <vTaskDelete+0xa>
    4ee8:	cd b7       	in	r28, 0x3d	; 61
    4eea:	de b7       	in	r29, 0x3e	; 62
    4eec:	9c 83       	std	Y+4, r25	; 0x04
    4eee:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    4ef0:	0f b6       	in	r0, 0x3f	; 63
    4ef2:	f8 94       	cli
    4ef4:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    4ef6:	8b 81       	ldd	r24, Y+3	; 0x03
    4ef8:	9c 81       	ldd	r25, Y+4	; 0x04
    4efa:	00 97       	sbiw	r24, 0x00	; 0
    4efc:	39 f4       	brne	.+14     	; 0x4f0c <vTaskDelete+0x2e>
    4efe:	80 91 a9 06 	lds	r24, 0x06A9
    4f02:	90 91 aa 06 	lds	r25, 0x06AA
    4f06:	9e 83       	std	Y+6, r25	; 0x06
    4f08:	8d 83       	std	Y+5, r24	; 0x05
    4f0a:	04 c0       	rjmp	.+8      	; 0x4f14 <vTaskDelete+0x36>
    4f0c:	8b 81       	ldd	r24, Y+3	; 0x03
    4f0e:	9c 81       	ldd	r25, Y+4	; 0x04
    4f10:	9e 83       	std	Y+6, r25	; 0x06
    4f12:	8d 83       	std	Y+5, r24	; 0x05
    4f14:	8d 81       	ldd	r24, Y+5	; 0x05
    4f16:	9e 81       	ldd	r25, Y+6	; 0x06
    4f18:	9a 83       	std	Y+2, r25	; 0x02
    4f1a:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    4f1c:	89 81       	ldd	r24, Y+1	; 0x01
    4f1e:	9a 81       	ldd	r25, Y+2	; 0x02
    4f20:	02 96       	adiw	r24, 0x02	; 2
    4f22:	0e 94 13 12 	call	0x2426	; 0x2426 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    4f26:	e9 81       	ldd	r30, Y+1	; 0x01
    4f28:	fa 81       	ldd	r31, Y+2	; 0x02
    4f2a:	84 89       	ldd	r24, Z+20	; 0x14
    4f2c:	95 89       	ldd	r25, Z+21	; 0x15
    4f2e:	00 97       	sbiw	r24, 0x00	; 0
    4f30:	29 f0       	breq	.+10     	; 0x4f3c <vTaskDelete+0x5e>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    4f32:	89 81       	ldd	r24, Y+1	; 0x01
    4f34:	9a 81       	ldd	r25, Y+2	; 0x02
    4f36:	0c 96       	adiw	r24, 0x0c	; 12
    4f38:	0e 94 13 12 	call	0x2426	; 0x2426 <uxListRemove>

			/* Increment the uxTaskNumber also so kernel aware debuggers can
			detect that the task lists need re-generating.  This is done before
			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
			not return. */
			uxTaskNumber++;
    4f3c:	80 91 b4 06 	lds	r24, 0x06B4
    4f40:	8f 5f       	subi	r24, 0xFF	; 255
    4f42:	80 93 b4 06 	sts	0x06B4, r24

			if( pxTCB == pxCurrentTCB )
    4f46:	20 91 a9 06 	lds	r18, 0x06A9
    4f4a:	30 91 aa 06 	lds	r19, 0x06AA
    4f4e:	89 81       	ldd	r24, Y+1	; 0x01
    4f50:	9a 81       	ldd	r25, Y+2	; 0x02
    4f52:	82 17       	cp	r24, r18
    4f54:	93 07       	cpc	r25, r19
    4f56:	81 f4       	brne	.+32     	; 0x4f78 <vTaskDelete+0x9a>
				/* A task is deleting itself.  This cannot complete within the
				task itself, as a context switch to another task is required.
				Place the task in the termination list.  The idle task will
				check the termination list and free up any memory allocated by
				the scheduler for the TCB and stack of the deleted task. */
				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
    4f58:	89 81       	ldd	r24, Y+1	; 0x01
    4f5a:	9a 81       	ldd	r25, Y+2	; 0x02
    4f5c:	9c 01       	movw	r18, r24
    4f5e:	2e 5f       	subi	r18, 0xFE	; 254
    4f60:	3f 4f       	sbci	r19, 0xFF	; 255
    4f62:	8d ef       	ldi	r24, 0xFD	; 253
    4f64:	96 e0       	ldi	r25, 0x06	; 6
    4f66:	b9 01       	movw	r22, r18
    4f68:	0e 94 63 11 	call	0x22c6	; 0x22c6 <vListInsertEnd>

				/* Increment the ucTasksDeleted variable so the idle task knows
				there is a task that has been deleted and that it should therefore
				check the xTasksWaitingTermination list. */
				++uxDeletedTasksWaitingCleanUp;
    4f6c:	80 91 ab 06 	lds	r24, 0x06AB
    4f70:	8f 5f       	subi	r24, 0xFF	; 255
    4f72:	80 93 ab 06 	sts	0x06AB, r24
    4f76:	0b c0       	rjmp	.+22     	; 0x4f8e <vTaskDelete+0xb0>
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
			}
			else
			{
				--uxCurrentNumberOfTasks;
    4f78:	80 91 ac 06 	lds	r24, 0x06AC
    4f7c:	81 50       	subi	r24, 0x01	; 1
    4f7e:	80 93 ac 06 	sts	0x06AC, r24
				prvDeleteTCB( pxTCB );
    4f82:	89 81       	ldd	r24, Y+1	; 0x01
    4f84:	9a 81       	ldd	r25, Y+2	; 0x02
    4f86:	0e 94 3e 2e 	call	0x5c7c	; 0x5c7c <prvDeleteTCB>

				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				prvResetNextTaskUnblockTime();
    4f8a:	0e 94 54 2e 	call	0x5ca8	; 0x5ca8 <prvResetNextTaskUnblockTime>
			}

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    4f8e:	0f 90       	pop	r0
    4f90:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
    4f92:	80 91 b0 06 	lds	r24, 0x06B0
    4f96:	88 23       	and	r24, r24
    4f98:	59 f0       	breq	.+22     	; 0x4fb0 <vTaskDelete+0xd2>
		{
			if( pxTCB == pxCurrentTCB )
    4f9a:	20 91 a9 06 	lds	r18, 0x06A9
    4f9e:	30 91 aa 06 	lds	r19, 0x06AA
    4fa2:	89 81       	ldd	r24, Y+1	; 0x01
    4fa4:	9a 81       	ldd	r25, Y+2	; 0x02
    4fa6:	82 17       	cp	r24, r18
    4fa8:	93 07       	cpc	r25, r19
    4faa:	11 f4       	brne	.+4      	; 0x4fb0 <vTaskDelete+0xd2>
			{
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    4fac:	0e 94 d8 15 	call	0x2bb0	; 0x2bb0 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
    4fb0:	26 96       	adiw	r28, 0x06	; 6
    4fb2:	0f b6       	in	r0, 0x3f	; 63
    4fb4:	f8 94       	cli
    4fb6:	de bf       	out	0x3e, r29	; 62
    4fb8:	0f be       	out	0x3f, r0	; 63
    4fba:	cd bf       	out	0x3d, r28	; 61
    4fbc:	cf 91       	pop	r28
    4fbe:	df 91       	pop	r29
    4fc0:	08 95       	ret

00004fc2 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    4fc2:	df 93       	push	r29
    4fc4:	cf 93       	push	r28
    4fc6:	00 d0       	rcall	.+0      	; 0x4fc8 <vTaskDelay+0x6>
    4fc8:	0f 92       	push	r0
    4fca:	cd b7       	in	r28, 0x3d	; 61
    4fcc:	de b7       	in	r29, 0x3e	; 62
    4fce:	9b 83       	std	Y+3, r25	; 0x03
    4fd0:	8a 83       	std	Y+2, r24	; 0x02
	BaseType_t xAlreadyYielded = pdFALSE;
    4fd2:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    4fd4:	8a 81       	ldd	r24, Y+2	; 0x02
    4fd6:	9b 81       	ldd	r25, Y+3	; 0x03
    4fd8:	00 97       	sbiw	r24, 0x00	; 0
    4fda:	51 f0       	breq	.+20     	; 0x4ff0 <vTaskDelay+0x2e>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    4fdc:	0e 94 ae 29 	call	0x535c	; 0x535c <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    4fe0:	8a 81       	ldd	r24, Y+2	; 0x02
    4fe2:	9b 81       	ldd	r25, Y+3	; 0x03
    4fe4:	60 e0       	ldi	r22, 0x00	; 0
    4fe6:	0e 94 60 32 	call	0x64c0	; 0x64c0 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    4fea:	0e 94 ba 29 	call	0x5374	; 0x5374 <xTaskResumeAll>
    4fee:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    4ff0:	89 81       	ldd	r24, Y+1	; 0x01
    4ff2:	88 23       	and	r24, r24
    4ff4:	11 f4       	brne	.+4      	; 0x4ffa <vTaskDelay+0x38>
		{
			portYIELD_WITHIN_API();
    4ff6:	0e 94 d8 15 	call	0x2bb0	; 0x2bb0 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    4ffa:	0f 90       	pop	r0
    4ffc:	0f 90       	pop	r0
    4ffe:	0f 90       	pop	r0
    5000:	cf 91       	pop	r28
    5002:	df 91       	pop	r29
    5004:	08 95       	ret

00005006 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
	{
    5006:	df 93       	push	r29
    5008:	cf 93       	push	r28
    500a:	00 d0       	rcall	.+0      	; 0x500c <vTaskSuspend+0x6>
    500c:	00 d0       	rcall	.+0      	; 0x500e <vTaskSuspend+0x8>
    500e:	00 d0       	rcall	.+0      	; 0x5010 <vTaskSuspend+0xa>
    5010:	cd b7       	in	r28, 0x3d	; 61
    5012:	de b7       	in	r29, 0x3e	; 62
    5014:	9c 83       	std	Y+4, r25	; 0x04
    5016:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    5018:	0f b6       	in	r0, 0x3f	; 63
    501a:	f8 94       	cli
    501c:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the running task that is
			being suspended. */
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
    501e:	8b 81       	ldd	r24, Y+3	; 0x03
    5020:	9c 81       	ldd	r25, Y+4	; 0x04
    5022:	00 97       	sbiw	r24, 0x00	; 0
    5024:	39 f4       	brne	.+14     	; 0x5034 <vTaskSuspend+0x2e>
    5026:	80 91 a9 06 	lds	r24, 0x06A9
    502a:	90 91 aa 06 	lds	r25, 0x06AA
    502e:	9e 83       	std	Y+6, r25	; 0x06
    5030:	8d 83       	std	Y+5, r24	; 0x05
    5032:	04 c0       	rjmp	.+8      	; 0x503c <vTaskSuspend+0x36>
    5034:	8b 81       	ldd	r24, Y+3	; 0x03
    5036:	9c 81       	ldd	r25, Y+4	; 0x04
    5038:	9e 83       	std	Y+6, r25	; 0x06
    503a:	8d 83       	std	Y+5, r24	; 0x05
    503c:	8d 81       	ldd	r24, Y+5	; 0x05
    503e:	9e 81       	ldd	r25, Y+6	; 0x06
    5040:	9a 83       	std	Y+2, r25	; 0x02
    5042:	89 83       	std	Y+1, r24	; 0x01

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the
			suspended list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    5044:	89 81       	ldd	r24, Y+1	; 0x01
    5046:	9a 81       	ldd	r25, Y+2	; 0x02
    5048:	02 96       	adiw	r24, 0x02	; 2
    504a:	0e 94 13 12 	call	0x2426	; 0x2426 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    504e:	e9 81       	ldd	r30, Y+1	; 0x01
    5050:	fa 81       	ldd	r31, Y+2	; 0x02
    5052:	84 89       	ldd	r24, Z+20	; 0x14
    5054:	95 89       	ldd	r25, Z+21	; 0x15
    5056:	00 97       	sbiw	r24, 0x00	; 0
    5058:	29 f0       	breq	.+10     	; 0x5064 <vTaskSuspend+0x5e>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    505a:	89 81       	ldd	r24, Y+1	; 0x01
    505c:	9a 81       	ldd	r25, Y+2	; 0x02
    505e:	0c 96       	adiw	r24, 0x0c	; 12
    5060:	0e 94 13 12 	call	0x2426	; 0x2426 <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
    5064:	89 81       	ldd	r24, Y+1	; 0x01
    5066:	9a 81       	ldd	r25, Y+2	; 0x02
    5068:	9c 01       	movw	r18, r24
    506a:	2e 5f       	subi	r18, 0xFE	; 254
    506c:	3f 4f       	sbci	r19, 0xFF	; 255
    506e:	86 e0       	ldi	r24, 0x06	; 6
    5070:	97 e0       	ldi	r25, 0x07	; 7
    5072:	b9 01       	movw	r22, r18
    5074:	0e 94 63 11 	call	0x22c6	; 0x22c6 <vListInsertEnd>

			#if( configUSE_TASK_NOTIFICATIONS == 1 )
			{
				if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
    5078:	e9 81       	ldd	r30, Y+1	; 0x01
    507a:	fa 81       	ldd	r31, Y+2	; 0x02
    507c:	85 a1       	ldd	r24, Z+37	; 0x25
    507e:	81 30       	cpi	r24, 0x01	; 1
    5080:	19 f4       	brne	.+6      	; 0x5088 <vTaskSuspend+0x82>
				{
					/* The task was blocked to wait for a notification, but is
					now suspended, so no notification was received. */
					pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    5082:	e9 81       	ldd	r30, Y+1	; 0x01
    5084:	fa 81       	ldd	r31, Y+2	; 0x02
    5086:	15 a2       	std	Z+37, r1	; 0x25
				}
			}
			#endif
		}
		taskEXIT_CRITICAL();
    5088:	0f 90       	pop	r0
    508a:	0f be       	out	0x3f, r0	; 63

		if( xSchedulerRunning != pdFALSE )
    508c:	80 91 b0 06 	lds	r24, 0x06B0
    5090:	88 23       	and	r24, r24
    5092:	39 f0       	breq	.+14     	; 0x50a2 <vTaskSuspend+0x9c>
		{
			/* Reset the next expected unblock time in case it referred to the
			task that is now in the Suspended state. */
			taskENTER_CRITICAL();
    5094:	0f b6       	in	r0, 0x3f	; 63
    5096:	f8 94       	cli
    5098:	0f 92       	push	r0
			{
				prvResetNextTaskUnblockTime();
    509a:	0e 94 54 2e 	call	0x5ca8	; 0x5ca8 <prvResetNextTaskUnblockTime>
			}
			taskEXIT_CRITICAL();
    509e:	0f 90       	pop	r0
    50a0:	0f be       	out	0x3f, r0	; 63
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( pxTCB == pxCurrentTCB )
    50a2:	20 91 a9 06 	lds	r18, 0x06A9
    50a6:	30 91 aa 06 	lds	r19, 0x06AA
    50aa:	89 81       	ldd	r24, Y+1	; 0x01
    50ac:	9a 81       	ldd	r25, Y+2	; 0x02
    50ae:	82 17       	cp	r24, r18
    50b0:	93 07       	cpc	r25, r19
    50b2:	a1 f4       	brne	.+40     	; 0x50dc <vTaskSuspend+0xd6>
		{
			if( xSchedulerRunning != pdFALSE )
    50b4:	80 91 b0 06 	lds	r24, 0x06B0
    50b8:	88 23       	and	r24, r24
    50ba:	19 f0       	breq	.+6      	; 0x50c2 <vTaskSuspend+0xbc>
			{
				/* The current task has just been suspended. */
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    50bc:	0e 94 d8 15 	call	0x2bb0	; 0x2bb0 <vPortYield>
    50c0:	0d c0       	rjmp	.+26     	; 0x50dc <vTaskSuspend+0xd6>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*lint !e931 Right has no side effect, just volatile. */
    50c2:	90 91 06 07 	lds	r25, 0x0706
    50c6:	80 91 ac 06 	lds	r24, 0x06AC
    50ca:	98 17       	cp	r25, r24
    50cc:	29 f4       	brne	.+10     	; 0x50d8 <vTaskSuspend+0xd2>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
    50ce:	10 92 aa 06 	sts	0x06AA, r1
    50d2:	10 92 a9 06 	sts	0x06A9, r1
    50d6:	02 c0       	rjmp	.+4      	; 0x50dc <vTaskSuspend+0xd6>
				}
				else
				{
					vTaskSwitchContext();
    50d8:	0e 94 8f 2b 	call	0x571e	; 0x571e <vTaskSwitchContext>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    50dc:	26 96       	adiw	r28, 0x06	; 6
    50de:	0f b6       	in	r0, 0x3f	; 63
    50e0:	f8 94       	cli
    50e2:	de bf       	out	0x3e, r29	; 62
    50e4:	0f be       	out	0x3f, r0	; 63
    50e6:	cd bf       	out	0x3d, r28	; 61
    50e8:	cf 91       	pop	r28
    50ea:	df 91       	pop	r29
    50ec:	08 95       	ret

000050ee <prvTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
	{
    50ee:	df 93       	push	r29
    50f0:	cf 93       	push	r28
    50f2:	00 d0       	rcall	.+0      	; 0x50f4 <prvTaskIsTaskSuspended+0x6>
    50f4:	00 d0       	rcall	.+0      	; 0x50f6 <prvTaskIsTaskSuspended+0x8>
    50f6:	0f 92       	push	r0
    50f8:	cd b7       	in	r28, 0x3d	; 61
    50fa:	de b7       	in	r29, 0x3e	; 62
    50fc:	9d 83       	std	Y+5, r25	; 0x05
    50fe:	8c 83       	std	Y+4, r24	; 0x04
	BaseType_t xReturn = pdFALSE;
    5100:	1b 82       	std	Y+3, r1	; 0x03
	const TCB_t * const pxTCB = xTask;
    5102:	8c 81       	ldd	r24, Y+4	; 0x04
    5104:	9d 81       	ldd	r25, Y+5	; 0x05
    5106:	9a 83       	std	Y+2, r25	; 0x02
    5108:	89 83       	std	Y+1, r24	; 0x01

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
    510a:	e9 81       	ldd	r30, Y+1	; 0x01
    510c:	fa 81       	ldd	r31, Y+2	; 0x02
    510e:	82 85       	ldd	r24, Z+10	; 0x0a
    5110:	93 85       	ldd	r25, Z+11	; 0x0b
    5112:	27 e0       	ldi	r18, 0x07	; 7
    5114:	86 30       	cpi	r24, 0x06	; 6
    5116:	92 07       	cpc	r25, r18
    5118:	81 f4       	brne	.+32     	; 0x513a <prvTaskIsTaskSuspended+0x4c>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
    511a:	e9 81       	ldd	r30, Y+1	; 0x01
    511c:	fa 81       	ldd	r31, Y+2	; 0x02
    511e:	84 89       	ldd	r24, Z+20	; 0x14
    5120:	95 89       	ldd	r25, Z+21	; 0x15
    5122:	26 e0       	ldi	r18, 0x06	; 6
    5124:	84 3f       	cpi	r24, 0xF4	; 244
    5126:	92 07       	cpc	r25, r18
    5128:	41 f0       	breq	.+16     	; 0x513a <prvTaskIsTaskSuspended+0x4c>
			{
				/* Is it in the suspended list because it is in the	Suspended
				state, or because is is blocked with no timeout? */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */
    512a:	e9 81       	ldd	r30, Y+1	; 0x01
    512c:	fa 81       	ldd	r31, Y+2	; 0x02
    512e:	84 89       	ldd	r24, Z+20	; 0x14
    5130:	95 89       	ldd	r25, Z+21	; 0x15
    5132:	00 97       	sbiw	r24, 0x00	; 0
    5134:	11 f4       	brne	.+4      	; 0x513a <prvTaskIsTaskSuspended+0x4c>
				{
					xReturn = pdTRUE;
    5136:	81 e0       	ldi	r24, 0x01	; 1
    5138:	8b 83       	std	Y+3, r24	; 0x03
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
    513a:	8b 81       	ldd	r24, Y+3	; 0x03
	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
    513c:	0f 90       	pop	r0
    513e:	0f 90       	pop	r0
    5140:	0f 90       	pop	r0
    5142:	0f 90       	pop	r0
    5144:	0f 90       	pop	r0
    5146:	cf 91       	pop	r28
    5148:	df 91       	pop	r29
    514a:	08 95       	ret

0000514c <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( TaskHandle_t xTaskToResume )
	{
    514c:	df 93       	push	r29
    514e:	cf 93       	push	r28
    5150:	00 d0       	rcall	.+0      	; 0x5152 <vTaskResume+0x6>
    5152:	00 d0       	rcall	.+0      	; 0x5154 <vTaskResume+0x8>
    5154:	cd b7       	in	r28, 0x3d	; 61
    5156:	de b7       	in	r29, 0x3e	; 62
    5158:	9c 83       	std	Y+4, r25	; 0x04
    515a:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t * const pxTCB = xTaskToResume;
    515c:	8b 81       	ldd	r24, Y+3	; 0x03
    515e:	9c 81       	ldd	r25, Y+4	; 0x04
    5160:	9a 83       	std	Y+2, r25	; 0x02
    5162:	89 83       	std	Y+1, r24	; 0x01
		/* It does not make sense to resume the calling task. */
		configASSERT( xTaskToResume );

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != pxCurrentTCB ) && ( pxTCB != NULL ) )
    5164:	20 91 a9 06 	lds	r18, 0x06A9
    5168:	30 91 aa 06 	lds	r19, 0x06AA
    516c:	89 81       	ldd	r24, Y+1	; 0x01
    516e:	9a 81       	ldd	r25, Y+2	; 0x02
    5170:	82 17       	cp	r24, r18
    5172:	93 07       	cpc	r25, r19
    5174:	09 f4       	brne	.+2      	; 0x5178 <vTaskResume+0x2c>
    5176:	47 c0       	rjmp	.+142    	; 0x5206 <vTaskResume+0xba>
    5178:	89 81       	ldd	r24, Y+1	; 0x01
    517a:	9a 81       	ldd	r25, Y+2	; 0x02
    517c:	00 97       	sbiw	r24, 0x00	; 0
    517e:	09 f4       	brne	.+2      	; 0x5182 <vTaskResume+0x36>
    5180:	42 c0       	rjmp	.+132    	; 0x5206 <vTaskResume+0xba>
		{
			taskENTER_CRITICAL();
    5182:	0f b6       	in	r0, 0x3f	; 63
    5184:	f8 94       	cli
    5186:	0f 92       	push	r0
			{
				if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
    5188:	89 81       	ldd	r24, Y+1	; 0x01
    518a:	9a 81       	ldd	r25, Y+2	; 0x02
    518c:	0e 94 77 28 	call	0x50ee	; 0x50ee <prvTaskIsTaskSuspended>
    5190:	88 23       	and	r24, r24
    5192:	b9 f1       	breq	.+110    	; 0x5202 <vTaskResume+0xb6>
				{
					traceTASK_RESUME( pxTCB );

					/* The ready list can be accessed even if the scheduler is
					suspended because this is inside a critical section. */
					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
    5194:	89 81       	ldd	r24, Y+1	; 0x01
    5196:	9a 81       	ldd	r25, Y+2	; 0x02
    5198:	02 96       	adiw	r24, 0x02	; 2
    519a:	0e 94 13 12 	call	0x2426	; 0x2426 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    519e:	e9 81       	ldd	r30, Y+1	; 0x01
    51a0:	fa 81       	ldd	r31, Y+2	; 0x02
    51a2:	96 89       	ldd	r25, Z+22	; 0x16
    51a4:	80 91 af 06 	lds	r24, 0x06AF
    51a8:	89 17       	cp	r24, r25
    51aa:	28 f4       	brcc	.+10     	; 0x51b6 <vTaskResume+0x6a>
    51ac:	e9 81       	ldd	r30, Y+1	; 0x01
    51ae:	fa 81       	ldd	r31, Y+2	; 0x02
    51b0:	86 89       	ldd	r24, Z+22	; 0x16
    51b2:	80 93 af 06 	sts	0x06AF, r24
    51b6:	e9 81       	ldd	r30, Y+1	; 0x01
    51b8:	fa 81       	ldd	r31, Y+2	; 0x02
    51ba:	86 89       	ldd	r24, Z+22	; 0x16
    51bc:	28 2f       	mov	r18, r24
    51be:	30 e0       	ldi	r19, 0x00	; 0
    51c0:	c9 01       	movw	r24, r18
    51c2:	88 0f       	add	r24, r24
    51c4:	99 1f       	adc	r25, r25
    51c6:	88 0f       	add	r24, r24
    51c8:	99 1f       	adc	r25, r25
    51ca:	88 0f       	add	r24, r24
    51cc:	99 1f       	adc	r25, r25
    51ce:	82 0f       	add	r24, r18
    51d0:	93 1f       	adc	r25, r19
    51d2:	ac 01       	movw	r20, r24
    51d4:	46 54       	subi	r20, 0x46	; 70
    51d6:	59 4f       	sbci	r21, 0xF9	; 249
    51d8:	89 81       	ldd	r24, Y+1	; 0x01
    51da:	9a 81       	ldd	r25, Y+2	; 0x02
    51dc:	9c 01       	movw	r18, r24
    51de:	2e 5f       	subi	r18, 0xFE	; 254
    51e0:	3f 4f       	sbci	r19, 0xFF	; 255
    51e2:	ca 01       	movw	r24, r20
    51e4:	b9 01       	movw	r22, r18
    51e6:	0e 94 63 11 	call	0x22c6	; 0x22c6 <vListInsertEnd>

					/* A higher priority task may have just been resumed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    51ea:	e9 81       	ldd	r30, Y+1	; 0x01
    51ec:	fa 81       	ldd	r31, Y+2	; 0x02
    51ee:	96 89       	ldd	r25, Z+22	; 0x16
    51f0:	e0 91 a9 06 	lds	r30, 0x06A9
    51f4:	f0 91 aa 06 	lds	r31, 0x06AA
    51f8:	86 89       	ldd	r24, Z+22	; 0x16
    51fa:	98 17       	cp	r25, r24
    51fc:	10 f0       	brcs	.+4      	; 0x5202 <vTaskResume+0xb6>
					{
						/* This yield may not cause the task just resumed to run,
						but will leave the lists in the correct state for the
						next yield. */
						taskYIELD_IF_USING_PREEMPTION();
    51fe:	0e 94 d8 15 	call	0x2bb0	; 0x2bb0 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
    5202:	0f 90       	pop	r0
    5204:	0f be       	out	0x3f, r0	; 63
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    5206:	0f 90       	pop	r0
    5208:	0f 90       	pop	r0
    520a:	0f 90       	pop	r0
    520c:	0f 90       	pop	r0
    520e:	cf 91       	pop	r28
    5210:	df 91       	pop	r29
    5212:	08 95       	ret

00005214 <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
    5214:	df 93       	push	r29
    5216:	cf 93       	push	r28
    5218:	00 d0       	rcall	.+0      	; 0x521a <xTaskResumeFromISR+0x6>
    521a:	00 d0       	rcall	.+0      	; 0x521c <xTaskResumeFromISR+0x8>
    521c:	00 d0       	rcall	.+0      	; 0x521e <xTaskResumeFromISR+0xa>
    521e:	cd b7       	in	r28, 0x3d	; 61
    5220:	de b7       	in	r29, 0x3e	; 62
    5222:	9e 83       	std	Y+6, r25	; 0x06
    5224:	8d 83       	std	Y+5, r24	; 0x05
	BaseType_t xYieldRequired = pdFALSE;
    5226:	1c 82       	std	Y+4, r1	; 0x04
	TCB_t * const pxTCB = xTaskToResume;
    5228:	8d 81       	ldd	r24, Y+5	; 0x05
    522a:	9e 81       	ldd	r25, Y+6	; 0x06
    522c:	9b 83       	std	Y+3, r25	; 0x03
    522e:	8a 83       	std	Y+2, r24	; 0x02
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		https://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    5230:	19 82       	std	Y+1, r1	; 0x01
		{
			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
    5232:	8a 81       	ldd	r24, Y+2	; 0x02
    5234:	9b 81       	ldd	r25, Y+3	; 0x03
    5236:	0e 94 77 28 	call	0x50ee	; 0x50ee <prvTaskIsTaskSuspended>
    523a:	88 23       	and	r24, r24
    523c:	09 f4       	brne	.+2      	; 0x5240 <xTaskResumeFromISR+0x2c>
    523e:	46 c0       	rjmp	.+140    	; 0x52cc <xTaskResumeFromISR+0xb8>
			{
				traceTASK_RESUME_FROM_ISR( pxTCB );

				/* Check the ready lists can be accessed. */
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    5240:	80 91 b9 06 	lds	r24, 0x06B9
    5244:	88 23       	and	r24, r24
    5246:	c1 f5       	brne	.+112    	; 0x52b8 <xTaskResumeFromISR+0xa4>
				{
					/* Ready lists can be accessed so move the task from the
					suspended list to the ready list directly. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    5248:	ea 81       	ldd	r30, Y+2	; 0x02
    524a:	fb 81       	ldd	r31, Y+3	; 0x03
    524c:	96 89       	ldd	r25, Z+22	; 0x16
    524e:	e0 91 a9 06 	lds	r30, 0x06A9
    5252:	f0 91 aa 06 	lds	r31, 0x06AA
    5256:	86 89       	ldd	r24, Z+22	; 0x16
    5258:	98 17       	cp	r25, r24
    525a:	10 f0       	brcs	.+4      	; 0x5260 <xTaskResumeFromISR+0x4c>
					{
						xYieldRequired = pdTRUE;
    525c:	81 e0       	ldi	r24, 0x01	; 1
    525e:	8c 83       	std	Y+4, r24	; 0x04
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    5260:	8a 81       	ldd	r24, Y+2	; 0x02
    5262:	9b 81       	ldd	r25, Y+3	; 0x03
    5264:	02 96       	adiw	r24, 0x02	; 2
    5266:	0e 94 13 12 	call	0x2426	; 0x2426 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    526a:	ea 81       	ldd	r30, Y+2	; 0x02
    526c:	fb 81       	ldd	r31, Y+3	; 0x03
    526e:	96 89       	ldd	r25, Z+22	; 0x16
    5270:	80 91 af 06 	lds	r24, 0x06AF
    5274:	89 17       	cp	r24, r25
    5276:	28 f4       	brcc	.+10     	; 0x5282 <xTaskResumeFromISR+0x6e>
    5278:	ea 81       	ldd	r30, Y+2	; 0x02
    527a:	fb 81       	ldd	r31, Y+3	; 0x03
    527c:	86 89       	ldd	r24, Z+22	; 0x16
    527e:	80 93 af 06 	sts	0x06AF, r24
    5282:	ea 81       	ldd	r30, Y+2	; 0x02
    5284:	fb 81       	ldd	r31, Y+3	; 0x03
    5286:	86 89       	ldd	r24, Z+22	; 0x16
    5288:	28 2f       	mov	r18, r24
    528a:	30 e0       	ldi	r19, 0x00	; 0
    528c:	c9 01       	movw	r24, r18
    528e:	88 0f       	add	r24, r24
    5290:	99 1f       	adc	r25, r25
    5292:	88 0f       	add	r24, r24
    5294:	99 1f       	adc	r25, r25
    5296:	88 0f       	add	r24, r24
    5298:	99 1f       	adc	r25, r25
    529a:	82 0f       	add	r24, r18
    529c:	93 1f       	adc	r25, r19
    529e:	ac 01       	movw	r20, r24
    52a0:	46 54       	subi	r20, 0x46	; 70
    52a2:	59 4f       	sbci	r21, 0xF9	; 249
    52a4:	8a 81       	ldd	r24, Y+2	; 0x02
    52a6:	9b 81       	ldd	r25, Y+3	; 0x03
    52a8:	9c 01       	movw	r18, r24
    52aa:	2e 5f       	subi	r18, 0xFE	; 254
    52ac:	3f 4f       	sbci	r19, 0xFF	; 255
    52ae:	ca 01       	movw	r24, r20
    52b0:	b9 01       	movw	r22, r18
    52b2:	0e 94 63 11 	call	0x22c6	; 0x22c6 <vListInsertEnd>
    52b6:	0a c0       	rjmp	.+20     	; 0x52cc <xTaskResumeFromISR+0xb8>
				else
				{
					/* The delayed or ready lists cannot be accessed so the task
					is held in the pending ready list until the scheduler is
					unsuspended. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    52b8:	8a 81       	ldd	r24, Y+2	; 0x02
    52ba:	9b 81       	ldd	r25, Y+3	; 0x03
    52bc:	9c 01       	movw	r18, r24
    52be:	24 5f       	subi	r18, 0xF4	; 244
    52c0:	3f 4f       	sbci	r19, 0xFF	; 255
    52c2:	84 ef       	ldi	r24, 0xF4	; 244
    52c4:	96 e0       	ldi	r25, 0x06	; 6
    52c6:	b9 01       	movw	r22, r18
    52c8:	0e 94 63 11 	call	0x22c6	; 0x22c6 <vListInsertEnd>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
    52cc:	8c 81       	ldd	r24, Y+4	; 0x04
	}
    52ce:	26 96       	adiw	r28, 0x06	; 6
    52d0:	0f b6       	in	r0, 0x3f	; 63
    52d2:	f8 94       	cli
    52d4:	de bf       	out	0x3e, r29	; 62
    52d6:	0f be       	out	0x3f, r0	; 63
    52d8:	cd bf       	out	0x3d, r28	; 61
    52da:	cf 91       	pop	r28
    52dc:	df 91       	pop	r29
    52de:	08 95       	ret

000052e0 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    52e0:	ef 92       	push	r14
    52e2:	ff 92       	push	r15
    52e4:	0f 93       	push	r16
    52e6:	df 93       	push	r29
    52e8:	cf 93       	push	r28
    52ea:	0f 92       	push	r0
    52ec:	cd b7       	in	r28, 0x3d	; 61
    52ee:	de b7       	in	r29, 0x3e	; 62
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
    52f0:	84 ec       	ldi	r24, 0xC4	; 196
    52f2:	9d e2       	ldi	r25, 0x2D	; 45
    52f4:	2c ea       	ldi	r18, 0xAC	; 172
    52f6:	30 e0       	ldi	r19, 0x00	; 0
    52f8:	e7 eb       	ldi	r30, 0xB7	; 183
    52fa:	f6 e0       	ldi	r31, 0x06	; 6
    52fc:	b9 01       	movw	r22, r18
    52fe:	45 e5       	ldi	r20, 0x55	; 85
    5300:	50 e0       	ldi	r21, 0x00	; 0
    5302:	20 e0       	ldi	r18, 0x00	; 0
    5304:	30 e0       	ldi	r19, 0x00	; 0
    5306:	00 e0       	ldi	r16, 0x00	; 0
    5308:	7f 01       	movw	r14, r30
    530a:	0e 94 c3 25 	call	0x4b86	; 0x4b86 <xTaskCreate>
    530e:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
    5310:	89 81       	ldd	r24, Y+1	; 0x01
    5312:	81 30       	cpi	r24, 0x01	; 1
    5314:	81 f4       	brne	.+32     	; 0x5336 <vTaskStartScheduler+0x56>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
    5316:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
    5318:	8f ef       	ldi	r24, 0xFF	; 255
    531a:	9f ef       	ldi	r25, 0xFF	; 255
    531c:	90 93 b6 06 	sts	0x06B6, r25
    5320:	80 93 b5 06 	sts	0x06B5, r24
		xSchedulerRunning = pdTRUE;
    5324:	81 e0       	ldi	r24, 0x01	; 1
    5326:	80 93 b0 06 	sts	0x06B0, r24
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
    532a:	10 92 ae 06 	sts	0x06AE, r1
    532e:	10 92 ad 06 	sts	0x06AD, r1

		traceTASK_SWITCHED_IN();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    5332:	0e 94 9c 15 	call	0x2b38	; 0x2b38 <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
    5336:	0f 90       	pop	r0
    5338:	cf 91       	pop	r28
    533a:	df 91       	pop	r29
    533c:	0f 91       	pop	r16
    533e:	ff 90       	pop	r15
    5340:	ef 90       	pop	r14
    5342:	08 95       	ret

00005344 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    5344:	df 93       	push	r29
    5346:	cf 93       	push	r28
    5348:	cd b7       	in	r28, 0x3d	; 61
    534a:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    534c:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    534e:	10 92 b0 06 	sts	0x06B0, r1
	vPortEndScheduler();
    5352:	0e 94 d1 15 	call	0x2ba2	; 0x2ba2 <vPortEndScheduler>
}
    5356:	cf 91       	pop	r28
    5358:	df 91       	pop	r29
    535a:	08 95       	ret

0000535c <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    535c:	df 93       	push	r29
    535e:	cf 93       	push	r28
    5360:	cd b7       	in	r28, 0x3d	; 61
    5362:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    5364:	80 91 b9 06 	lds	r24, 0x06B9
    5368:	8f 5f       	subi	r24, 0xFF	; 255
    536a:	80 93 b9 06 	sts	0x06B9, r24
}
    536e:	cf 91       	pop	r28
    5370:	df 91       	pop	r29
    5372:	08 95       	ret

00005374 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    5374:	df 93       	push	r29
    5376:	cf 93       	push	r28
    5378:	00 d0       	rcall	.+0      	; 0x537a <xTaskResumeAll+0x6>
    537a:	00 d0       	rcall	.+0      	; 0x537c <xTaskResumeAll+0x8>
    537c:	cd b7       	in	r28, 0x3d	; 61
    537e:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB = NULL;
    5380:	1c 82       	std	Y+4, r1	; 0x04
    5382:	1b 82       	std	Y+3, r1	; 0x03
BaseType_t xAlreadyYielded = pdFALSE;
    5384:	1a 82       	std	Y+2, r1	; 0x02
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    5386:	0f b6       	in	r0, 0x3f	; 63
    5388:	f8 94       	cli
    538a:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    538c:	80 91 b9 06 	lds	r24, 0x06B9
    5390:	81 50       	subi	r24, 0x01	; 1
    5392:	80 93 b9 06 	sts	0x06B9, r24

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    5396:	80 91 b9 06 	lds	r24, 0x06B9
    539a:	88 23       	and	r24, r24
    539c:	09 f0       	breq	.+2      	; 0x53a0 <xTaskResumeAll+0x2c>
    539e:	73 c0       	rjmp	.+230    	; 0x5486 <xTaskResumeAll+0x112>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    53a0:	80 91 ac 06 	lds	r24, 0x06AC
    53a4:	88 23       	and	r24, r24
    53a6:	09 f4       	brne	.+2      	; 0x53aa <xTaskResumeAll+0x36>
    53a8:	6e c0       	rjmp	.+220    	; 0x5486 <xTaskResumeAll+0x112>
    53aa:	45 c0       	rjmp	.+138    	; 0x5436 <xTaskResumeAll+0xc2>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    53ac:	e0 91 f9 06 	lds	r30, 0x06F9
    53b0:	f0 91 fa 06 	lds	r31, 0x06FA
    53b4:	86 81       	ldd	r24, Z+6	; 0x06
    53b6:	97 81       	ldd	r25, Z+7	; 0x07
    53b8:	9c 83       	std	Y+4, r25	; 0x04
    53ba:	8b 83       	std	Y+3, r24	; 0x03
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    53bc:	8b 81       	ldd	r24, Y+3	; 0x03
    53be:	9c 81       	ldd	r25, Y+4	; 0x04
    53c0:	0c 96       	adiw	r24, 0x0c	; 12
    53c2:	0e 94 13 12 	call	0x2426	; 0x2426 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    53c6:	8b 81       	ldd	r24, Y+3	; 0x03
    53c8:	9c 81       	ldd	r25, Y+4	; 0x04
    53ca:	02 96       	adiw	r24, 0x02	; 2
    53cc:	0e 94 13 12 	call	0x2426	; 0x2426 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    53d0:	eb 81       	ldd	r30, Y+3	; 0x03
    53d2:	fc 81       	ldd	r31, Y+4	; 0x04
    53d4:	96 89       	ldd	r25, Z+22	; 0x16
    53d6:	80 91 af 06 	lds	r24, 0x06AF
    53da:	89 17       	cp	r24, r25
    53dc:	28 f4       	brcc	.+10     	; 0x53e8 <xTaskResumeAll+0x74>
    53de:	eb 81       	ldd	r30, Y+3	; 0x03
    53e0:	fc 81       	ldd	r31, Y+4	; 0x04
    53e2:	86 89       	ldd	r24, Z+22	; 0x16
    53e4:	80 93 af 06 	sts	0x06AF, r24
    53e8:	eb 81       	ldd	r30, Y+3	; 0x03
    53ea:	fc 81       	ldd	r31, Y+4	; 0x04
    53ec:	86 89       	ldd	r24, Z+22	; 0x16
    53ee:	28 2f       	mov	r18, r24
    53f0:	30 e0       	ldi	r19, 0x00	; 0
    53f2:	c9 01       	movw	r24, r18
    53f4:	88 0f       	add	r24, r24
    53f6:	99 1f       	adc	r25, r25
    53f8:	88 0f       	add	r24, r24
    53fa:	99 1f       	adc	r25, r25
    53fc:	88 0f       	add	r24, r24
    53fe:	99 1f       	adc	r25, r25
    5400:	82 0f       	add	r24, r18
    5402:	93 1f       	adc	r25, r19
    5404:	ac 01       	movw	r20, r24
    5406:	46 54       	subi	r20, 0x46	; 70
    5408:	59 4f       	sbci	r21, 0xF9	; 249
    540a:	8b 81       	ldd	r24, Y+3	; 0x03
    540c:	9c 81       	ldd	r25, Y+4	; 0x04
    540e:	9c 01       	movw	r18, r24
    5410:	2e 5f       	subi	r18, 0xFE	; 254
    5412:	3f 4f       	sbci	r19, 0xFF	; 255
    5414:	ca 01       	movw	r24, r20
    5416:	b9 01       	movw	r22, r18
    5418:	0e 94 63 11 	call	0x22c6	; 0x22c6 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    541c:	eb 81       	ldd	r30, Y+3	; 0x03
    541e:	fc 81       	ldd	r31, Y+4	; 0x04
    5420:	96 89       	ldd	r25, Z+22	; 0x16
    5422:	e0 91 a9 06 	lds	r30, 0x06A9
    5426:	f0 91 aa 06 	lds	r31, 0x06AA
    542a:	86 89       	ldd	r24, Z+22	; 0x16
    542c:	98 17       	cp	r25, r24
    542e:	18 f0       	brcs	.+6      	; 0x5436 <xTaskResumeAll+0xc2>
					{
						xYieldPending = pdTRUE;
    5430:	81 e0       	ldi	r24, 0x01	; 1
    5432:	80 93 b2 06 	sts	0x06B2, r24
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    5436:	80 91 f4 06 	lds	r24, 0x06F4
    543a:	88 23       	and	r24, r24
    543c:	09 f0       	breq	.+2      	; 0x5440 <xTaskResumeAll+0xcc>
    543e:	b6 cf       	rjmp	.-148    	; 0x53ac <xTaskResumeAll+0x38>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
    5440:	8b 81       	ldd	r24, Y+3	; 0x03
    5442:	9c 81       	ldd	r25, Y+4	; 0x04
    5444:	00 97       	sbiw	r24, 0x00	; 0
    5446:	11 f0       	breq	.+4      	; 0x544c <xTaskResumeAll+0xd8>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
    5448:	0e 94 54 2e 	call	0x5ca8	; 0x5ca8 <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
    544c:	80 91 b1 06 	lds	r24, 0x06B1
    5450:	89 83       	std	Y+1, r24	; 0x01

					if( uxPendedCounts > ( UBaseType_t ) 0U )
    5452:	89 81       	ldd	r24, Y+1	; 0x01
    5454:	88 23       	and	r24, r24
    5456:	79 f0       	breq	.+30     	; 0x5476 <xTaskResumeAll+0x102>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
    5458:	0e 94 aa 2a 	call	0x5554	; 0x5554 <xTaskIncrementTick>
    545c:	88 23       	and	r24, r24
    545e:	19 f0       	breq	.+6      	; 0x5466 <xTaskResumeAll+0xf2>
							{
								xYieldPending = pdTRUE;
    5460:	81 e0       	ldi	r24, 0x01	; 1
    5462:	80 93 b2 06 	sts	0x06B2, r24
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
    5466:	89 81       	ldd	r24, Y+1	; 0x01
    5468:	81 50       	subi	r24, 0x01	; 1
    546a:	89 83       	std	Y+1, r24	; 0x01
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
    546c:	89 81       	ldd	r24, Y+1	; 0x01
    546e:	88 23       	and	r24, r24
    5470:	99 f7       	brne	.-26     	; 0x5458 <xTaskResumeAll+0xe4>

						uxPendedTicks = 0;
    5472:	10 92 b1 06 	sts	0x06B1, r1
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
    5476:	80 91 b2 06 	lds	r24, 0x06B2
    547a:	88 23       	and	r24, r24
    547c:	21 f0       	breq	.+8      	; 0x5486 <xTaskResumeAll+0x112>
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
    547e:	81 e0       	ldi	r24, 0x01	; 1
    5480:	8a 83       	std	Y+2, r24	; 0x02
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
    5482:	0e 94 d8 15 	call	0x2bb0	; 0x2bb0 <vPortYield>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    5486:	0f 90       	pop	r0
    5488:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    548a:	8a 81       	ldd	r24, Y+2	; 0x02
}
    548c:	0f 90       	pop	r0
    548e:	0f 90       	pop	r0
    5490:	0f 90       	pop	r0
    5492:	0f 90       	pop	r0
    5494:	cf 91       	pop	r28
    5496:	df 91       	pop	r29
    5498:	08 95       	ret

0000549a <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
    549a:	df 93       	push	r29
    549c:	cf 93       	push	r28
    549e:	00 d0       	rcall	.+0      	; 0x54a0 <xTaskGetTickCount+0x6>
    54a0:	cd b7       	in	r28, 0x3d	; 61
    54a2:	de b7       	in	r29, 0x3e	; 62
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
    54a4:	0f b6       	in	r0, 0x3f	; 63
    54a6:	f8 94       	cli
    54a8:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    54aa:	80 91 ad 06 	lds	r24, 0x06AD
    54ae:	90 91 ae 06 	lds	r25, 0x06AE
    54b2:	9a 83       	std	Y+2, r25	; 0x02
    54b4:	89 83       	std	Y+1, r24	; 0x01
	}
	portTICK_TYPE_EXIT_CRITICAL();
    54b6:	0f 90       	pop	r0
    54b8:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    54ba:	89 81       	ldd	r24, Y+1	; 0x01
    54bc:	9a 81       	ldd	r25, Y+2	; 0x02
}
    54be:	0f 90       	pop	r0
    54c0:	0f 90       	pop	r0
    54c2:	cf 91       	pop	r28
    54c4:	df 91       	pop	r29
    54c6:	08 95       	ret

000054c8 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
    54c8:	df 93       	push	r29
    54ca:	cf 93       	push	r28
    54cc:	00 d0       	rcall	.+0      	; 0x54ce <xTaskGetTickCountFromISR+0x6>
    54ce:	0f 92       	push	r0
    54d0:	cd b7       	in	r28, 0x3d	; 61
    54d2:	de b7       	in	r29, 0x3e	; 62
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: https://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
    54d4:	19 82       	std	Y+1, r1	; 0x01
	{
		xReturn = xTickCount;
    54d6:	80 91 ad 06 	lds	r24, 0x06AD
    54da:	90 91 ae 06 	lds	r25, 0x06AE
    54de:	9b 83       	std	Y+3, r25	; 0x03
    54e0:	8a 83       	std	Y+2, r24	; 0x02
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    54e2:	8a 81       	ldd	r24, Y+2	; 0x02
    54e4:	9b 81       	ldd	r25, Y+3	; 0x03
}
    54e6:	0f 90       	pop	r0
    54e8:	0f 90       	pop	r0
    54ea:	0f 90       	pop	r0
    54ec:	cf 91       	pop	r28
    54ee:	df 91       	pop	r29
    54f0:	08 95       	ret

000054f2 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
    54f2:	df 93       	push	r29
    54f4:	cf 93       	push	r28
    54f6:	cd b7       	in	r28, 0x3d	; 61
    54f8:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
    54fa:	80 91 ac 06 	lds	r24, 0x06AC
}
    54fe:	cf 91       	pop	r28
    5500:	df 91       	pop	r29
    5502:	08 95       	ret

00005504 <pcTaskGetName>:
/*-----------------------------------------------------------*/

char *pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    5504:	df 93       	push	r29
    5506:	cf 93       	push	r28
    5508:	00 d0       	rcall	.+0      	; 0x550a <pcTaskGetName+0x6>
    550a:	00 d0       	rcall	.+0      	; 0x550c <pcTaskGetName+0x8>
    550c:	00 d0       	rcall	.+0      	; 0x550e <pcTaskGetName+0xa>
    550e:	cd b7       	in	r28, 0x3d	; 61
    5510:	de b7       	in	r29, 0x3e	; 62
    5512:	9c 83       	std	Y+4, r25	; 0x04
    5514:	8b 83       	std	Y+3, r24	; 0x03
TCB_t *pxTCB;

	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    5516:	8b 81       	ldd	r24, Y+3	; 0x03
    5518:	9c 81       	ldd	r25, Y+4	; 0x04
    551a:	00 97       	sbiw	r24, 0x00	; 0
    551c:	39 f4       	brne	.+14     	; 0x552c <pcTaskGetName+0x28>
    551e:	80 91 a9 06 	lds	r24, 0x06A9
    5522:	90 91 aa 06 	lds	r25, 0x06AA
    5526:	9e 83       	std	Y+6, r25	; 0x06
    5528:	8d 83       	std	Y+5, r24	; 0x05
    552a:	04 c0       	rjmp	.+8      	; 0x5534 <pcTaskGetName+0x30>
    552c:	8b 81       	ldd	r24, Y+3	; 0x03
    552e:	9c 81       	ldd	r25, Y+4	; 0x04
    5530:	9e 83       	std	Y+6, r25	; 0x06
    5532:	8d 83       	std	Y+5, r24	; 0x05
    5534:	8d 81       	ldd	r24, Y+5	; 0x05
    5536:	9e 81       	ldd	r25, Y+6	; 0x06
    5538:	9a 83       	std	Y+2, r25	; 0x02
    553a:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTCB );
	return &( pxTCB->pcTaskName[ 0 ] );
    553c:	89 81       	ldd	r24, Y+1	; 0x01
    553e:	9a 81       	ldd	r25, Y+2	; 0x02
    5540:	49 96       	adiw	r24, 0x19	; 25
}
    5542:	26 96       	adiw	r28, 0x06	; 6
    5544:	0f b6       	in	r0, 0x3f	; 63
    5546:	f8 94       	cli
    5548:	de bf       	out	0x3e, r29	; 62
    554a:	0f be       	out	0x3f, r0	; 63
    554c:	cd bf       	out	0x3d, r28	; 61
    554e:	cf 91       	pop	r28
    5550:	df 91       	pop	r29
    5552:	08 95       	ret

00005554 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    5554:	df 93       	push	r29
    5556:	cf 93       	push	r28
    5558:	cd b7       	in	r28, 0x3d	; 61
    555a:	de b7       	in	r29, 0x3e	; 62
    555c:	29 97       	sbiw	r28, 0x09	; 9
    555e:	0f b6       	in	r0, 0x3f	; 63
    5560:	f8 94       	cli
    5562:	de bf       	out	0x3e, r29	; 62
    5564:	0f be       	out	0x3f, r0	; 63
    5566:	cd bf       	out	0x3d, r28	; 61
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    5568:	1d 82       	std	Y+5, r1	; 0x05

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    556a:	80 91 b9 06 	lds	r24, 0x06B9
    556e:	88 23       	and	r24, r24
    5570:	09 f0       	breq	.+2      	; 0x5574 <xTaskIncrementTick+0x20>
    5572:	c0 c0       	rjmp	.+384    	; 0x56f4 <xTaskIncrementTick+0x1a0>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
    5574:	80 91 ad 06 	lds	r24, 0x06AD
    5578:	90 91 ae 06 	lds	r25, 0x06AE
    557c:	01 96       	adiw	r24, 0x01	; 1
    557e:	9c 83       	std	Y+4, r25	; 0x04
    5580:	8b 83       	std	Y+3, r24	; 0x03

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
    5582:	8b 81       	ldd	r24, Y+3	; 0x03
    5584:	9c 81       	ldd	r25, Y+4	; 0x04
    5586:	90 93 ae 06 	sts	0x06AE, r25
    558a:	80 93 ad 06 	sts	0x06AD, r24

		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
    558e:	8b 81       	ldd	r24, Y+3	; 0x03
    5590:	9c 81       	ldd	r25, Y+4	; 0x04
    5592:	00 97       	sbiw	r24, 0x00	; 0
    5594:	d9 f4       	brne	.+54     	; 0x55cc <xTaskIncrementTick+0x78>
		{
			taskSWITCH_DELAYED_LISTS();
    5596:	80 91 f0 06 	lds	r24, 0x06F0
    559a:	90 91 f1 06 	lds	r25, 0x06F1
    559e:	9a 83       	std	Y+2, r25	; 0x02
    55a0:	89 83       	std	Y+1, r24	; 0x01
    55a2:	80 91 f2 06 	lds	r24, 0x06F2
    55a6:	90 91 f3 06 	lds	r25, 0x06F3
    55aa:	90 93 f1 06 	sts	0x06F1, r25
    55ae:	80 93 f0 06 	sts	0x06F0, r24
    55b2:	89 81       	ldd	r24, Y+1	; 0x01
    55b4:	9a 81       	ldd	r25, Y+2	; 0x02
    55b6:	90 93 f3 06 	sts	0x06F3, r25
    55ba:	80 93 f2 06 	sts	0x06F2, r24
    55be:	80 91 b3 06 	lds	r24, 0x06B3
    55c2:	8f 5f       	subi	r24, 0xFF	; 255
    55c4:	80 93 b3 06 	sts	0x06B3, r24
    55c8:	0e 94 54 2e 	call	0x5ca8	; 0x5ca8 <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
    55cc:	20 91 b5 06 	lds	r18, 0x06B5
    55d0:	30 91 b6 06 	lds	r19, 0x06B6
    55d4:	8b 81       	ldd	r24, Y+3	; 0x03
    55d6:	9c 81       	ldd	r25, Y+4	; 0x04
    55d8:	82 17       	cp	r24, r18
    55da:	93 07       	cpc	r25, r19
    55dc:	08 f4       	brcc	.+2      	; 0x55e0 <xTaskIncrementTick+0x8c>
    55de:	71 c0       	rjmp	.+226    	; 0x56c2 <xTaskIncrementTick+0x16e>
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    55e0:	e0 91 f0 06 	lds	r30, 0x06F0
    55e4:	f0 91 f1 06 	lds	r31, 0x06F1
    55e8:	80 81       	ld	r24, Z
    55ea:	88 23       	and	r24, r24
    55ec:	39 f4       	brne	.+14     	; 0x55fc <xTaskIncrementTick+0xa8>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    55ee:	8f ef       	ldi	r24, 0xFF	; 255
    55f0:	9f ef       	ldi	r25, 0xFF	; 255
    55f2:	90 93 b6 06 	sts	0x06B6, r25
    55f6:	80 93 b5 06 	sts	0x06B5, r24
    55fa:	63 c0       	rjmp	.+198    	; 0x56c2 <xTaskIncrementTick+0x16e>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    55fc:	e0 91 f0 06 	lds	r30, 0x06F0
    5600:	f0 91 f1 06 	lds	r31, 0x06F1
    5604:	05 80       	ldd	r0, Z+5	; 0x05
    5606:	f6 81       	ldd	r31, Z+6	; 0x06
    5608:	e0 2d       	mov	r30, r0
    560a:	86 81       	ldd	r24, Z+6	; 0x06
    560c:	97 81       	ldd	r25, Z+7	; 0x07
    560e:	99 87       	std	Y+9, r25	; 0x09
    5610:	88 87       	std	Y+8, r24	; 0x08
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    5612:	e8 85       	ldd	r30, Y+8	; 0x08
    5614:	f9 85       	ldd	r31, Y+9	; 0x09
    5616:	82 81       	ldd	r24, Z+2	; 0x02
    5618:	93 81       	ldd	r25, Z+3	; 0x03
    561a:	9f 83       	std	Y+7, r25	; 0x07
    561c:	8e 83       	std	Y+6, r24	; 0x06

					if( xConstTickCount < xItemValue )
    561e:	2b 81       	ldd	r18, Y+3	; 0x03
    5620:	3c 81       	ldd	r19, Y+4	; 0x04
    5622:	8e 81       	ldd	r24, Y+6	; 0x06
    5624:	9f 81       	ldd	r25, Y+7	; 0x07
    5626:	28 17       	cp	r18, r24
    5628:	39 07       	cpc	r19, r25
    562a:	38 f4       	brcc	.+14     	; 0x563a <xTaskIncrementTick+0xe6>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
    562c:	8e 81       	ldd	r24, Y+6	; 0x06
    562e:	9f 81       	ldd	r25, Y+7	; 0x07
    5630:	90 93 b6 06 	sts	0x06B6, r25
    5634:	80 93 b5 06 	sts	0x06B5, r24
    5638:	44 c0       	rjmp	.+136    	; 0x56c2 <xTaskIncrementTick+0x16e>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    563a:	88 85       	ldd	r24, Y+8	; 0x08
    563c:	99 85       	ldd	r25, Y+9	; 0x09
    563e:	02 96       	adiw	r24, 0x02	; 2
    5640:	0e 94 13 12 	call	0x2426	; 0x2426 <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    5644:	e8 85       	ldd	r30, Y+8	; 0x08
    5646:	f9 85       	ldd	r31, Y+9	; 0x09
    5648:	84 89       	ldd	r24, Z+20	; 0x14
    564a:	95 89       	ldd	r25, Z+21	; 0x15
    564c:	00 97       	sbiw	r24, 0x00	; 0
    564e:	29 f0       	breq	.+10     	; 0x565a <xTaskIncrementTick+0x106>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    5650:	88 85       	ldd	r24, Y+8	; 0x08
    5652:	99 85       	ldd	r25, Y+9	; 0x09
    5654:	0c 96       	adiw	r24, 0x0c	; 12
    5656:	0e 94 13 12 	call	0x2426	; 0x2426 <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
    565a:	e8 85       	ldd	r30, Y+8	; 0x08
    565c:	f9 85       	ldd	r31, Y+9	; 0x09
    565e:	96 89       	ldd	r25, Z+22	; 0x16
    5660:	80 91 af 06 	lds	r24, 0x06AF
    5664:	89 17       	cp	r24, r25
    5666:	28 f4       	brcc	.+10     	; 0x5672 <xTaskIncrementTick+0x11e>
    5668:	e8 85       	ldd	r30, Y+8	; 0x08
    566a:	f9 85       	ldd	r31, Y+9	; 0x09
    566c:	86 89       	ldd	r24, Z+22	; 0x16
    566e:	80 93 af 06 	sts	0x06AF, r24
    5672:	e8 85       	ldd	r30, Y+8	; 0x08
    5674:	f9 85       	ldd	r31, Y+9	; 0x09
    5676:	86 89       	ldd	r24, Z+22	; 0x16
    5678:	28 2f       	mov	r18, r24
    567a:	30 e0       	ldi	r19, 0x00	; 0
    567c:	c9 01       	movw	r24, r18
    567e:	88 0f       	add	r24, r24
    5680:	99 1f       	adc	r25, r25
    5682:	88 0f       	add	r24, r24
    5684:	99 1f       	adc	r25, r25
    5686:	88 0f       	add	r24, r24
    5688:	99 1f       	adc	r25, r25
    568a:	82 0f       	add	r24, r18
    568c:	93 1f       	adc	r25, r19
    568e:	ac 01       	movw	r20, r24
    5690:	46 54       	subi	r20, 0x46	; 70
    5692:	59 4f       	sbci	r21, 0xF9	; 249
    5694:	88 85       	ldd	r24, Y+8	; 0x08
    5696:	99 85       	ldd	r25, Y+9	; 0x09
    5698:	9c 01       	movw	r18, r24
    569a:	2e 5f       	subi	r18, 0xFE	; 254
    569c:	3f 4f       	sbci	r19, 0xFF	; 255
    569e:	ca 01       	movw	r24, r20
    56a0:	b9 01       	movw	r22, r18
    56a2:	0e 94 63 11 	call	0x22c6	; 0x22c6 <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    56a6:	e8 85       	ldd	r30, Y+8	; 0x08
    56a8:	f9 85       	ldd	r31, Y+9	; 0x09
    56aa:	96 89       	ldd	r25, Z+22	; 0x16
    56ac:	e0 91 a9 06 	lds	r30, 0x06A9
    56b0:	f0 91 aa 06 	lds	r31, 0x06AA
    56b4:	86 89       	ldd	r24, Z+22	; 0x16
    56b6:	98 17       	cp	r25, r24
    56b8:	08 f4       	brcc	.+2      	; 0x56bc <xTaskIncrementTick+0x168>
    56ba:	92 cf       	rjmp	.-220    	; 0x55e0 <xTaskIncrementTick+0x8c>
						{
							xSwitchRequired = pdTRUE;
    56bc:	81 e0       	ldi	r24, 0x01	; 1
    56be:	8d 83       	std	Y+5, r24	; 0x05
    56c0:	8f cf       	rjmp	.-226    	; 0x55e0 <xTaskIncrementTick+0x8c>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    56c2:	e0 91 a9 06 	lds	r30, 0x06A9
    56c6:	f0 91 aa 06 	lds	r31, 0x06AA
    56ca:	86 89       	ldd	r24, Z+22	; 0x16
    56cc:	28 2f       	mov	r18, r24
    56ce:	30 e0       	ldi	r19, 0x00	; 0
    56d0:	c9 01       	movw	r24, r18
    56d2:	88 0f       	add	r24, r24
    56d4:	99 1f       	adc	r25, r25
    56d6:	88 0f       	add	r24, r24
    56d8:	99 1f       	adc	r25, r25
    56da:	88 0f       	add	r24, r24
    56dc:	99 1f       	adc	r25, r25
    56de:	82 0f       	add	r24, r18
    56e0:	93 1f       	adc	r25, r19
    56e2:	fc 01       	movw	r30, r24
    56e4:	e6 54       	subi	r30, 0x46	; 70
    56e6:	f9 4f       	sbci	r31, 0xF9	; 249
    56e8:	80 81       	ld	r24, Z
    56ea:	82 30       	cpi	r24, 0x02	; 2
    56ec:	40 f0       	brcs	.+16     	; 0x56fe <xTaskIncrementTick+0x1aa>
			{
				xSwitchRequired = pdTRUE;
    56ee:	81 e0       	ldi	r24, 0x01	; 1
    56f0:	8d 83       	std	Y+5, r24	; 0x05
    56f2:	05 c0       	rjmp	.+10     	; 0x56fe <xTaskIncrementTick+0x1aa>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
    56f4:	80 91 b1 06 	lds	r24, 0x06B1
    56f8:	8f 5f       	subi	r24, 0xFF	; 255
    56fa:	80 93 b1 06 	sts	0x06B1, r24
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
    56fe:	80 91 b2 06 	lds	r24, 0x06B2
    5702:	88 23       	and	r24, r24
    5704:	11 f0       	breq	.+4      	; 0x570a <xTaskIncrementTick+0x1b6>
		{
			xSwitchRequired = pdTRUE;
    5706:	81 e0       	ldi	r24, 0x01	; 1
    5708:	8d 83       	std	Y+5, r24	; 0x05
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
    570a:	8d 81       	ldd	r24, Y+5	; 0x05
}
    570c:	29 96       	adiw	r28, 0x09	; 9
    570e:	0f b6       	in	r0, 0x3f	; 63
    5710:	f8 94       	cli
    5712:	de bf       	out	0x3e, r29	; 62
    5714:	0f be       	out	0x3f, r0	; 63
    5716:	cd bf       	out	0x3d, r28	; 61
    5718:	cf 91       	pop	r28
    571a:	df 91       	pop	r29
    571c:	08 95       	ret

0000571e <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    571e:	df 93       	push	r29
    5720:	cf 93       	push	r28
    5722:	00 d0       	rcall	.+0      	; 0x5724 <vTaskSwitchContext+0x6>
    5724:	0f 92       	push	r0
    5726:	cd b7       	in	r28, 0x3d	; 61
    5728:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    572a:	80 91 b9 06 	lds	r24, 0x06B9
    572e:	88 23       	and	r24, r24
    5730:	21 f0       	breq	.+8      	; 0x573a <vTaskSwitchContext+0x1c>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    5732:	81 e0       	ldi	r24, 0x01	; 1
    5734:	80 93 b2 06 	sts	0x06B2, r24
    5738:	59 c0       	rjmp	.+178    	; 0x57ec <vTaskSwitchContext+0xce>
	}
	else
	{
		xYieldPending = pdFALSE;
    573a:	10 92 b2 06 	sts	0x06B2, r1
		}
		#endif

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    573e:	80 91 af 06 	lds	r24, 0x06AF
    5742:	8b 83       	std	Y+3, r24	; 0x03
    5744:	03 c0       	rjmp	.+6      	; 0x574c <vTaskSwitchContext+0x2e>
    5746:	8b 81       	ldd	r24, Y+3	; 0x03
    5748:	81 50       	subi	r24, 0x01	; 1
    574a:	8b 83       	std	Y+3, r24	; 0x03
    574c:	8b 81       	ldd	r24, Y+3	; 0x03
    574e:	28 2f       	mov	r18, r24
    5750:	30 e0       	ldi	r19, 0x00	; 0
    5752:	c9 01       	movw	r24, r18
    5754:	88 0f       	add	r24, r24
    5756:	99 1f       	adc	r25, r25
    5758:	88 0f       	add	r24, r24
    575a:	99 1f       	adc	r25, r25
    575c:	88 0f       	add	r24, r24
    575e:	99 1f       	adc	r25, r25
    5760:	82 0f       	add	r24, r18
    5762:	93 1f       	adc	r25, r19
    5764:	fc 01       	movw	r30, r24
    5766:	e6 54       	subi	r30, 0x46	; 70
    5768:	f9 4f       	sbci	r31, 0xF9	; 249
    576a:	80 81       	ld	r24, Z
    576c:	88 23       	and	r24, r24
    576e:	59 f3       	breq	.-42     	; 0x5746 <vTaskSwitchContext+0x28>
    5770:	8b 81       	ldd	r24, Y+3	; 0x03
    5772:	28 2f       	mov	r18, r24
    5774:	30 e0       	ldi	r19, 0x00	; 0
    5776:	c9 01       	movw	r24, r18
    5778:	88 0f       	add	r24, r24
    577a:	99 1f       	adc	r25, r25
    577c:	88 0f       	add	r24, r24
    577e:	99 1f       	adc	r25, r25
    5780:	88 0f       	add	r24, r24
    5782:	99 1f       	adc	r25, r25
    5784:	82 0f       	add	r24, r18
    5786:	93 1f       	adc	r25, r19
    5788:	86 54       	subi	r24, 0x46	; 70
    578a:	99 4f       	sbci	r25, 0xF9	; 249
    578c:	9a 83       	std	Y+2, r25	; 0x02
    578e:	89 83       	std	Y+1, r24	; 0x01
    5790:	e9 81       	ldd	r30, Y+1	; 0x01
    5792:	fa 81       	ldd	r31, Y+2	; 0x02
    5794:	01 80       	ldd	r0, Z+1	; 0x01
    5796:	f2 81       	ldd	r31, Z+2	; 0x02
    5798:	e0 2d       	mov	r30, r0
    579a:	82 81       	ldd	r24, Z+2	; 0x02
    579c:	93 81       	ldd	r25, Z+3	; 0x03
    579e:	e9 81       	ldd	r30, Y+1	; 0x01
    57a0:	fa 81       	ldd	r31, Y+2	; 0x02
    57a2:	92 83       	std	Z+2, r25	; 0x02
    57a4:	81 83       	std	Z+1, r24	; 0x01
    57a6:	e9 81       	ldd	r30, Y+1	; 0x01
    57a8:	fa 81       	ldd	r31, Y+2	; 0x02
    57aa:	21 81       	ldd	r18, Z+1	; 0x01
    57ac:	32 81       	ldd	r19, Z+2	; 0x02
    57ae:	89 81       	ldd	r24, Y+1	; 0x01
    57b0:	9a 81       	ldd	r25, Y+2	; 0x02
    57b2:	03 96       	adiw	r24, 0x03	; 3
    57b4:	28 17       	cp	r18, r24
    57b6:	39 07       	cpc	r19, r25
    57b8:	59 f4       	brne	.+22     	; 0x57d0 <vTaskSwitchContext+0xb2>
    57ba:	e9 81       	ldd	r30, Y+1	; 0x01
    57bc:	fa 81       	ldd	r31, Y+2	; 0x02
    57be:	01 80       	ldd	r0, Z+1	; 0x01
    57c0:	f2 81       	ldd	r31, Z+2	; 0x02
    57c2:	e0 2d       	mov	r30, r0
    57c4:	82 81       	ldd	r24, Z+2	; 0x02
    57c6:	93 81       	ldd	r25, Z+3	; 0x03
    57c8:	e9 81       	ldd	r30, Y+1	; 0x01
    57ca:	fa 81       	ldd	r31, Y+2	; 0x02
    57cc:	92 83       	std	Z+2, r25	; 0x02
    57ce:	81 83       	std	Z+1, r24	; 0x01
    57d0:	e9 81       	ldd	r30, Y+1	; 0x01
    57d2:	fa 81       	ldd	r31, Y+2	; 0x02
    57d4:	01 80       	ldd	r0, Z+1	; 0x01
    57d6:	f2 81       	ldd	r31, Z+2	; 0x02
    57d8:	e0 2d       	mov	r30, r0
    57da:	86 81       	ldd	r24, Z+6	; 0x06
    57dc:	97 81       	ldd	r25, Z+7	; 0x07
    57de:	90 93 aa 06 	sts	0x06AA, r25
    57e2:	80 93 a9 06 	sts	0x06A9, r24
    57e6:	8b 81       	ldd	r24, Y+3	; 0x03
    57e8:	80 93 af 06 	sts	0x06AF, r24
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
    57ec:	0f 90       	pop	r0
    57ee:	0f 90       	pop	r0
    57f0:	0f 90       	pop	r0
    57f2:	cf 91       	pop	r28
    57f4:	df 91       	pop	r29
    57f6:	08 95       	ret

000057f8 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
    57f8:	df 93       	push	r29
    57fa:	cf 93       	push	r28
    57fc:	00 d0       	rcall	.+0      	; 0x57fe <vTaskPlaceOnEventList+0x6>
    57fe:	00 d0       	rcall	.+0      	; 0x5800 <vTaskPlaceOnEventList+0x8>
    5800:	cd b7       	in	r28, 0x3d	; 61
    5802:	de b7       	in	r29, 0x3e	; 62
    5804:	9a 83       	std	Y+2, r25	; 0x02
    5806:	89 83       	std	Y+1, r24	; 0x01
    5808:	7c 83       	std	Y+4, r23	; 0x04
    580a:	6b 83       	std	Y+3, r22	; 0x03

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    580c:	80 91 a9 06 	lds	r24, 0x06A9
    5810:	90 91 aa 06 	lds	r25, 0x06AA
    5814:	9c 01       	movw	r18, r24
    5816:	24 5f       	subi	r18, 0xF4	; 244
    5818:	3f 4f       	sbci	r19, 0xFF	; 255
    581a:	89 81       	ldd	r24, Y+1	; 0x01
    581c:	9a 81       	ldd	r25, Y+2	; 0x02
    581e:	b9 01       	movw	r22, r18
    5820:	0e 94 a7 11 	call	0x234e	; 0x234e <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    5824:	8b 81       	ldd	r24, Y+3	; 0x03
    5826:	9c 81       	ldd	r25, Y+4	; 0x04
    5828:	61 e0       	ldi	r22, 0x01	; 1
    582a:	0e 94 60 32 	call	0x64c0	; 0x64c0 <prvAddCurrentTaskToDelayedList>
}
    582e:	0f 90       	pop	r0
    5830:	0f 90       	pop	r0
    5832:	0f 90       	pop	r0
    5834:	0f 90       	pop	r0
    5836:	cf 91       	pop	r28
    5838:	df 91       	pop	r29
    583a:	08 95       	ret

0000583c <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
    583c:	df 93       	push	r29
    583e:	cf 93       	push	r28
    5840:	00 d0       	rcall	.+0      	; 0x5842 <vTaskPlaceOnUnorderedEventList+0x6>
    5842:	00 d0       	rcall	.+0      	; 0x5844 <vTaskPlaceOnUnorderedEventList+0x8>
    5844:	00 d0       	rcall	.+0      	; 0x5846 <vTaskPlaceOnUnorderedEventList+0xa>
    5846:	cd b7       	in	r28, 0x3d	; 61
    5848:	de b7       	in	r29, 0x3e	; 62
    584a:	9a 83       	std	Y+2, r25	; 0x02
    584c:	89 83       	std	Y+1, r24	; 0x01
    584e:	7c 83       	std	Y+4, r23	; 0x04
    5850:	6b 83       	std	Y+3, r22	; 0x03
    5852:	5e 83       	std	Y+6, r21	; 0x06
    5854:	4d 83       	std	Y+5, r20	; 0x05
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    5856:	e0 91 a9 06 	lds	r30, 0x06A9
    585a:	f0 91 aa 06 	lds	r31, 0x06AA
    585e:	8b 81       	ldd	r24, Y+3	; 0x03
    5860:	9c 81       	ldd	r25, Y+4	; 0x04
    5862:	90 68       	ori	r25, 0x80	; 128
    5864:	95 87       	std	Z+13, r25	; 0x0d
    5866:	84 87       	std	Z+12, r24	; 0x0c
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    5868:	80 91 a9 06 	lds	r24, 0x06A9
    586c:	90 91 aa 06 	lds	r25, 0x06AA
    5870:	9c 01       	movw	r18, r24
    5872:	24 5f       	subi	r18, 0xF4	; 244
    5874:	3f 4f       	sbci	r19, 0xFF	; 255
    5876:	89 81       	ldd	r24, Y+1	; 0x01
    5878:	9a 81       	ldd	r25, Y+2	; 0x02
    587a:	b9 01       	movw	r22, r18
    587c:	0e 94 63 11 	call	0x22c6	; 0x22c6 <vListInsertEnd>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    5880:	8d 81       	ldd	r24, Y+5	; 0x05
    5882:	9e 81       	ldd	r25, Y+6	; 0x06
    5884:	61 e0       	ldi	r22, 0x01	; 1
    5886:	0e 94 60 32 	call	0x64c0	; 0x64c0 <prvAddCurrentTaskToDelayedList>
}
    588a:	26 96       	adiw	r28, 0x06	; 6
    588c:	0f b6       	in	r0, 0x3f	; 63
    588e:	f8 94       	cli
    5890:	de bf       	out	0x3e, r29	; 62
    5892:	0f be       	out	0x3f, r0	; 63
    5894:	cd bf       	out	0x3d, r28	; 61
    5896:	cf 91       	pop	r28
    5898:	df 91       	pop	r29
    589a:	08 95       	ret

0000589c <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    589c:	df 93       	push	r29
    589e:	cf 93       	push	r28
    58a0:	00 d0       	rcall	.+0      	; 0x58a2 <xTaskRemoveFromEventList+0x6>
    58a2:	00 d0       	rcall	.+0      	; 0x58a4 <xTaskRemoveFromEventList+0x8>
    58a4:	0f 92       	push	r0
    58a6:	cd b7       	in	r28, 0x3d	; 61
    58a8:	de b7       	in	r29, 0x3e	; 62
    58aa:	9d 83       	std	Y+5, r25	; 0x05
    58ac:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    58ae:	ec 81       	ldd	r30, Y+4	; 0x04
    58b0:	fd 81       	ldd	r31, Y+5	; 0x05
    58b2:	05 80       	ldd	r0, Z+5	; 0x05
    58b4:	f6 81       	ldd	r31, Z+6	; 0x06
    58b6:	e0 2d       	mov	r30, r0
    58b8:	86 81       	ldd	r24, Z+6	; 0x06
    58ba:	97 81       	ldd	r25, Z+7	; 0x07
    58bc:	9b 83       	std	Y+3, r25	; 0x03
    58be:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    58c0:	8a 81       	ldd	r24, Y+2	; 0x02
    58c2:	9b 81       	ldd	r25, Y+3	; 0x03
    58c4:	0c 96       	adiw	r24, 0x0c	; 12
    58c6:	0e 94 13 12 	call	0x2426	; 0x2426 <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    58ca:	80 91 b9 06 	lds	r24, 0x06B9
    58ce:	88 23       	and	r24, r24
    58d0:	61 f5       	brne	.+88     	; 0x592a <xTaskRemoveFromEventList+0x8e>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    58d2:	8a 81       	ldd	r24, Y+2	; 0x02
    58d4:	9b 81       	ldd	r25, Y+3	; 0x03
    58d6:	02 96       	adiw	r24, 0x02	; 2
    58d8:	0e 94 13 12 	call	0x2426	; 0x2426 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
    58dc:	ea 81       	ldd	r30, Y+2	; 0x02
    58de:	fb 81       	ldd	r31, Y+3	; 0x03
    58e0:	96 89       	ldd	r25, Z+22	; 0x16
    58e2:	80 91 af 06 	lds	r24, 0x06AF
    58e6:	89 17       	cp	r24, r25
    58e8:	28 f4       	brcc	.+10     	; 0x58f4 <xTaskRemoveFromEventList+0x58>
    58ea:	ea 81       	ldd	r30, Y+2	; 0x02
    58ec:	fb 81       	ldd	r31, Y+3	; 0x03
    58ee:	86 89       	ldd	r24, Z+22	; 0x16
    58f0:	80 93 af 06 	sts	0x06AF, r24
    58f4:	ea 81       	ldd	r30, Y+2	; 0x02
    58f6:	fb 81       	ldd	r31, Y+3	; 0x03
    58f8:	86 89       	ldd	r24, Z+22	; 0x16
    58fa:	28 2f       	mov	r18, r24
    58fc:	30 e0       	ldi	r19, 0x00	; 0
    58fe:	c9 01       	movw	r24, r18
    5900:	88 0f       	add	r24, r24
    5902:	99 1f       	adc	r25, r25
    5904:	88 0f       	add	r24, r24
    5906:	99 1f       	adc	r25, r25
    5908:	88 0f       	add	r24, r24
    590a:	99 1f       	adc	r25, r25
    590c:	82 0f       	add	r24, r18
    590e:	93 1f       	adc	r25, r19
    5910:	ac 01       	movw	r20, r24
    5912:	46 54       	subi	r20, 0x46	; 70
    5914:	59 4f       	sbci	r21, 0xF9	; 249
    5916:	8a 81       	ldd	r24, Y+2	; 0x02
    5918:	9b 81       	ldd	r25, Y+3	; 0x03
    591a:	9c 01       	movw	r18, r24
    591c:	2e 5f       	subi	r18, 0xFE	; 254
    591e:	3f 4f       	sbci	r19, 0xFF	; 255
    5920:	ca 01       	movw	r24, r20
    5922:	b9 01       	movw	r22, r18
    5924:	0e 94 63 11 	call	0x22c6	; 0x22c6 <vListInsertEnd>
    5928:	0a c0       	rjmp	.+20     	; 0x593e <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    592a:	8a 81       	ldd	r24, Y+2	; 0x02
    592c:	9b 81       	ldd	r25, Y+3	; 0x03
    592e:	9c 01       	movw	r18, r24
    5930:	24 5f       	subi	r18, 0xF4	; 244
    5932:	3f 4f       	sbci	r19, 0xFF	; 255
    5934:	84 ef       	ldi	r24, 0xF4	; 244
    5936:	96 e0       	ldi	r25, 0x06	; 6
    5938:	b9 01       	movw	r22, r18
    593a:	0e 94 63 11 	call	0x22c6	; 0x22c6 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    593e:	ea 81       	ldd	r30, Y+2	; 0x02
    5940:	fb 81       	ldd	r31, Y+3	; 0x03
    5942:	96 89       	ldd	r25, Z+22	; 0x16
    5944:	e0 91 a9 06 	lds	r30, 0x06A9
    5948:	f0 91 aa 06 	lds	r31, 0x06AA
    594c:	86 89       	ldd	r24, Z+22	; 0x16
    594e:	89 17       	cp	r24, r25
    5950:	30 f4       	brcc	.+12     	; 0x595e <xTaskRemoveFromEventList+0xc2>
	{
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
    5952:	81 e0       	ldi	r24, 0x01	; 1
    5954:	89 83       	std	Y+1, r24	; 0x01

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    5956:	81 e0       	ldi	r24, 0x01	; 1
    5958:	80 93 b2 06 	sts	0x06B2, r24
    595c:	01 c0       	rjmp	.+2      	; 0x5960 <xTaskRemoveFromEventList+0xc4>
	}
	else
	{
		xReturn = pdFALSE;
    595e:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    5960:	89 81       	ldd	r24, Y+1	; 0x01
}
    5962:	0f 90       	pop	r0
    5964:	0f 90       	pop	r0
    5966:	0f 90       	pop	r0
    5968:	0f 90       	pop	r0
    596a:	0f 90       	pop	r0
    596c:	cf 91       	pop	r28
    596e:	df 91       	pop	r29
    5970:	08 95       	ret

00005972 <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
    5972:	df 93       	push	r29
    5974:	cf 93       	push	r28
    5976:	00 d0       	rcall	.+0      	; 0x5978 <vTaskRemoveFromUnorderedEventList+0x6>
    5978:	00 d0       	rcall	.+0      	; 0x597a <vTaskRemoveFromUnorderedEventList+0x8>
    597a:	00 d0       	rcall	.+0      	; 0x597c <vTaskRemoveFromUnorderedEventList+0xa>
    597c:	cd b7       	in	r28, 0x3d	; 61
    597e:	de b7       	in	r29, 0x3e	; 62
    5980:	9c 83       	std	Y+4, r25	; 0x04
    5982:	8b 83       	std	Y+3, r24	; 0x03
    5984:	7e 83       	std	Y+6, r23	; 0x06
    5986:	6d 83       	std	Y+5, r22	; 0x05
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    5988:	8d 81       	ldd	r24, Y+5	; 0x05
    598a:	9e 81       	ldd	r25, Y+6	; 0x06
    598c:	90 68       	ori	r25, 0x80	; 128
    598e:	eb 81       	ldd	r30, Y+3	; 0x03
    5990:	fc 81       	ldd	r31, Y+4	; 0x04
    5992:	91 83       	std	Z+1, r25	; 0x01
    5994:	80 83       	st	Z, r24

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    5996:	eb 81       	ldd	r30, Y+3	; 0x03
    5998:	fc 81       	ldd	r31, Y+4	; 0x04
    599a:	86 81       	ldd	r24, Z+6	; 0x06
    599c:	97 81       	ldd	r25, Z+7	; 0x07
    599e:	9a 83       	std	Y+2, r25	; 0x02
    59a0:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
    59a2:	8b 81       	ldd	r24, Y+3	; 0x03
    59a4:	9c 81       	ldd	r25, Y+4	; 0x04
    59a6:	0e 94 13 12 	call	0x2426	; 0x2426 <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    59aa:	89 81       	ldd	r24, Y+1	; 0x01
    59ac:	9a 81       	ldd	r25, Y+2	; 0x02
    59ae:	02 96       	adiw	r24, 0x02	; 2
    59b0:	0e 94 13 12 	call	0x2426	; 0x2426 <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
    59b4:	e9 81       	ldd	r30, Y+1	; 0x01
    59b6:	fa 81       	ldd	r31, Y+2	; 0x02
    59b8:	96 89       	ldd	r25, Z+22	; 0x16
    59ba:	80 91 af 06 	lds	r24, 0x06AF
    59be:	89 17       	cp	r24, r25
    59c0:	28 f4       	brcc	.+10     	; 0x59cc <vTaskRemoveFromUnorderedEventList+0x5a>
    59c2:	e9 81       	ldd	r30, Y+1	; 0x01
    59c4:	fa 81       	ldd	r31, Y+2	; 0x02
    59c6:	86 89       	ldd	r24, Z+22	; 0x16
    59c8:	80 93 af 06 	sts	0x06AF, r24
    59cc:	e9 81       	ldd	r30, Y+1	; 0x01
    59ce:	fa 81       	ldd	r31, Y+2	; 0x02
    59d0:	86 89       	ldd	r24, Z+22	; 0x16
    59d2:	28 2f       	mov	r18, r24
    59d4:	30 e0       	ldi	r19, 0x00	; 0
    59d6:	c9 01       	movw	r24, r18
    59d8:	88 0f       	add	r24, r24
    59da:	99 1f       	adc	r25, r25
    59dc:	88 0f       	add	r24, r24
    59de:	99 1f       	adc	r25, r25
    59e0:	88 0f       	add	r24, r24
    59e2:	99 1f       	adc	r25, r25
    59e4:	82 0f       	add	r24, r18
    59e6:	93 1f       	adc	r25, r19
    59e8:	ac 01       	movw	r20, r24
    59ea:	46 54       	subi	r20, 0x46	; 70
    59ec:	59 4f       	sbci	r21, 0xF9	; 249
    59ee:	89 81       	ldd	r24, Y+1	; 0x01
    59f0:	9a 81       	ldd	r25, Y+2	; 0x02
    59f2:	9c 01       	movw	r18, r24
    59f4:	2e 5f       	subi	r18, 0xFE	; 254
    59f6:	3f 4f       	sbci	r19, 0xFF	; 255
    59f8:	ca 01       	movw	r24, r20
    59fa:	b9 01       	movw	r22, r18
    59fc:	0e 94 63 11 	call	0x22c6	; 0x22c6 <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    5a00:	e9 81       	ldd	r30, Y+1	; 0x01
    5a02:	fa 81       	ldd	r31, Y+2	; 0x02
    5a04:	96 89       	ldd	r25, Z+22	; 0x16
    5a06:	e0 91 a9 06 	lds	r30, 0x06A9
    5a0a:	f0 91 aa 06 	lds	r31, 0x06AA
    5a0e:	86 89       	ldd	r24, Z+22	; 0x16
    5a10:	89 17       	cp	r24, r25
    5a12:	18 f4       	brcc	.+6      	; 0x5a1a <vTaskRemoveFromUnorderedEventList+0xa8>
	{
		/* The unblocked task has a priority above that of the calling task, so
		a context switch is required.  This function is called with the
		scheduler suspended so xYieldPending is set so the context switch
		occurs immediately that the scheduler is resumed (unsuspended). */
		xYieldPending = pdTRUE;
    5a14:	81 e0       	ldi	r24, 0x01	; 1
    5a16:	80 93 b2 06 	sts	0x06B2, r24
	}
}
    5a1a:	26 96       	adiw	r28, 0x06	; 6
    5a1c:	0f b6       	in	r0, 0x3f	; 63
    5a1e:	f8 94       	cli
    5a20:	de bf       	out	0x3e, r29	; 62
    5a22:	0f be       	out	0x3f, r0	; 63
    5a24:	cd bf       	out	0x3d, r28	; 61
    5a26:	cf 91       	pop	r28
    5a28:	df 91       	pop	r29
    5a2a:	08 95       	ret

00005a2c <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    5a2c:	df 93       	push	r29
    5a2e:	cf 93       	push	r28
    5a30:	00 d0       	rcall	.+0      	; 0x5a32 <vTaskSetTimeOutState+0x6>
    5a32:	cd b7       	in	r28, 0x3d	; 61
    5a34:	de b7       	in	r29, 0x3e	; 62
    5a36:	9a 83       	std	Y+2, r25	; 0x02
    5a38:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	taskENTER_CRITICAL();
    5a3a:	0f b6       	in	r0, 0x3f	; 63
    5a3c:	f8 94       	cli
    5a3e:	0f 92       	push	r0
	{
		pxTimeOut->xOverflowCount = xNumOfOverflows;
    5a40:	80 91 b3 06 	lds	r24, 0x06B3
    5a44:	e9 81       	ldd	r30, Y+1	; 0x01
    5a46:	fa 81       	ldd	r31, Y+2	; 0x02
    5a48:	80 83       	st	Z, r24
		pxTimeOut->xTimeOnEntering = xTickCount;
    5a4a:	80 91 ad 06 	lds	r24, 0x06AD
    5a4e:	90 91 ae 06 	lds	r25, 0x06AE
    5a52:	e9 81       	ldd	r30, Y+1	; 0x01
    5a54:	fa 81       	ldd	r31, Y+2	; 0x02
    5a56:	92 83       	std	Z+2, r25	; 0x02
    5a58:	81 83       	std	Z+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    5a5a:	0f 90       	pop	r0
    5a5c:	0f be       	out	0x3f, r0	; 63
}
    5a5e:	0f 90       	pop	r0
    5a60:	0f 90       	pop	r0
    5a62:	cf 91       	pop	r28
    5a64:	df 91       	pop	r29
    5a66:	08 95       	ret

00005a68 <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    5a68:	df 93       	push	r29
    5a6a:	cf 93       	push	r28
    5a6c:	00 d0       	rcall	.+0      	; 0x5a6e <vTaskInternalSetTimeOutState+0x6>
    5a6e:	cd b7       	in	r28, 0x3d	; 61
    5a70:	de b7       	in	r29, 0x3e	; 62
    5a72:	9a 83       	std	Y+2, r25	; 0x02
    5a74:	89 83       	std	Y+1, r24	; 0x01
	/* For internal use only as it does not use a critical section. */
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    5a76:	80 91 b3 06 	lds	r24, 0x06B3
    5a7a:	e9 81       	ldd	r30, Y+1	; 0x01
    5a7c:	fa 81       	ldd	r31, Y+2	; 0x02
    5a7e:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    5a80:	80 91 ad 06 	lds	r24, 0x06AD
    5a84:	90 91 ae 06 	lds	r25, 0x06AE
    5a88:	e9 81       	ldd	r30, Y+1	; 0x01
    5a8a:	fa 81       	ldd	r31, Y+2	; 0x02
    5a8c:	92 83       	std	Z+2, r25	; 0x02
    5a8e:	81 83       	std	Z+1, r24	; 0x01
}
    5a90:	0f 90       	pop	r0
    5a92:	0f 90       	pop	r0
    5a94:	cf 91       	pop	r28
    5a96:	df 91       	pop	r29
    5a98:	08 95       	ret

00005a9a <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    5a9a:	df 93       	push	r29
    5a9c:	cf 93       	push	r28
    5a9e:	cd b7       	in	r28, 0x3d	; 61
    5aa0:	de b7       	in	r29, 0x3e	; 62
    5aa2:	29 97       	sbiw	r28, 0x09	; 9
    5aa4:	0f b6       	in	r0, 0x3f	; 63
    5aa6:	f8 94       	cli
    5aa8:	de bf       	out	0x3e, r29	; 62
    5aaa:	0f be       	out	0x3f, r0	; 63
    5aac:	cd bf       	out	0x3d, r28	; 61
    5aae:	9f 83       	std	Y+7, r25	; 0x07
    5ab0:	8e 83       	std	Y+6, r24	; 0x06
    5ab2:	79 87       	std	Y+9, r23	; 0x09
    5ab4:	68 87       	std	Y+8, r22	; 0x08
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    5ab6:	0f b6       	in	r0, 0x3f	; 63
    5ab8:	f8 94       	cli
    5aba:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    5abc:	80 91 ad 06 	lds	r24, 0x06AD
    5ac0:	90 91 ae 06 	lds	r25, 0x06AE
    5ac4:	9c 83       	std	Y+4, r25	; 0x04
    5ac6:	8b 83       	std	Y+3, r24	; 0x03
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    5ac8:	ee 81       	ldd	r30, Y+6	; 0x06
    5aca:	ff 81       	ldd	r31, Y+7	; 0x07
    5acc:	21 81       	ldd	r18, Z+1	; 0x01
    5ace:	32 81       	ldd	r19, Z+2	; 0x02
    5ad0:	8b 81       	ldd	r24, Y+3	; 0x03
    5ad2:	9c 81       	ldd	r25, Y+4	; 0x04
    5ad4:	82 1b       	sub	r24, r18
    5ad6:	93 0b       	sbc	r25, r19
    5ad8:	9a 83       	std	Y+2, r25	; 0x02
    5ada:	89 83       	std	Y+1, r24	; 0x01
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
    5adc:	e8 85       	ldd	r30, Y+8	; 0x08
    5ade:	f9 85       	ldd	r31, Y+9	; 0x09
    5ae0:	80 81       	ld	r24, Z
    5ae2:	91 81       	ldd	r25, Z+1	; 0x01
    5ae4:	2f ef       	ldi	r18, 0xFF	; 255
    5ae6:	8f 3f       	cpi	r24, 0xFF	; 255
    5ae8:	92 07       	cpc	r25, r18
    5aea:	11 f4       	brne	.+4      	; 0x5af0 <xTaskCheckForTimeOut+0x56>
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
    5aec:	1d 82       	std	Y+5, r1	; 0x05
    5aee:	36 c0       	rjmp	.+108    	; 0x5b5c <xTaskCheckForTimeOut+0xc2>
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    5af0:	ee 81       	ldd	r30, Y+6	; 0x06
    5af2:	ff 81       	ldd	r31, Y+7	; 0x07
    5af4:	90 81       	ld	r25, Z
    5af6:	80 91 b3 06 	lds	r24, 0x06B3
    5afa:	98 17       	cp	r25, r24
    5afc:	61 f0       	breq	.+24     	; 0x5b16 <xTaskCheckForTimeOut+0x7c>
    5afe:	ee 81       	ldd	r30, Y+6	; 0x06
    5b00:	ff 81       	ldd	r31, Y+7	; 0x07
    5b02:	21 81       	ldd	r18, Z+1	; 0x01
    5b04:	32 81       	ldd	r19, Z+2	; 0x02
    5b06:	8b 81       	ldd	r24, Y+3	; 0x03
    5b08:	9c 81       	ldd	r25, Y+4	; 0x04
    5b0a:	82 17       	cp	r24, r18
    5b0c:	93 07       	cpc	r25, r19
    5b0e:	18 f0       	brcs	.+6      	; 0x5b16 <xTaskCheckForTimeOut+0x7c>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
    5b10:	81 e0       	ldi	r24, 0x01	; 1
    5b12:	8d 83       	std	Y+5, r24	; 0x05
    5b14:	23 c0       	rjmp	.+70     	; 0x5b5c <xTaskCheckForTimeOut+0xc2>
		}
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    5b16:	e8 85       	ldd	r30, Y+8	; 0x08
    5b18:	f9 85       	ldd	r31, Y+9	; 0x09
    5b1a:	20 81       	ld	r18, Z
    5b1c:	31 81       	ldd	r19, Z+1	; 0x01
    5b1e:	89 81       	ldd	r24, Y+1	; 0x01
    5b20:	9a 81       	ldd	r25, Y+2	; 0x02
    5b22:	82 17       	cp	r24, r18
    5b24:	93 07       	cpc	r25, r19
    5b26:	a0 f4       	brcc	.+40     	; 0x5b50 <xTaskCheckForTimeOut+0xb6>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= xElapsedTime;
    5b28:	e8 85       	ldd	r30, Y+8	; 0x08
    5b2a:	f9 85       	ldd	r31, Y+9	; 0x09
    5b2c:	20 81       	ld	r18, Z
    5b2e:	31 81       	ldd	r19, Z+1	; 0x01
    5b30:	89 81       	ldd	r24, Y+1	; 0x01
    5b32:	9a 81       	ldd	r25, Y+2	; 0x02
    5b34:	a9 01       	movw	r20, r18
    5b36:	48 1b       	sub	r20, r24
    5b38:	59 0b       	sbc	r21, r25
    5b3a:	ca 01       	movw	r24, r20
    5b3c:	e8 85       	ldd	r30, Y+8	; 0x08
    5b3e:	f9 85       	ldd	r31, Y+9	; 0x09
    5b40:	91 83       	std	Z+1, r25	; 0x01
    5b42:	80 83       	st	Z, r24
			vTaskInternalSetTimeOutState( pxTimeOut );
    5b44:	8e 81       	ldd	r24, Y+6	; 0x06
    5b46:	9f 81       	ldd	r25, Y+7	; 0x07
    5b48:	0e 94 34 2d 	call	0x5a68	; 0x5a68 <vTaskInternalSetTimeOutState>
			xReturn = pdFALSE;
    5b4c:	1d 82       	std	Y+5, r1	; 0x05
    5b4e:	06 c0       	rjmp	.+12     	; 0x5b5c <xTaskCheckForTimeOut+0xc2>
		}
		else
		{
			*pxTicksToWait = 0;
    5b50:	e8 85       	ldd	r30, Y+8	; 0x08
    5b52:	f9 85       	ldd	r31, Y+9	; 0x09
    5b54:	11 82       	std	Z+1, r1	; 0x01
    5b56:	10 82       	st	Z, r1
			xReturn = pdTRUE;
    5b58:	81 e0       	ldi	r24, 0x01	; 1
    5b5a:	8d 83       	std	Y+5, r24	; 0x05
		}
	}
	taskEXIT_CRITICAL();
    5b5c:	0f 90       	pop	r0
    5b5e:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    5b60:	8d 81       	ldd	r24, Y+5	; 0x05
}
    5b62:	29 96       	adiw	r28, 0x09	; 9
    5b64:	0f b6       	in	r0, 0x3f	; 63
    5b66:	f8 94       	cli
    5b68:	de bf       	out	0x3e, r29	; 62
    5b6a:	0f be       	out	0x3f, r0	; 63
    5b6c:	cd bf       	out	0x3d, r28	; 61
    5b6e:	cf 91       	pop	r28
    5b70:	df 91       	pop	r29
    5b72:	08 95       	ret

00005b74 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    5b74:	df 93       	push	r29
    5b76:	cf 93       	push	r28
    5b78:	cd b7       	in	r28, 0x3d	; 61
    5b7a:	de b7       	in	r29, 0x3e	; 62
	xYieldPending = pdTRUE;
    5b7c:	81 e0       	ldi	r24, 0x01	; 1
    5b7e:	80 93 b2 06 	sts	0x06B2, r24
}
    5b82:	cf 91       	pop	r28
    5b84:	df 91       	pop	r29
    5b86:	08 95       	ret

00005b88 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    5b88:	df 93       	push	r29
    5b8a:	cf 93       	push	r28
    5b8c:	00 d0       	rcall	.+0      	; 0x5b8e <prvIdleTask+0x6>
    5b8e:	cd b7       	in	r28, 0x3d	; 61
    5b90:	de b7       	in	r29, 0x3e	; 62
    5b92:	9a 83       	std	Y+2, r25	; 0x02
    5b94:	89 83       	std	Y+1, r24	; 0x01

	for( ;; )
	{
		/* See if any tasks have deleted themselves - if so then the idle task
		is responsible for freeing the deleted task's TCB and stack. */
		prvCheckTasksWaitingTermination();
    5b96:	0e 94 0f 2e 	call	0x5c1e	; 0x5c1e <prvCheckTasksWaitingTermination>
    5b9a:	fd cf       	rjmp	.-6      	; 0x5b96 <prvIdleTask+0xe>

00005b9c <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
    5b9c:	df 93       	push	r29
    5b9e:	cf 93       	push	r28
    5ba0:	0f 92       	push	r0
    5ba2:	cd b7       	in	r28, 0x3d	; 61
    5ba4:	de b7       	in	r29, 0x3e	; 62
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    5ba6:	19 82       	std	Y+1, r1	; 0x01
    5ba8:	13 c0       	rjmp	.+38     	; 0x5bd0 <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    5baa:	89 81       	ldd	r24, Y+1	; 0x01
    5bac:	28 2f       	mov	r18, r24
    5bae:	30 e0       	ldi	r19, 0x00	; 0
    5bb0:	c9 01       	movw	r24, r18
    5bb2:	88 0f       	add	r24, r24
    5bb4:	99 1f       	adc	r25, r25
    5bb6:	88 0f       	add	r24, r24
    5bb8:	99 1f       	adc	r25, r25
    5bba:	88 0f       	add	r24, r24
    5bbc:	99 1f       	adc	r25, r25
    5bbe:	82 0f       	add	r24, r18
    5bc0:	93 1f       	adc	r25, r19
    5bc2:	86 54       	subi	r24, 0x46	; 70
    5bc4:	99 4f       	sbci	r25, 0xF9	; 249
    5bc6:	0e 94 29 11 	call	0x2252	; 0x2252 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    5bca:	89 81       	ldd	r24, Y+1	; 0x01
    5bcc:	8f 5f       	subi	r24, 0xFF	; 255
    5bce:	89 83       	std	Y+1, r24	; 0x01
    5bd0:	89 81       	ldd	r24, Y+1	; 0x01
    5bd2:	84 30       	cpi	r24, 0x04	; 4
    5bd4:	50 f3       	brcs	.-44     	; 0x5baa <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
    5bd6:	8e ed       	ldi	r24, 0xDE	; 222
    5bd8:	96 e0       	ldi	r25, 0x06	; 6
    5bda:	0e 94 29 11 	call	0x2252	; 0x2252 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
    5bde:	87 ee       	ldi	r24, 0xE7	; 231
    5be0:	96 e0       	ldi	r25, 0x06	; 6
    5be2:	0e 94 29 11 	call	0x2252	; 0x2252 <vListInitialise>
	vListInitialise( &xPendingReadyList );
    5be6:	84 ef       	ldi	r24, 0xF4	; 244
    5be8:	96 e0       	ldi	r25, 0x06	; 6
    5bea:	0e 94 29 11 	call	0x2252	; 0x2252 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
    5bee:	8d ef       	ldi	r24, 0xFD	; 253
    5bf0:	96 e0       	ldi	r25, 0x06	; 6
    5bf2:	0e 94 29 11 	call	0x2252	; 0x2252 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
    5bf6:	86 e0       	ldi	r24, 0x06	; 6
    5bf8:	97 e0       	ldi	r25, 0x07	; 7
    5bfa:	0e 94 29 11 	call	0x2252	; 0x2252 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    5bfe:	8e ed       	ldi	r24, 0xDE	; 222
    5c00:	96 e0       	ldi	r25, 0x06	; 6
    5c02:	90 93 f1 06 	sts	0x06F1, r25
    5c06:	80 93 f0 06 	sts	0x06F0, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    5c0a:	87 ee       	ldi	r24, 0xE7	; 231
    5c0c:	96 e0       	ldi	r25, 0x06	; 6
    5c0e:	90 93 f3 06 	sts	0x06F3, r25
    5c12:	80 93 f2 06 	sts	0x06F2, r24
}
    5c16:	0f 90       	pop	r0
    5c18:	cf 91       	pop	r28
    5c1a:	df 91       	pop	r29
    5c1c:	08 95       	ret

00005c1e <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    5c1e:	df 93       	push	r29
    5c20:	cf 93       	push	r28
    5c22:	00 d0       	rcall	.+0      	; 0x5c24 <prvCheckTasksWaitingTermination+0x6>
    5c24:	cd b7       	in	r28, 0x3d	; 61
    5c26:	de b7       	in	r29, 0x3e	; 62
    5c28:	20 c0       	rjmp	.+64     	; 0x5c6a <prvCheckTasksWaitingTermination+0x4c>

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
		{
			taskENTER_CRITICAL();
    5c2a:	0f b6       	in	r0, 0x3f	; 63
    5c2c:	f8 94       	cli
    5c2e:	0f 92       	push	r0
			{
				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    5c30:	e0 91 02 07 	lds	r30, 0x0702
    5c34:	f0 91 03 07 	lds	r31, 0x0703
    5c38:	86 81       	ldd	r24, Z+6	; 0x06
    5c3a:	97 81       	ldd	r25, Z+7	; 0x07
    5c3c:	9a 83       	std	Y+2, r25	; 0x02
    5c3e:	89 83       	std	Y+1, r24	; 0x01
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    5c40:	89 81       	ldd	r24, Y+1	; 0x01
    5c42:	9a 81       	ldd	r25, Y+2	; 0x02
    5c44:	02 96       	adiw	r24, 0x02	; 2
    5c46:	0e 94 13 12 	call	0x2426	; 0x2426 <uxListRemove>
				--uxCurrentNumberOfTasks;
    5c4a:	80 91 ac 06 	lds	r24, 0x06AC
    5c4e:	81 50       	subi	r24, 0x01	; 1
    5c50:	80 93 ac 06 	sts	0x06AC, r24
				--uxDeletedTasksWaitingCleanUp;
    5c54:	80 91 ab 06 	lds	r24, 0x06AB
    5c58:	81 50       	subi	r24, 0x01	; 1
    5c5a:	80 93 ab 06 	sts	0x06AB, r24
			}
			taskEXIT_CRITICAL();
    5c5e:	0f 90       	pop	r0
    5c60:	0f be       	out	0x3f, r0	; 63

			prvDeleteTCB( pxTCB );
    5c62:	89 81       	ldd	r24, Y+1	; 0x01
    5c64:	9a 81       	ldd	r25, Y+2	; 0x02
    5c66:	0e 94 3e 2e 	call	0x5c7c	; 0x5c7c <prvDeleteTCB>
	{
		TCB_t *pxTCB;

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    5c6a:	80 91 ab 06 	lds	r24, 0x06AB
    5c6e:	88 23       	and	r24, r24
    5c70:	e1 f6       	brne	.-72     	; 0x5c2a <prvCheckTasksWaitingTermination+0xc>

			prvDeleteTCB( pxTCB );
		}
	}
	#endif /* INCLUDE_vTaskDelete */
}
    5c72:	0f 90       	pop	r0
    5c74:	0f 90       	pop	r0
    5c76:	cf 91       	pop	r28
    5c78:	df 91       	pop	r29
    5c7a:	08 95       	ret

00005c7c <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
    5c7c:	df 93       	push	r29
    5c7e:	cf 93       	push	r28
    5c80:	00 d0       	rcall	.+0      	; 0x5c82 <prvDeleteTCB+0x6>
    5c82:	cd b7       	in	r28, 0x3d	; 61
    5c84:	de b7       	in	r29, 0x3e	; 62
    5c86:	9a 83       	std	Y+2, r25	; 0x02
    5c88:	89 83       	std	Y+1, r24	; 0x01

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
    5c8a:	e9 81       	ldd	r30, Y+1	; 0x01
    5c8c:	fa 81       	ldd	r31, Y+2	; 0x02
    5c8e:	87 89       	ldd	r24, Z+23	; 0x17
    5c90:	90 8d       	ldd	r25, Z+24	; 0x18
    5c92:	0e 94 89 0d 	call	0x1b12	; 0x1b12 <vPortFree>
			vPortFree( pxTCB );
    5c96:	89 81       	ldd	r24, Y+1	; 0x01
    5c98:	9a 81       	ldd	r25, Y+2	; 0x02
    5c9a:	0e 94 89 0d 	call	0x1b12	; 0x1b12 <vPortFree>
				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	);
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
    5c9e:	0f 90       	pop	r0
    5ca0:	0f 90       	pop	r0
    5ca2:	cf 91       	pop	r28
    5ca4:	df 91       	pop	r29
    5ca6:	08 95       	ret

00005ca8 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    5ca8:	df 93       	push	r29
    5caa:	cf 93       	push	r28
    5cac:	00 d0       	rcall	.+0      	; 0x5cae <prvResetNextTaskUnblockTime+0x6>
    5cae:	cd b7       	in	r28, 0x3d	; 61
    5cb0:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    5cb2:	e0 91 f0 06 	lds	r30, 0x06F0
    5cb6:	f0 91 f1 06 	lds	r31, 0x06F1
    5cba:	80 81       	ld	r24, Z
    5cbc:	88 23       	and	r24, r24
    5cbe:	39 f4       	brne	.+14     	; 0x5cce <prvResetNextTaskUnblockTime+0x26>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    5cc0:	8f ef       	ldi	r24, 0xFF	; 255
    5cc2:	9f ef       	ldi	r25, 0xFF	; 255
    5cc4:	90 93 b6 06 	sts	0x06B6, r25
    5cc8:	80 93 b5 06 	sts	0x06B5, r24
    5ccc:	13 c0       	rjmp	.+38     	; 0x5cf4 <prvResetNextTaskUnblockTime+0x4c>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    5cce:	e0 91 f0 06 	lds	r30, 0x06F0
    5cd2:	f0 91 f1 06 	lds	r31, 0x06F1
    5cd6:	05 80       	ldd	r0, Z+5	; 0x05
    5cd8:	f6 81       	ldd	r31, Z+6	; 0x06
    5cda:	e0 2d       	mov	r30, r0
    5cdc:	86 81       	ldd	r24, Z+6	; 0x06
    5cde:	97 81       	ldd	r25, Z+7	; 0x07
    5ce0:	9a 83       	std	Y+2, r25	; 0x02
    5ce2:	89 83       	std	Y+1, r24	; 0x01
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
    5ce4:	e9 81       	ldd	r30, Y+1	; 0x01
    5ce6:	fa 81       	ldd	r31, Y+2	; 0x02
    5ce8:	82 81       	ldd	r24, Z+2	; 0x02
    5cea:	93 81       	ldd	r25, Z+3	; 0x03
    5cec:	90 93 b6 06 	sts	0x06B6, r25
    5cf0:	80 93 b5 06 	sts	0x06B5, r24
	}
}
    5cf4:	0f 90       	pop	r0
    5cf6:	0f 90       	pop	r0
    5cf8:	cf 91       	pop	r28
    5cfa:	df 91       	pop	r29
    5cfc:	08 95       	ret

00005cfe <xTaskGetCurrentTaskHandle>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )

	TaskHandle_t xTaskGetCurrentTaskHandle( void )
	{
    5cfe:	df 93       	push	r29
    5d00:	cf 93       	push	r28
    5d02:	00 d0       	rcall	.+0      	; 0x5d04 <xTaskGetCurrentTaskHandle+0x6>
    5d04:	cd b7       	in	r28, 0x3d	; 61
    5d06:	de b7       	in	r29, 0x3e	; 62
	TaskHandle_t xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    5d08:	80 91 a9 06 	lds	r24, 0x06A9
    5d0c:	90 91 aa 06 	lds	r25, 0x06AA
    5d10:	9a 83       	std	Y+2, r25	; 0x02
    5d12:	89 83       	std	Y+1, r24	; 0x01

		return xReturn;
    5d14:	89 81       	ldd	r24, Y+1	; 0x01
    5d16:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    5d18:	0f 90       	pop	r0
    5d1a:	0f 90       	pop	r0
    5d1c:	cf 91       	pop	r28
    5d1e:	df 91       	pop	r29
    5d20:	08 95       	ret

00005d22 <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
    5d22:	df 93       	push	r29
    5d24:	cf 93       	push	r28
    5d26:	00 d0       	rcall	.+0      	; 0x5d28 <uxTaskResetEventItemValue+0x6>
    5d28:	cd b7       	in	r28, 0x3d	; 61
    5d2a:	de b7       	in	r29, 0x3e	; 62
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    5d2c:	e0 91 a9 06 	lds	r30, 0x06A9
    5d30:	f0 91 aa 06 	lds	r31, 0x06AA
    5d34:	84 85       	ldd	r24, Z+12	; 0x0c
    5d36:	95 85       	ldd	r25, Z+13	; 0x0d
    5d38:	9a 83       	std	Y+2, r25	; 0x02
    5d3a:	89 83       	std	Y+1, r24	; 0x01

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    5d3c:	a0 91 a9 06 	lds	r26, 0x06A9
    5d40:	b0 91 aa 06 	lds	r27, 0x06AA
    5d44:	e0 91 a9 06 	lds	r30, 0x06A9
    5d48:	f0 91 aa 06 	lds	r31, 0x06AA
    5d4c:	86 89       	ldd	r24, Z+22	; 0x16
    5d4e:	28 2f       	mov	r18, r24
    5d50:	30 e0       	ldi	r19, 0x00	; 0
    5d52:	84 e0       	ldi	r24, 0x04	; 4
    5d54:	90 e0       	ldi	r25, 0x00	; 0
    5d56:	82 1b       	sub	r24, r18
    5d58:	93 0b       	sbc	r25, r19
    5d5a:	1d 96       	adiw	r26, 0x0d	; 13
    5d5c:	9c 93       	st	X, r25
    5d5e:	8e 93       	st	-X, r24
    5d60:	1c 97       	sbiw	r26, 0x0c	; 12

	return uxReturn;
    5d62:	89 81       	ldd	r24, Y+1	; 0x01
    5d64:	9a 81       	ldd	r25, Y+2	; 0x02
}
    5d66:	0f 90       	pop	r0
    5d68:	0f 90       	pop	r0
    5d6a:	cf 91       	pop	r28
    5d6c:	df 91       	pop	r29
    5d6e:	08 95       	ret

00005d70 <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
    5d70:	df 93       	push	r29
    5d72:	cf 93       	push	r28
    5d74:	cd b7       	in	r28, 0x3d	; 61
    5d76:	de b7       	in	r29, 0x3e	; 62
    5d78:	27 97       	sbiw	r28, 0x07	; 7
    5d7a:	0f b6       	in	r0, 0x3f	; 63
    5d7c:	f8 94       	cli
    5d7e:	de bf       	out	0x3e, r29	; 62
    5d80:	0f be       	out	0x3f, r0	; 63
    5d82:	cd bf       	out	0x3d, r28	; 61
    5d84:	8d 83       	std	Y+5, r24	; 0x05
    5d86:	7f 83       	std	Y+7, r23	; 0x07
    5d88:	6e 83       	std	Y+6, r22	; 0x06
	uint32_t ulReturn;

		taskENTER_CRITICAL();
    5d8a:	0f b6       	in	r0, 0x3f	; 63
    5d8c:	f8 94       	cli
    5d8e:	0f 92       	push	r0
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
    5d90:	e0 91 a9 06 	lds	r30, 0x06A9
    5d94:	f0 91 aa 06 	lds	r31, 0x06AA
    5d98:	81 a1       	ldd	r24, Z+33	; 0x21
    5d9a:	92 a1       	ldd	r25, Z+34	; 0x22
    5d9c:	a3 a1       	ldd	r26, Z+35	; 0x23
    5d9e:	b4 a1       	ldd	r27, Z+36	; 0x24
    5da0:	00 97       	sbiw	r24, 0x00	; 0
    5da2:	a1 05       	cpc	r26, r1
    5da4:	b1 05       	cpc	r27, r1
    5da6:	89 f4       	brne	.+34     	; 0x5dca <ulTaskNotifyTake+0x5a>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    5da8:	e0 91 a9 06 	lds	r30, 0x06A9
    5dac:	f0 91 aa 06 	lds	r31, 0x06AA
    5db0:	81 e0       	ldi	r24, 0x01	; 1
    5db2:	85 a3       	std	Z+37, r24	; 0x25

				if( xTicksToWait > ( TickType_t ) 0 )
    5db4:	8e 81       	ldd	r24, Y+6	; 0x06
    5db6:	9f 81       	ldd	r25, Y+7	; 0x07
    5db8:	00 97       	sbiw	r24, 0x00	; 0
    5dba:	39 f0       	breq	.+14     	; 0x5dca <ulTaskNotifyTake+0x5a>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    5dbc:	8e 81       	ldd	r24, Y+6	; 0x06
    5dbe:	9f 81       	ldd	r25, Y+7	; 0x07
    5dc0:	61 e0       	ldi	r22, 0x01	; 1
    5dc2:	0e 94 60 32 	call	0x64c0	; 0x64c0 <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    5dc6:	0e 94 d8 15 	call	0x2bb0	; 0x2bb0 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    5dca:	0f 90       	pop	r0
    5dcc:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    5dce:	0f b6       	in	r0, 0x3f	; 63
    5dd0:	f8 94       	cli
    5dd2:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
    5dd4:	e0 91 a9 06 	lds	r30, 0x06A9
    5dd8:	f0 91 aa 06 	lds	r31, 0x06AA
    5ddc:	81 a1       	ldd	r24, Z+33	; 0x21
    5dde:	92 a1       	ldd	r25, Z+34	; 0x22
    5de0:	a3 a1       	ldd	r26, Z+35	; 0x23
    5de2:	b4 a1       	ldd	r27, Z+36	; 0x24
    5de4:	89 83       	std	Y+1, r24	; 0x01
    5de6:	9a 83       	std	Y+2, r25	; 0x02
    5de8:	ab 83       	std	Y+3, r26	; 0x03
    5dea:	bc 83       	std	Y+4, r27	; 0x04

			if( ulReturn != 0UL )
    5dec:	89 81       	ldd	r24, Y+1	; 0x01
    5dee:	9a 81       	ldd	r25, Y+2	; 0x02
    5df0:	ab 81       	ldd	r26, Y+3	; 0x03
    5df2:	bc 81       	ldd	r27, Y+4	; 0x04
    5df4:	00 97       	sbiw	r24, 0x00	; 0
    5df6:	a1 05       	cpc	r26, r1
    5df8:	b1 05       	cpc	r27, r1
    5dfa:	d9 f0       	breq	.+54     	; 0x5e32 <ulTaskNotifyTake+0xc2>
			{
				if( xClearCountOnExit != pdFALSE )
    5dfc:	8d 81       	ldd	r24, Y+5	; 0x05
    5dfe:	88 23       	and	r24, r24
    5e00:	49 f0       	breq	.+18     	; 0x5e14 <ulTaskNotifyTake+0xa4>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
    5e02:	e0 91 a9 06 	lds	r30, 0x06A9
    5e06:	f0 91 aa 06 	lds	r31, 0x06AA
    5e0a:	11 a2       	std	Z+33, r1	; 0x21
    5e0c:	12 a2       	std	Z+34, r1	; 0x22
    5e0e:	13 a2       	std	Z+35, r1	; 0x23
    5e10:	14 a2       	std	Z+36, r1	; 0x24
    5e12:	0f c0       	rjmp	.+30     	; 0x5e32 <ulTaskNotifyTake+0xc2>
				}
				else
				{
					pxCurrentTCB->ulNotifiedValue = ulReturn - ( uint32_t ) 1;
    5e14:	e0 91 a9 06 	lds	r30, 0x06A9
    5e18:	f0 91 aa 06 	lds	r31, 0x06AA
    5e1c:	89 81       	ldd	r24, Y+1	; 0x01
    5e1e:	9a 81       	ldd	r25, Y+2	; 0x02
    5e20:	ab 81       	ldd	r26, Y+3	; 0x03
    5e22:	bc 81       	ldd	r27, Y+4	; 0x04
    5e24:	01 97       	sbiw	r24, 0x01	; 1
    5e26:	a1 09       	sbc	r26, r1
    5e28:	b1 09       	sbc	r27, r1
    5e2a:	81 a3       	std	Z+33, r24	; 0x21
    5e2c:	92 a3       	std	Z+34, r25	; 0x22
    5e2e:	a3 a3       	std	Z+35, r26	; 0x23
    5e30:	b4 a3       	std	Z+36, r27	; 0x24
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    5e32:	e0 91 a9 06 	lds	r30, 0x06A9
    5e36:	f0 91 aa 06 	lds	r31, 0x06AA
    5e3a:	15 a2       	std	Z+37, r1	; 0x25
		}
		taskEXIT_CRITICAL();
    5e3c:	0f 90       	pop	r0
    5e3e:	0f be       	out	0x3f, r0	; 63

		return ulReturn;
    5e40:	89 81       	ldd	r24, Y+1	; 0x01
    5e42:	9a 81       	ldd	r25, Y+2	; 0x02
    5e44:	ab 81       	ldd	r26, Y+3	; 0x03
    5e46:	bc 81       	ldd	r27, Y+4	; 0x04
	}
    5e48:	bc 01       	movw	r22, r24
    5e4a:	cd 01       	movw	r24, r26
    5e4c:	27 96       	adiw	r28, 0x07	; 7
    5e4e:	0f b6       	in	r0, 0x3f	; 63
    5e50:	f8 94       	cli
    5e52:	de bf       	out	0x3e, r29	; 62
    5e54:	0f be       	out	0x3f, r0	; 63
    5e56:	cd bf       	out	0x3d, r28	; 61
    5e58:	cf 91       	pop	r28
    5e5a:	df 91       	pop	r29
    5e5c:	08 95       	ret

00005e5e <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
    5e5e:	ef 92       	push	r14
    5e60:	ff 92       	push	r15
    5e62:	0f 93       	push	r16
    5e64:	1f 93       	push	r17
    5e66:	df 93       	push	r29
    5e68:	cf 93       	push	r28
    5e6a:	cd b7       	in	r28, 0x3d	; 61
    5e6c:	de b7       	in	r29, 0x3e	; 62
    5e6e:	2d 97       	sbiw	r28, 0x0d	; 13
    5e70:	0f b6       	in	r0, 0x3f	; 63
    5e72:	f8 94       	cli
    5e74:	de bf       	out	0x3e, r29	; 62
    5e76:	0f be       	out	0x3f, r0	; 63
    5e78:	cd bf       	out	0x3d, r28	; 61
    5e7a:	6a 83       	std	Y+2, r22	; 0x02
    5e7c:	7b 83       	std	Y+3, r23	; 0x03
    5e7e:	8c 83       	std	Y+4, r24	; 0x04
    5e80:	9d 83       	std	Y+5, r25	; 0x05
    5e82:	2e 83       	std	Y+6, r18	; 0x06
    5e84:	3f 83       	std	Y+7, r19	; 0x07
    5e86:	48 87       	std	Y+8, r20	; 0x08
    5e88:	59 87       	std	Y+9, r21	; 0x09
    5e8a:	1b 87       	std	Y+11, r17	; 0x0b
    5e8c:	0a 87       	std	Y+10, r16	; 0x0a
    5e8e:	fd 86       	std	Y+13, r15	; 0x0d
    5e90:	ec 86       	std	Y+12, r14	; 0x0c
	BaseType_t xReturn;

		taskENTER_CRITICAL();
    5e92:	0f b6       	in	r0, 0x3f	; 63
    5e94:	f8 94       	cli
    5e96:	0f 92       	push	r0
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    5e98:	e0 91 a9 06 	lds	r30, 0x06A9
    5e9c:	f0 91 aa 06 	lds	r31, 0x06AA
    5ea0:	85 a1       	ldd	r24, Z+37	; 0x25
    5ea2:	82 30       	cpi	r24, 0x02	; 2
    5ea4:	49 f1       	breq	.+82     	; 0x5ef8 <xTaskNotifyWait+0x9a>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
    5ea6:	e0 91 a9 06 	lds	r30, 0x06A9
    5eaa:	f0 91 aa 06 	lds	r31, 0x06AA
    5eae:	21 a1       	ldd	r18, Z+33	; 0x21
    5eb0:	32 a1       	ldd	r19, Z+34	; 0x22
    5eb2:	43 a1       	ldd	r20, Z+35	; 0x23
    5eb4:	54 a1       	ldd	r21, Z+36	; 0x24
    5eb6:	8a 81       	ldd	r24, Y+2	; 0x02
    5eb8:	9b 81       	ldd	r25, Y+3	; 0x03
    5eba:	ac 81       	ldd	r26, Y+4	; 0x04
    5ebc:	bd 81       	ldd	r27, Y+5	; 0x05
    5ebe:	80 95       	com	r24
    5ec0:	90 95       	com	r25
    5ec2:	a0 95       	com	r26
    5ec4:	b0 95       	com	r27
    5ec6:	82 23       	and	r24, r18
    5ec8:	93 23       	and	r25, r19
    5eca:	a4 23       	and	r26, r20
    5ecc:	b5 23       	and	r27, r21
    5ece:	81 a3       	std	Z+33, r24	; 0x21
    5ed0:	92 a3       	std	Z+34, r25	; 0x22
    5ed2:	a3 a3       	std	Z+35, r26	; 0x23
    5ed4:	b4 a3       	std	Z+36, r27	; 0x24

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    5ed6:	e0 91 a9 06 	lds	r30, 0x06A9
    5eda:	f0 91 aa 06 	lds	r31, 0x06AA
    5ede:	81 e0       	ldi	r24, 0x01	; 1
    5ee0:	85 a3       	std	Z+37, r24	; 0x25

				if( xTicksToWait > ( TickType_t ) 0 )
    5ee2:	8c 85       	ldd	r24, Y+12	; 0x0c
    5ee4:	9d 85       	ldd	r25, Y+13	; 0x0d
    5ee6:	00 97       	sbiw	r24, 0x00	; 0
    5ee8:	39 f0       	breq	.+14     	; 0x5ef8 <xTaskNotifyWait+0x9a>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    5eea:	8c 85       	ldd	r24, Y+12	; 0x0c
    5eec:	9d 85       	ldd	r25, Y+13	; 0x0d
    5eee:	61 e0       	ldi	r22, 0x01	; 1
    5ef0:	0e 94 60 32 	call	0x64c0	; 0x64c0 <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    5ef4:	0e 94 d8 15 	call	0x2bb0	; 0x2bb0 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    5ef8:	0f 90       	pop	r0
    5efa:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    5efc:	0f b6       	in	r0, 0x3f	; 63
    5efe:	f8 94       	cli
    5f00:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
    5f02:	8a 85       	ldd	r24, Y+10	; 0x0a
    5f04:	9b 85       	ldd	r25, Y+11	; 0x0b
    5f06:	00 97       	sbiw	r24, 0x00	; 0
    5f08:	71 f0       	breq	.+28     	; 0x5f26 <xTaskNotifyWait+0xc8>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
    5f0a:	e0 91 a9 06 	lds	r30, 0x06A9
    5f0e:	f0 91 aa 06 	lds	r31, 0x06AA
    5f12:	81 a1       	ldd	r24, Z+33	; 0x21
    5f14:	92 a1       	ldd	r25, Z+34	; 0x22
    5f16:	a3 a1       	ldd	r26, Z+35	; 0x23
    5f18:	b4 a1       	ldd	r27, Z+36	; 0x24
    5f1a:	ea 85       	ldd	r30, Y+10	; 0x0a
    5f1c:	fb 85       	ldd	r31, Y+11	; 0x0b
    5f1e:	80 83       	st	Z, r24
    5f20:	91 83       	std	Z+1, r25	; 0x01
    5f22:	a2 83       	std	Z+2, r26	; 0x02
    5f24:	b3 83       	std	Z+3, r27	; 0x03

			/* If ucNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    5f26:	e0 91 a9 06 	lds	r30, 0x06A9
    5f2a:	f0 91 aa 06 	lds	r31, 0x06AA
    5f2e:	85 a1       	ldd	r24, Z+37	; 0x25
    5f30:	82 30       	cpi	r24, 0x02	; 2
    5f32:	11 f0       	breq	.+4      	; 0x5f38 <xTaskNotifyWait+0xda>
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
    5f34:	19 82       	std	Y+1, r1	; 0x01
    5f36:	1a c0       	rjmp	.+52     	; 0x5f6c <xTaskNotifyWait+0x10e>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
    5f38:	e0 91 a9 06 	lds	r30, 0x06A9
    5f3c:	f0 91 aa 06 	lds	r31, 0x06AA
    5f40:	21 a1       	ldd	r18, Z+33	; 0x21
    5f42:	32 a1       	ldd	r19, Z+34	; 0x22
    5f44:	43 a1       	ldd	r20, Z+35	; 0x23
    5f46:	54 a1       	ldd	r21, Z+36	; 0x24
    5f48:	8e 81       	ldd	r24, Y+6	; 0x06
    5f4a:	9f 81       	ldd	r25, Y+7	; 0x07
    5f4c:	a8 85       	ldd	r26, Y+8	; 0x08
    5f4e:	b9 85       	ldd	r27, Y+9	; 0x09
    5f50:	80 95       	com	r24
    5f52:	90 95       	com	r25
    5f54:	a0 95       	com	r26
    5f56:	b0 95       	com	r27
    5f58:	82 23       	and	r24, r18
    5f5a:	93 23       	and	r25, r19
    5f5c:	a4 23       	and	r26, r20
    5f5e:	b5 23       	and	r27, r21
    5f60:	81 a3       	std	Z+33, r24	; 0x21
    5f62:	92 a3       	std	Z+34, r25	; 0x22
    5f64:	a3 a3       	std	Z+35, r26	; 0x23
    5f66:	b4 a3       	std	Z+36, r27	; 0x24
				xReturn = pdTRUE;
    5f68:	81 e0       	ldi	r24, 0x01	; 1
    5f6a:	89 83       	std	Y+1, r24	; 0x01
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    5f6c:	e0 91 a9 06 	lds	r30, 0x06A9
    5f70:	f0 91 aa 06 	lds	r31, 0x06AA
    5f74:	15 a2       	std	Z+37, r1	; 0x25
		}
		taskEXIT_CRITICAL();
    5f76:	0f 90       	pop	r0
    5f78:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    5f7a:	89 81       	ldd	r24, Y+1	; 0x01
	}
    5f7c:	2d 96       	adiw	r28, 0x0d	; 13
    5f7e:	0f b6       	in	r0, 0x3f	; 63
    5f80:	f8 94       	cli
    5f82:	de bf       	out	0x3e, r29	; 62
    5f84:	0f be       	out	0x3f, r0	; 63
    5f86:	cd bf       	out	0x3d, r28	; 61
    5f88:	cf 91       	pop	r28
    5f8a:	df 91       	pop	r29
    5f8c:	1f 91       	pop	r17
    5f8e:	0f 91       	pop	r16
    5f90:	ff 90       	pop	r15
    5f92:	ef 90       	pop	r14
    5f94:	08 95       	ret

00005f96 <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
    5f96:	0f 93       	push	r16
    5f98:	1f 93       	push	r17
    5f9a:	df 93       	push	r29
    5f9c:	cf 93       	push	r28
    5f9e:	cd b7       	in	r28, 0x3d	; 61
    5fa0:	de b7       	in	r29, 0x3e	; 62
    5fa2:	2f 97       	sbiw	r28, 0x0f	; 15
    5fa4:	0f b6       	in	r0, 0x3f	; 63
    5fa6:	f8 94       	cli
    5fa8:	de bf       	out	0x3e, r29	; 62
    5faa:	0f be       	out	0x3f, r0	; 63
    5fac:	cd bf       	out	0x3d, r28	; 61
    5fae:	9e 83       	std	Y+6, r25	; 0x06
    5fb0:	8d 83       	std	Y+5, r24	; 0x05
    5fb2:	4f 83       	std	Y+7, r20	; 0x07
    5fb4:	58 87       	std	Y+8, r21	; 0x08
    5fb6:	69 87       	std	Y+9, r22	; 0x09
    5fb8:	7a 87       	std	Y+10, r23	; 0x0a
    5fba:	2b 87       	std	Y+11, r18	; 0x0b
    5fbc:	1d 87       	std	Y+13, r17	; 0x0d
    5fbe:	0c 87       	std	Y+12, r16	; 0x0c
	TCB_t * pxTCB;
	BaseType_t xReturn = pdPASS;
    5fc0:	81 e0       	ldi	r24, 0x01	; 1
    5fc2:	8a 83       	std	Y+2, r24	; 0x02
	uint8_t ucOriginalNotifyState;

		configASSERT( xTaskToNotify );
		pxTCB = xTaskToNotify;
    5fc4:	8d 81       	ldd	r24, Y+5	; 0x05
    5fc6:	9e 81       	ldd	r25, Y+6	; 0x06
    5fc8:	9c 83       	std	Y+4, r25	; 0x04
    5fca:	8b 83       	std	Y+3, r24	; 0x03

		taskENTER_CRITICAL();
    5fcc:	0f b6       	in	r0, 0x3f	; 63
    5fce:	f8 94       	cli
    5fd0:	0f 92       	push	r0
		{
			if( pulPreviousNotificationValue != NULL )
    5fd2:	8c 85       	ldd	r24, Y+12	; 0x0c
    5fd4:	9d 85       	ldd	r25, Y+13	; 0x0d
    5fd6:	00 97       	sbiw	r24, 0x00	; 0
    5fd8:	61 f0       	breq	.+24     	; 0x5ff2 <xTaskGenericNotify+0x5c>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    5fda:	eb 81       	ldd	r30, Y+3	; 0x03
    5fdc:	fc 81       	ldd	r31, Y+4	; 0x04
    5fde:	81 a1       	ldd	r24, Z+33	; 0x21
    5fe0:	92 a1       	ldd	r25, Z+34	; 0x22
    5fe2:	a3 a1       	ldd	r26, Z+35	; 0x23
    5fe4:	b4 a1       	ldd	r27, Z+36	; 0x24
    5fe6:	ec 85       	ldd	r30, Y+12	; 0x0c
    5fe8:	fd 85       	ldd	r31, Y+13	; 0x0d
    5fea:	80 83       	st	Z, r24
    5fec:	91 83       	std	Z+1, r25	; 0x01
    5fee:	a2 83       	std	Z+2, r26	; 0x02
    5ff0:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    5ff2:	eb 81       	ldd	r30, Y+3	; 0x03
    5ff4:	fc 81       	ldd	r31, Y+4	; 0x04
    5ff6:	85 a1       	ldd	r24, Z+37	; 0x25
    5ff8:	89 83       	std	Y+1, r24	; 0x01

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    5ffa:	eb 81       	ldd	r30, Y+3	; 0x03
    5ffc:	fc 81       	ldd	r31, Y+4	; 0x04
    5ffe:	82 e0       	ldi	r24, 0x02	; 2
    6000:	85 a3       	std	Z+37, r24	; 0x25

			switch( eAction )
    6002:	8b 85       	ldd	r24, Y+11	; 0x0b
    6004:	28 2f       	mov	r18, r24
    6006:	30 e0       	ldi	r19, 0x00	; 0
    6008:	3f 87       	std	Y+15, r19	; 0x0f
    600a:	2e 87       	std	Y+14, r18	; 0x0e
    600c:	8e 85       	ldd	r24, Y+14	; 0x0e
    600e:	9f 85       	ldd	r25, Y+15	; 0x0f
    6010:	82 30       	cpi	r24, 0x02	; 2
    6012:	91 05       	cpc	r25, r1
    6014:	59 f1       	breq	.+86     	; 0x606c <xTaskGenericNotify+0xd6>
    6016:	2e 85       	ldd	r18, Y+14	; 0x0e
    6018:	3f 85       	ldd	r19, Y+15	; 0x0f
    601a:	23 30       	cpi	r18, 0x03	; 3
    601c:	31 05       	cpc	r19, r1
    601e:	34 f4       	brge	.+12     	; 0x602c <xTaskGenericNotify+0x96>
    6020:	8e 85       	ldd	r24, Y+14	; 0x0e
    6022:	9f 85       	ldd	r25, Y+15	; 0x0f
    6024:	81 30       	cpi	r24, 0x01	; 1
    6026:	91 05       	cpc	r25, r1
    6028:	61 f0       	breq	.+24     	; 0x6042 <xTaskGenericNotify+0xac>
    602a:	4a c0       	rjmp	.+148    	; 0x60c0 <xTaskGenericNotify+0x12a>
    602c:	2e 85       	ldd	r18, Y+14	; 0x0e
    602e:	3f 85       	ldd	r19, Y+15	; 0x0f
    6030:	23 30       	cpi	r18, 0x03	; 3
    6032:	31 05       	cpc	r19, r1
    6034:	59 f1       	breq	.+86     	; 0x608c <xTaskGenericNotify+0xf6>
    6036:	8e 85       	ldd	r24, Y+14	; 0x0e
    6038:	9f 85       	ldd	r25, Y+15	; 0x0f
    603a:	84 30       	cpi	r24, 0x04	; 4
    603c:	91 05       	cpc	r25, r1
    603e:	89 f1       	breq	.+98     	; 0x60a2 <xTaskGenericNotify+0x10c>
    6040:	3f c0       	rjmp	.+126    	; 0x60c0 <xTaskGenericNotify+0x12a>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    6042:	eb 81       	ldd	r30, Y+3	; 0x03
    6044:	fc 81       	ldd	r31, Y+4	; 0x04
    6046:	21 a1       	ldd	r18, Z+33	; 0x21
    6048:	32 a1       	ldd	r19, Z+34	; 0x22
    604a:	43 a1       	ldd	r20, Z+35	; 0x23
    604c:	54 a1       	ldd	r21, Z+36	; 0x24
    604e:	8f 81       	ldd	r24, Y+7	; 0x07
    6050:	98 85       	ldd	r25, Y+8	; 0x08
    6052:	a9 85       	ldd	r26, Y+9	; 0x09
    6054:	ba 85       	ldd	r27, Y+10	; 0x0a
    6056:	82 2b       	or	r24, r18
    6058:	93 2b       	or	r25, r19
    605a:	a4 2b       	or	r26, r20
    605c:	b5 2b       	or	r27, r21
    605e:	eb 81       	ldd	r30, Y+3	; 0x03
    6060:	fc 81       	ldd	r31, Y+4	; 0x04
    6062:	81 a3       	std	Z+33, r24	; 0x21
    6064:	92 a3       	std	Z+34, r25	; 0x22
    6066:	a3 a3       	std	Z+35, r26	; 0x23
    6068:	b4 a3       	std	Z+36, r27	; 0x24
    606a:	2a c0       	rjmp	.+84     	; 0x60c0 <xTaskGenericNotify+0x12a>
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    606c:	eb 81       	ldd	r30, Y+3	; 0x03
    606e:	fc 81       	ldd	r31, Y+4	; 0x04
    6070:	81 a1       	ldd	r24, Z+33	; 0x21
    6072:	92 a1       	ldd	r25, Z+34	; 0x22
    6074:	a3 a1       	ldd	r26, Z+35	; 0x23
    6076:	b4 a1       	ldd	r27, Z+36	; 0x24
    6078:	01 96       	adiw	r24, 0x01	; 1
    607a:	a1 1d       	adc	r26, r1
    607c:	b1 1d       	adc	r27, r1
    607e:	eb 81       	ldd	r30, Y+3	; 0x03
    6080:	fc 81       	ldd	r31, Y+4	; 0x04
    6082:	81 a3       	std	Z+33, r24	; 0x21
    6084:	92 a3       	std	Z+34, r25	; 0x22
    6086:	a3 a3       	std	Z+35, r26	; 0x23
    6088:	b4 a3       	std	Z+36, r27	; 0x24
    608a:	1a c0       	rjmp	.+52     	; 0x60c0 <xTaskGenericNotify+0x12a>
					break;

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    608c:	eb 81       	ldd	r30, Y+3	; 0x03
    608e:	fc 81       	ldd	r31, Y+4	; 0x04
    6090:	8f 81       	ldd	r24, Y+7	; 0x07
    6092:	98 85       	ldd	r25, Y+8	; 0x08
    6094:	a9 85       	ldd	r26, Y+9	; 0x09
    6096:	ba 85       	ldd	r27, Y+10	; 0x0a
    6098:	81 a3       	std	Z+33, r24	; 0x21
    609a:	92 a3       	std	Z+34, r25	; 0x22
    609c:	a3 a3       	std	Z+35, r26	; 0x23
    609e:	b4 a3       	std	Z+36, r27	; 0x24
    60a0:	0f c0       	rjmp	.+30     	; 0x60c0 <xTaskGenericNotify+0x12a>
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    60a2:	89 81       	ldd	r24, Y+1	; 0x01
    60a4:	82 30       	cpi	r24, 0x02	; 2
    60a6:	59 f0       	breq	.+22     	; 0x60be <xTaskGenericNotify+0x128>
					{
						pxTCB->ulNotifiedValue = ulValue;
    60a8:	eb 81       	ldd	r30, Y+3	; 0x03
    60aa:	fc 81       	ldd	r31, Y+4	; 0x04
    60ac:	8f 81       	ldd	r24, Y+7	; 0x07
    60ae:	98 85       	ldd	r25, Y+8	; 0x08
    60b0:	a9 85       	ldd	r26, Y+9	; 0x09
    60b2:	ba 85       	ldd	r27, Y+10	; 0x0a
    60b4:	81 a3       	std	Z+33, r24	; 0x21
    60b6:	92 a3       	std	Z+34, r25	; 0x22
    60b8:	a3 a3       	std	Z+35, r26	; 0x23
    60ba:	b4 a3       	std	Z+36, r27	; 0x24
    60bc:	01 c0       	rjmp	.+2      	; 0x60c0 <xTaskGenericNotify+0x12a>
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    60be:	1a 82       	std	Y+2, r1	; 0x02

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    60c0:	89 81       	ldd	r24, Y+1	; 0x01
    60c2:	81 30       	cpi	r24, 0x01	; 1
    60c4:	b9 f5       	brne	.+110    	; 0x6134 <xTaskGenericNotify+0x19e>
			{
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    60c6:	8b 81       	ldd	r24, Y+3	; 0x03
    60c8:	9c 81       	ldd	r25, Y+4	; 0x04
    60ca:	02 96       	adiw	r24, 0x02	; 2
    60cc:	0e 94 13 12 	call	0x2426	; 0x2426 <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
    60d0:	eb 81       	ldd	r30, Y+3	; 0x03
    60d2:	fc 81       	ldd	r31, Y+4	; 0x04
    60d4:	96 89       	ldd	r25, Z+22	; 0x16
    60d6:	80 91 af 06 	lds	r24, 0x06AF
    60da:	89 17       	cp	r24, r25
    60dc:	28 f4       	brcc	.+10     	; 0x60e8 <xTaskGenericNotify+0x152>
    60de:	eb 81       	ldd	r30, Y+3	; 0x03
    60e0:	fc 81       	ldd	r31, Y+4	; 0x04
    60e2:	86 89       	ldd	r24, Z+22	; 0x16
    60e4:	80 93 af 06 	sts	0x06AF, r24
    60e8:	eb 81       	ldd	r30, Y+3	; 0x03
    60ea:	fc 81       	ldd	r31, Y+4	; 0x04
    60ec:	86 89       	ldd	r24, Z+22	; 0x16
    60ee:	28 2f       	mov	r18, r24
    60f0:	30 e0       	ldi	r19, 0x00	; 0
    60f2:	c9 01       	movw	r24, r18
    60f4:	88 0f       	add	r24, r24
    60f6:	99 1f       	adc	r25, r25
    60f8:	88 0f       	add	r24, r24
    60fa:	99 1f       	adc	r25, r25
    60fc:	88 0f       	add	r24, r24
    60fe:	99 1f       	adc	r25, r25
    6100:	82 0f       	add	r24, r18
    6102:	93 1f       	adc	r25, r19
    6104:	ac 01       	movw	r20, r24
    6106:	46 54       	subi	r20, 0x46	; 70
    6108:	59 4f       	sbci	r21, 0xF9	; 249
    610a:	8b 81       	ldd	r24, Y+3	; 0x03
    610c:	9c 81       	ldd	r25, Y+4	; 0x04
    610e:	9c 01       	movw	r18, r24
    6110:	2e 5f       	subi	r18, 0xFE	; 254
    6112:	3f 4f       	sbci	r19, 0xFF	; 255
    6114:	ca 01       	movw	r24, r20
    6116:	b9 01       	movw	r22, r18
    6118:	0e 94 63 11 	call	0x22c6	; 0x22c6 <vListInsertEnd>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    611c:	eb 81       	ldd	r30, Y+3	; 0x03
    611e:	fc 81       	ldd	r31, Y+4	; 0x04
    6120:	96 89       	ldd	r25, Z+22	; 0x16
    6122:	e0 91 a9 06 	lds	r30, 0x06A9
    6126:	f0 91 aa 06 	lds	r31, 0x06AA
    612a:	86 89       	ldd	r24, Z+22	; 0x16
    612c:	89 17       	cp	r24, r25
    612e:	10 f4       	brcc	.+4      	; 0x6134 <xTaskGenericNotify+0x19e>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
    6130:	0e 94 d8 15 	call	0x2bb0	; 0x2bb0 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    6134:	0f 90       	pop	r0
    6136:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    6138:	8a 81       	ldd	r24, Y+2	; 0x02
	}
    613a:	2f 96       	adiw	r28, 0x0f	; 15
    613c:	0f b6       	in	r0, 0x3f	; 63
    613e:	f8 94       	cli
    6140:	de bf       	out	0x3e, r29	; 62
    6142:	0f be       	out	0x3f, r0	; 63
    6144:	cd bf       	out	0x3d, r28	; 61
    6146:	cf 91       	pop	r28
    6148:	df 91       	pop	r29
    614a:	1f 91       	pop	r17
    614c:	0f 91       	pop	r16
    614e:	08 95       	ret

00006150 <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
    6150:	ef 92       	push	r14
    6152:	ff 92       	push	r15
    6154:	0f 93       	push	r16
    6156:	1f 93       	push	r17
    6158:	df 93       	push	r29
    615a:	cf 93       	push	r28
    615c:	cd b7       	in	r28, 0x3d	; 61
    615e:	de b7       	in	r29, 0x3e	; 62
    6160:	62 97       	sbiw	r28, 0x12	; 18
    6162:	0f b6       	in	r0, 0x3f	; 63
    6164:	f8 94       	cli
    6166:	de bf       	out	0x3e, r29	; 62
    6168:	0f be       	out	0x3f, r0	; 63
    616a:	cd bf       	out	0x3d, r28	; 61
    616c:	9f 83       	std	Y+7, r25	; 0x07
    616e:	8e 83       	std	Y+6, r24	; 0x06
    6170:	48 87       	std	Y+8, r20	; 0x08
    6172:	59 87       	std	Y+9, r21	; 0x09
    6174:	6a 87       	std	Y+10, r22	; 0x0a
    6176:	7b 87       	std	Y+11, r23	; 0x0b
    6178:	2c 87       	std	Y+12, r18	; 0x0c
    617a:	1e 87       	std	Y+14, r17	; 0x0e
    617c:	0d 87       	std	Y+13, r16	; 0x0d
    617e:	f8 8a       	std	Y+16, r15	; 0x10
    6180:	ef 86       	std	Y+15, r14	; 0x0f
	TCB_t * pxTCB;
	uint8_t ucOriginalNotifyState;
	BaseType_t xReturn = pdPASS;
    6182:	81 e0       	ldi	r24, 0x01	; 1
    6184:	8a 83       	std	Y+2, r24	; 0x02
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = xTaskToNotify;
    6186:	8e 81       	ldd	r24, Y+6	; 0x06
    6188:	9f 81       	ldd	r25, Y+7	; 0x07
    618a:	9d 83       	std	Y+5, r25	; 0x05
    618c:	8c 83       	std	Y+4, r24	; 0x04

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    618e:	19 82       	std	Y+1, r1	; 0x01
		{
			if( pulPreviousNotificationValue != NULL )
    6190:	8d 85       	ldd	r24, Y+13	; 0x0d
    6192:	9e 85       	ldd	r25, Y+14	; 0x0e
    6194:	00 97       	sbiw	r24, 0x00	; 0
    6196:	61 f0       	breq	.+24     	; 0x61b0 <xTaskGenericNotifyFromISR+0x60>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    6198:	ec 81       	ldd	r30, Y+4	; 0x04
    619a:	fd 81       	ldd	r31, Y+5	; 0x05
    619c:	81 a1       	ldd	r24, Z+33	; 0x21
    619e:	92 a1       	ldd	r25, Z+34	; 0x22
    61a0:	a3 a1       	ldd	r26, Z+35	; 0x23
    61a2:	b4 a1       	ldd	r27, Z+36	; 0x24
    61a4:	ed 85       	ldd	r30, Y+13	; 0x0d
    61a6:	fe 85       	ldd	r31, Y+14	; 0x0e
    61a8:	80 83       	st	Z, r24
    61aa:	91 83       	std	Z+1, r25	; 0x01
    61ac:	a2 83       	std	Z+2, r26	; 0x02
    61ae:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    61b0:	ec 81       	ldd	r30, Y+4	; 0x04
    61b2:	fd 81       	ldd	r31, Y+5	; 0x05
    61b4:	85 a1       	ldd	r24, Z+37	; 0x25
    61b6:	8b 83       	std	Y+3, r24	; 0x03
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    61b8:	ec 81       	ldd	r30, Y+4	; 0x04
    61ba:	fd 81       	ldd	r31, Y+5	; 0x05
    61bc:	82 e0       	ldi	r24, 0x02	; 2
    61be:	85 a3       	std	Z+37, r24	; 0x25

			switch( eAction )
    61c0:	8c 85       	ldd	r24, Y+12	; 0x0c
    61c2:	28 2f       	mov	r18, r24
    61c4:	30 e0       	ldi	r19, 0x00	; 0
    61c6:	3a 8b       	std	Y+18, r19	; 0x12
    61c8:	29 8b       	std	Y+17, r18	; 0x11
    61ca:	89 89       	ldd	r24, Y+17	; 0x11
    61cc:	9a 89       	ldd	r25, Y+18	; 0x12
    61ce:	82 30       	cpi	r24, 0x02	; 2
    61d0:	91 05       	cpc	r25, r1
    61d2:	59 f1       	breq	.+86     	; 0x622a <xTaskGenericNotifyFromISR+0xda>
    61d4:	29 89       	ldd	r18, Y+17	; 0x11
    61d6:	3a 89       	ldd	r19, Y+18	; 0x12
    61d8:	23 30       	cpi	r18, 0x03	; 3
    61da:	31 05       	cpc	r19, r1
    61dc:	34 f4       	brge	.+12     	; 0x61ea <xTaskGenericNotifyFromISR+0x9a>
    61de:	89 89       	ldd	r24, Y+17	; 0x11
    61e0:	9a 89       	ldd	r25, Y+18	; 0x12
    61e2:	81 30       	cpi	r24, 0x01	; 1
    61e4:	91 05       	cpc	r25, r1
    61e6:	61 f0       	breq	.+24     	; 0x6200 <xTaskGenericNotifyFromISR+0xb0>
    61e8:	4a c0       	rjmp	.+148    	; 0x627e <xTaskGenericNotifyFromISR+0x12e>
    61ea:	29 89       	ldd	r18, Y+17	; 0x11
    61ec:	3a 89       	ldd	r19, Y+18	; 0x12
    61ee:	23 30       	cpi	r18, 0x03	; 3
    61f0:	31 05       	cpc	r19, r1
    61f2:	59 f1       	breq	.+86     	; 0x624a <xTaskGenericNotifyFromISR+0xfa>
    61f4:	89 89       	ldd	r24, Y+17	; 0x11
    61f6:	9a 89       	ldd	r25, Y+18	; 0x12
    61f8:	84 30       	cpi	r24, 0x04	; 4
    61fa:	91 05       	cpc	r25, r1
    61fc:	89 f1       	breq	.+98     	; 0x6260 <xTaskGenericNotifyFromISR+0x110>
    61fe:	3f c0       	rjmp	.+126    	; 0x627e <xTaskGenericNotifyFromISR+0x12e>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    6200:	ec 81       	ldd	r30, Y+4	; 0x04
    6202:	fd 81       	ldd	r31, Y+5	; 0x05
    6204:	21 a1       	ldd	r18, Z+33	; 0x21
    6206:	32 a1       	ldd	r19, Z+34	; 0x22
    6208:	43 a1       	ldd	r20, Z+35	; 0x23
    620a:	54 a1       	ldd	r21, Z+36	; 0x24
    620c:	88 85       	ldd	r24, Y+8	; 0x08
    620e:	99 85       	ldd	r25, Y+9	; 0x09
    6210:	aa 85       	ldd	r26, Y+10	; 0x0a
    6212:	bb 85       	ldd	r27, Y+11	; 0x0b
    6214:	82 2b       	or	r24, r18
    6216:	93 2b       	or	r25, r19
    6218:	a4 2b       	or	r26, r20
    621a:	b5 2b       	or	r27, r21
    621c:	ec 81       	ldd	r30, Y+4	; 0x04
    621e:	fd 81       	ldd	r31, Y+5	; 0x05
    6220:	81 a3       	std	Z+33, r24	; 0x21
    6222:	92 a3       	std	Z+34, r25	; 0x22
    6224:	a3 a3       	std	Z+35, r26	; 0x23
    6226:	b4 a3       	std	Z+36, r27	; 0x24
    6228:	2a c0       	rjmp	.+84     	; 0x627e <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    622a:	ec 81       	ldd	r30, Y+4	; 0x04
    622c:	fd 81       	ldd	r31, Y+5	; 0x05
    622e:	81 a1       	ldd	r24, Z+33	; 0x21
    6230:	92 a1       	ldd	r25, Z+34	; 0x22
    6232:	a3 a1       	ldd	r26, Z+35	; 0x23
    6234:	b4 a1       	ldd	r27, Z+36	; 0x24
    6236:	01 96       	adiw	r24, 0x01	; 1
    6238:	a1 1d       	adc	r26, r1
    623a:	b1 1d       	adc	r27, r1
    623c:	ec 81       	ldd	r30, Y+4	; 0x04
    623e:	fd 81       	ldd	r31, Y+5	; 0x05
    6240:	81 a3       	std	Z+33, r24	; 0x21
    6242:	92 a3       	std	Z+34, r25	; 0x22
    6244:	a3 a3       	std	Z+35, r26	; 0x23
    6246:	b4 a3       	std	Z+36, r27	; 0x24
    6248:	1a c0       	rjmp	.+52     	; 0x627e <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    624a:	ec 81       	ldd	r30, Y+4	; 0x04
    624c:	fd 81       	ldd	r31, Y+5	; 0x05
    624e:	88 85       	ldd	r24, Y+8	; 0x08
    6250:	99 85       	ldd	r25, Y+9	; 0x09
    6252:	aa 85       	ldd	r26, Y+10	; 0x0a
    6254:	bb 85       	ldd	r27, Y+11	; 0x0b
    6256:	81 a3       	std	Z+33, r24	; 0x21
    6258:	92 a3       	std	Z+34, r25	; 0x22
    625a:	a3 a3       	std	Z+35, r26	; 0x23
    625c:	b4 a3       	std	Z+36, r27	; 0x24
    625e:	0f c0       	rjmp	.+30     	; 0x627e <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    6260:	8b 81       	ldd	r24, Y+3	; 0x03
    6262:	82 30       	cpi	r24, 0x02	; 2
    6264:	59 f0       	breq	.+22     	; 0x627c <xTaskGenericNotifyFromISR+0x12c>
					{
						pxTCB->ulNotifiedValue = ulValue;
    6266:	ec 81       	ldd	r30, Y+4	; 0x04
    6268:	fd 81       	ldd	r31, Y+5	; 0x05
    626a:	88 85       	ldd	r24, Y+8	; 0x08
    626c:	99 85       	ldd	r25, Y+9	; 0x09
    626e:	aa 85       	ldd	r26, Y+10	; 0x0a
    6270:	bb 85       	ldd	r27, Y+11	; 0x0b
    6272:	81 a3       	std	Z+33, r24	; 0x21
    6274:	92 a3       	std	Z+34, r25	; 0x22
    6276:	a3 a3       	std	Z+35, r26	; 0x23
    6278:	b4 a3       	std	Z+36, r27	; 0x24
    627a:	01 c0       	rjmp	.+2      	; 0x627e <xTaskGenericNotifyFromISR+0x12e>
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    627c:	1a 82       	std	Y+2, r1	; 0x02

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    627e:	8b 81       	ldd	r24, Y+3	; 0x03
    6280:	81 30       	cpi	r24, 0x01	; 1
    6282:	09 f0       	breq	.+2      	; 0x6286 <xTaskGenericNotifyFromISR+0x136>
    6284:	4f c0       	rjmp	.+158    	; 0x6324 <xTaskGenericNotifyFromISR+0x1d4>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    6286:	80 91 b9 06 	lds	r24, 0x06B9
    628a:	88 23       	and	r24, r24
    628c:	61 f5       	brne	.+88     	; 0x62e6 <xTaskGenericNotifyFromISR+0x196>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    628e:	8c 81       	ldd	r24, Y+4	; 0x04
    6290:	9d 81       	ldd	r25, Y+5	; 0x05
    6292:	02 96       	adiw	r24, 0x02	; 2
    6294:	0e 94 13 12 	call	0x2426	; 0x2426 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    6298:	ec 81       	ldd	r30, Y+4	; 0x04
    629a:	fd 81       	ldd	r31, Y+5	; 0x05
    629c:	96 89       	ldd	r25, Z+22	; 0x16
    629e:	80 91 af 06 	lds	r24, 0x06AF
    62a2:	89 17       	cp	r24, r25
    62a4:	28 f4       	brcc	.+10     	; 0x62b0 <xTaskGenericNotifyFromISR+0x160>
    62a6:	ec 81       	ldd	r30, Y+4	; 0x04
    62a8:	fd 81       	ldd	r31, Y+5	; 0x05
    62aa:	86 89       	ldd	r24, Z+22	; 0x16
    62ac:	80 93 af 06 	sts	0x06AF, r24
    62b0:	ec 81       	ldd	r30, Y+4	; 0x04
    62b2:	fd 81       	ldd	r31, Y+5	; 0x05
    62b4:	86 89       	ldd	r24, Z+22	; 0x16
    62b6:	28 2f       	mov	r18, r24
    62b8:	30 e0       	ldi	r19, 0x00	; 0
    62ba:	c9 01       	movw	r24, r18
    62bc:	88 0f       	add	r24, r24
    62be:	99 1f       	adc	r25, r25
    62c0:	88 0f       	add	r24, r24
    62c2:	99 1f       	adc	r25, r25
    62c4:	88 0f       	add	r24, r24
    62c6:	99 1f       	adc	r25, r25
    62c8:	82 0f       	add	r24, r18
    62ca:	93 1f       	adc	r25, r19
    62cc:	ac 01       	movw	r20, r24
    62ce:	46 54       	subi	r20, 0x46	; 70
    62d0:	59 4f       	sbci	r21, 0xF9	; 249
    62d2:	8c 81       	ldd	r24, Y+4	; 0x04
    62d4:	9d 81       	ldd	r25, Y+5	; 0x05
    62d6:	9c 01       	movw	r18, r24
    62d8:	2e 5f       	subi	r18, 0xFE	; 254
    62da:	3f 4f       	sbci	r19, 0xFF	; 255
    62dc:	ca 01       	movw	r24, r20
    62de:	b9 01       	movw	r22, r18
    62e0:	0e 94 63 11 	call	0x22c6	; 0x22c6 <vListInsertEnd>
    62e4:	0a c0       	rjmp	.+20     	; 0x62fa <xTaskGenericNotifyFromISR+0x1aa>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    62e6:	8c 81       	ldd	r24, Y+4	; 0x04
    62e8:	9d 81       	ldd	r25, Y+5	; 0x05
    62ea:	9c 01       	movw	r18, r24
    62ec:	24 5f       	subi	r18, 0xF4	; 244
    62ee:	3f 4f       	sbci	r19, 0xFF	; 255
    62f0:	84 ef       	ldi	r24, 0xF4	; 244
    62f2:	96 e0       	ldi	r25, 0x06	; 6
    62f4:	b9 01       	movw	r22, r18
    62f6:	0e 94 63 11 	call	0x22c6	; 0x22c6 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    62fa:	ec 81       	ldd	r30, Y+4	; 0x04
    62fc:	fd 81       	ldd	r31, Y+5	; 0x05
    62fe:	96 89       	ldd	r25, Z+22	; 0x16
    6300:	e0 91 a9 06 	lds	r30, 0x06A9
    6304:	f0 91 aa 06 	lds	r31, 0x06AA
    6308:	86 89       	ldd	r24, Z+22	; 0x16
    630a:	89 17       	cp	r24, r25
    630c:	58 f4       	brcc	.+22     	; 0x6324 <xTaskGenericNotifyFromISR+0x1d4>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    630e:	8f 85       	ldd	r24, Y+15	; 0x0f
    6310:	98 89       	ldd	r25, Y+16	; 0x10
    6312:	00 97       	sbiw	r24, 0x00	; 0
    6314:	21 f0       	breq	.+8      	; 0x631e <xTaskGenericNotifyFromISR+0x1ce>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    6316:	ef 85       	ldd	r30, Y+15	; 0x0f
    6318:	f8 89       	ldd	r31, Y+16	; 0x10
    631a:	81 e0       	ldi	r24, 0x01	; 1
    631c:	80 83       	st	Z, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter to an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    631e:	81 e0       	ldi	r24, 0x01	; 1
    6320:	80 93 b2 06 	sts	0x06B2, r24
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
    6324:	8a 81       	ldd	r24, Y+2	; 0x02
	}
    6326:	62 96       	adiw	r28, 0x12	; 18
    6328:	0f b6       	in	r0, 0x3f	; 63
    632a:	f8 94       	cli
    632c:	de bf       	out	0x3e, r29	; 62
    632e:	0f be       	out	0x3f, r0	; 63
    6330:	cd bf       	out	0x3d, r28	; 61
    6332:	cf 91       	pop	r28
    6334:	df 91       	pop	r29
    6336:	1f 91       	pop	r17
    6338:	0f 91       	pop	r16
    633a:	ff 90       	pop	r15
    633c:	ef 90       	pop	r14
    633e:	08 95       	ret

00006340 <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
    6340:	df 93       	push	r29
    6342:	cf 93       	push	r28
    6344:	cd b7       	in	r28, 0x3d	; 61
    6346:	de b7       	in	r29, 0x3e	; 62
    6348:	28 97       	sbiw	r28, 0x08	; 8
    634a:	0f b6       	in	r0, 0x3f	; 63
    634c:	f8 94       	cli
    634e:	de bf       	out	0x3e, r29	; 62
    6350:	0f be       	out	0x3f, r0	; 63
    6352:	cd bf       	out	0x3d, r28	; 61
    6354:	9e 83       	std	Y+6, r25	; 0x06
    6356:	8d 83       	std	Y+5, r24	; 0x05
    6358:	78 87       	std	Y+8, r23	; 0x08
    635a:	6f 83       	std	Y+7, r22	; 0x07
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = xTaskToNotify;
    635c:	8d 81       	ldd	r24, Y+5	; 0x05
    635e:	9e 81       	ldd	r25, Y+6	; 0x06
    6360:	9c 83       	std	Y+4, r25	; 0x04
    6362:	8b 83       	std	Y+3, r24	; 0x03

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    6364:	19 82       	std	Y+1, r1	; 0x01
		{
			ucOriginalNotifyState = pxTCB->ucNotifyState;
    6366:	eb 81       	ldd	r30, Y+3	; 0x03
    6368:	fc 81       	ldd	r31, Y+4	; 0x04
    636a:	85 a1       	ldd	r24, Z+37	; 0x25
    636c:	8a 83       	std	Y+2, r24	; 0x02
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    636e:	eb 81       	ldd	r30, Y+3	; 0x03
    6370:	fc 81       	ldd	r31, Y+4	; 0x04
    6372:	82 e0       	ldi	r24, 0x02	; 2
    6374:	85 a3       	std	Z+37, r24	; 0x25

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
    6376:	eb 81       	ldd	r30, Y+3	; 0x03
    6378:	fc 81       	ldd	r31, Y+4	; 0x04
    637a:	81 a1       	ldd	r24, Z+33	; 0x21
    637c:	92 a1       	ldd	r25, Z+34	; 0x22
    637e:	a3 a1       	ldd	r26, Z+35	; 0x23
    6380:	b4 a1       	ldd	r27, Z+36	; 0x24
    6382:	01 96       	adiw	r24, 0x01	; 1
    6384:	a1 1d       	adc	r26, r1
    6386:	b1 1d       	adc	r27, r1
    6388:	eb 81       	ldd	r30, Y+3	; 0x03
    638a:	fc 81       	ldd	r31, Y+4	; 0x04
    638c:	81 a3       	std	Z+33, r24	; 0x21
    638e:	92 a3       	std	Z+34, r25	; 0x22
    6390:	a3 a3       	std	Z+35, r26	; 0x23
    6392:	b4 a3       	std	Z+36, r27	; 0x24

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    6394:	8a 81       	ldd	r24, Y+2	; 0x02
    6396:	81 30       	cpi	r24, 0x01	; 1
    6398:	09 f0       	breq	.+2      	; 0x639c <vTaskNotifyGiveFromISR+0x5c>
    639a:	4f c0       	rjmp	.+158    	; 0x643a <vTaskNotifyGiveFromISR+0xfa>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    639c:	80 91 b9 06 	lds	r24, 0x06B9
    63a0:	88 23       	and	r24, r24
    63a2:	61 f5       	brne	.+88     	; 0x63fc <vTaskNotifyGiveFromISR+0xbc>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    63a4:	8b 81       	ldd	r24, Y+3	; 0x03
    63a6:	9c 81       	ldd	r25, Y+4	; 0x04
    63a8:	02 96       	adiw	r24, 0x02	; 2
    63aa:	0e 94 13 12 	call	0x2426	; 0x2426 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    63ae:	eb 81       	ldd	r30, Y+3	; 0x03
    63b0:	fc 81       	ldd	r31, Y+4	; 0x04
    63b2:	96 89       	ldd	r25, Z+22	; 0x16
    63b4:	80 91 af 06 	lds	r24, 0x06AF
    63b8:	89 17       	cp	r24, r25
    63ba:	28 f4       	brcc	.+10     	; 0x63c6 <vTaskNotifyGiveFromISR+0x86>
    63bc:	eb 81       	ldd	r30, Y+3	; 0x03
    63be:	fc 81       	ldd	r31, Y+4	; 0x04
    63c0:	86 89       	ldd	r24, Z+22	; 0x16
    63c2:	80 93 af 06 	sts	0x06AF, r24
    63c6:	eb 81       	ldd	r30, Y+3	; 0x03
    63c8:	fc 81       	ldd	r31, Y+4	; 0x04
    63ca:	86 89       	ldd	r24, Z+22	; 0x16
    63cc:	28 2f       	mov	r18, r24
    63ce:	30 e0       	ldi	r19, 0x00	; 0
    63d0:	c9 01       	movw	r24, r18
    63d2:	88 0f       	add	r24, r24
    63d4:	99 1f       	adc	r25, r25
    63d6:	88 0f       	add	r24, r24
    63d8:	99 1f       	adc	r25, r25
    63da:	88 0f       	add	r24, r24
    63dc:	99 1f       	adc	r25, r25
    63de:	82 0f       	add	r24, r18
    63e0:	93 1f       	adc	r25, r19
    63e2:	ac 01       	movw	r20, r24
    63e4:	46 54       	subi	r20, 0x46	; 70
    63e6:	59 4f       	sbci	r21, 0xF9	; 249
    63e8:	8b 81       	ldd	r24, Y+3	; 0x03
    63ea:	9c 81       	ldd	r25, Y+4	; 0x04
    63ec:	9c 01       	movw	r18, r24
    63ee:	2e 5f       	subi	r18, 0xFE	; 254
    63f0:	3f 4f       	sbci	r19, 0xFF	; 255
    63f2:	ca 01       	movw	r24, r20
    63f4:	b9 01       	movw	r22, r18
    63f6:	0e 94 63 11 	call	0x22c6	; 0x22c6 <vListInsertEnd>
    63fa:	0a c0       	rjmp	.+20     	; 0x6410 <vTaskNotifyGiveFromISR+0xd0>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    63fc:	8b 81       	ldd	r24, Y+3	; 0x03
    63fe:	9c 81       	ldd	r25, Y+4	; 0x04
    6400:	9c 01       	movw	r18, r24
    6402:	24 5f       	subi	r18, 0xF4	; 244
    6404:	3f 4f       	sbci	r19, 0xFF	; 255
    6406:	84 ef       	ldi	r24, 0xF4	; 244
    6408:	96 e0       	ldi	r25, 0x06	; 6
    640a:	b9 01       	movw	r22, r18
    640c:	0e 94 63 11 	call	0x22c6	; 0x22c6 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    6410:	eb 81       	ldd	r30, Y+3	; 0x03
    6412:	fc 81       	ldd	r31, Y+4	; 0x04
    6414:	96 89       	ldd	r25, Z+22	; 0x16
    6416:	e0 91 a9 06 	lds	r30, 0x06A9
    641a:	f0 91 aa 06 	lds	r31, 0x06AA
    641e:	86 89       	ldd	r24, Z+22	; 0x16
    6420:	89 17       	cp	r24, r25
    6422:	58 f4       	brcc	.+22     	; 0x643a <vTaskNotifyGiveFromISR+0xfa>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    6424:	8f 81       	ldd	r24, Y+7	; 0x07
    6426:	98 85       	ldd	r25, Y+8	; 0x08
    6428:	00 97       	sbiw	r24, 0x00	; 0
    642a:	21 f0       	breq	.+8      	; 0x6434 <vTaskNotifyGiveFromISR+0xf4>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    642c:	ef 81       	ldd	r30, Y+7	; 0x07
    642e:	f8 85       	ldd	r31, Y+8	; 0x08
    6430:	81 e0       	ldi	r24, 0x01	; 1
    6432:	80 83       	st	Z, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter in an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    6434:	81 e0       	ldi	r24, 0x01	; 1
    6436:	80 93 b2 06 	sts	0x06B2, r24
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
    643a:	28 96       	adiw	r28, 0x08	; 8
    643c:	0f b6       	in	r0, 0x3f	; 63
    643e:	f8 94       	cli
    6440:	de bf       	out	0x3e, r29	; 62
    6442:	0f be       	out	0x3f, r0	; 63
    6444:	cd bf       	out	0x3d, r28	; 61
    6446:	cf 91       	pop	r28
    6448:	df 91       	pop	r29
    644a:	08 95       	ret

0000644c <xTaskNotifyStateClear>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
	{
    644c:	df 93       	push	r29
    644e:	cf 93       	push	r28
    6450:	cd b7       	in	r28, 0x3d	; 61
    6452:	de b7       	in	r29, 0x3e	; 62
    6454:	27 97       	sbiw	r28, 0x07	; 7
    6456:	0f b6       	in	r0, 0x3f	; 63
    6458:	f8 94       	cli
    645a:	de bf       	out	0x3e, r29	; 62
    645c:	0f be       	out	0x3f, r0	; 63
    645e:	cd bf       	out	0x3d, r28	; 61
    6460:	9d 83       	std	Y+5, r25	; 0x05
    6462:	8c 83       	std	Y+4, r24	; 0x04
	TCB_t *pxTCB;
	BaseType_t xReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
    6464:	8c 81       	ldd	r24, Y+4	; 0x04
    6466:	9d 81       	ldd	r25, Y+5	; 0x05
    6468:	00 97       	sbiw	r24, 0x00	; 0
    646a:	39 f4       	brne	.+14     	; 0x647a <xTaskNotifyStateClear+0x2e>
    646c:	80 91 a9 06 	lds	r24, 0x06A9
    6470:	90 91 aa 06 	lds	r25, 0x06AA
    6474:	9f 83       	std	Y+7, r25	; 0x07
    6476:	8e 83       	std	Y+6, r24	; 0x06
    6478:	04 c0       	rjmp	.+8      	; 0x6482 <xTaskNotifyStateClear+0x36>
    647a:	8c 81       	ldd	r24, Y+4	; 0x04
    647c:	9d 81       	ldd	r25, Y+5	; 0x05
    647e:	9f 83       	std	Y+7, r25	; 0x07
    6480:	8e 83       	std	Y+6, r24	; 0x06
    6482:	8e 81       	ldd	r24, Y+6	; 0x06
    6484:	9f 81       	ldd	r25, Y+7	; 0x07
    6486:	9b 83       	std	Y+3, r25	; 0x03
    6488:	8a 83       	std	Y+2, r24	; 0x02

		taskENTER_CRITICAL();
    648a:	0f b6       	in	r0, 0x3f	; 63
    648c:	f8 94       	cli
    648e:	0f 92       	push	r0
		{
			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
    6490:	ea 81       	ldd	r30, Y+2	; 0x02
    6492:	fb 81       	ldd	r31, Y+3	; 0x03
    6494:	85 a1       	ldd	r24, Z+37	; 0x25
    6496:	82 30       	cpi	r24, 0x02	; 2
    6498:	31 f4       	brne	.+12     	; 0x64a6 <xTaskNotifyStateClear+0x5a>
			{
				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    649a:	ea 81       	ldd	r30, Y+2	; 0x02
    649c:	fb 81       	ldd	r31, Y+3	; 0x03
    649e:	15 a2       	std	Z+37, r1	; 0x25
				xReturn = pdPASS;
    64a0:	81 e0       	ldi	r24, 0x01	; 1
    64a2:	89 83       	std	Y+1, r24	; 0x01
    64a4:	01 c0       	rjmp	.+2      	; 0x64a8 <xTaskNotifyStateClear+0x5c>
			}
			else
			{
				xReturn = pdFAIL;
    64a6:	19 82       	std	Y+1, r1	; 0x01
			}
		}
		taskEXIT_CRITICAL();
    64a8:	0f 90       	pop	r0
    64aa:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    64ac:	89 81       	ldd	r24, Y+1	; 0x01
	}
    64ae:	27 96       	adiw	r28, 0x07	; 7
    64b0:	0f b6       	in	r0, 0x3f	; 63
    64b2:	f8 94       	cli
    64b4:	de bf       	out	0x3e, r29	; 62
    64b6:	0f be       	out	0x3f, r0	; 63
    64b8:	cd bf       	out	0x3d, r28	; 61
    64ba:	cf 91       	pop	r28
    64bc:	df 91       	pop	r29
    64be:	08 95       	ret

000064c0 <prvAddCurrentTaskToDelayedList>:
	}
#endif
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
    64c0:	df 93       	push	r29
    64c2:	cf 93       	push	r28
    64c4:	cd b7       	in	r28, 0x3d	; 61
    64c6:	de b7       	in	r29, 0x3e	; 62
    64c8:	27 97       	sbiw	r28, 0x07	; 7
    64ca:	0f b6       	in	r0, 0x3f	; 63
    64cc:	f8 94       	cli
    64ce:	de bf       	out	0x3e, r29	; 62
    64d0:	0f be       	out	0x3f, r0	; 63
    64d2:	cd bf       	out	0x3d, r28	; 61
    64d4:	9e 83       	std	Y+6, r25	; 0x06
    64d6:	8d 83       	std	Y+5, r24	; 0x05
    64d8:	6f 83       	std	Y+7, r22	; 0x07
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
    64da:	80 91 ad 06 	lds	r24, 0x06AD
    64de:	90 91 ae 06 	lds	r25, 0x06AE
    64e2:	9a 83       	std	Y+2, r25	; 0x02
    64e4:	89 83       	std	Y+1, r24	; 0x01
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    64e6:	80 91 a9 06 	lds	r24, 0x06A9
    64ea:	90 91 aa 06 	lds	r25, 0x06AA
    64ee:	02 96       	adiw	r24, 0x02	; 2
    64f0:	0e 94 13 12 	call	0x2426	; 0x2426 <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
    64f4:	8d 81       	ldd	r24, Y+5	; 0x05
    64f6:	9e 81       	ldd	r25, Y+6	; 0x06
    64f8:	2f ef       	ldi	r18, 0xFF	; 255
    64fa:	8f 3f       	cpi	r24, 0xFF	; 255
    64fc:	92 07       	cpc	r25, r18
    64fe:	81 f4       	brne	.+32     	; 0x6520 <prvAddCurrentTaskToDelayedList+0x60>
    6500:	8f 81       	ldd	r24, Y+7	; 0x07
    6502:	88 23       	and	r24, r24
    6504:	69 f0       	breq	.+26     	; 0x6520 <prvAddCurrentTaskToDelayedList+0x60>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
    6506:	80 91 a9 06 	lds	r24, 0x06A9
    650a:	90 91 aa 06 	lds	r25, 0x06AA
    650e:	9c 01       	movw	r18, r24
    6510:	2e 5f       	subi	r18, 0xFE	; 254
    6512:	3f 4f       	sbci	r19, 0xFF	; 255
    6514:	86 e0       	ldi	r24, 0x06	; 6
    6516:	97 e0       	ldi	r25, 0x07	; 7
    6518:	b9 01       	movw	r22, r18
    651a:	0e 94 63 11 	call	0x22c6	; 0x22c6 <vListInsertEnd>
    651e:	43 c0       	rjmp	.+134    	; 0x65a6 <prvAddCurrentTaskToDelayedList+0xe6>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
    6520:	29 81       	ldd	r18, Y+1	; 0x01
    6522:	3a 81       	ldd	r19, Y+2	; 0x02
    6524:	8d 81       	ldd	r24, Y+5	; 0x05
    6526:	9e 81       	ldd	r25, Y+6	; 0x06
    6528:	82 0f       	add	r24, r18
    652a:	93 1f       	adc	r25, r19
    652c:	9c 83       	std	Y+4, r25	; 0x04
    652e:	8b 83       	std	Y+3, r24	; 0x03

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    6530:	e0 91 a9 06 	lds	r30, 0x06A9
    6534:	f0 91 aa 06 	lds	r31, 0x06AA
    6538:	8b 81       	ldd	r24, Y+3	; 0x03
    653a:	9c 81       	ldd	r25, Y+4	; 0x04
    653c:	93 83       	std	Z+3, r25	; 0x03
    653e:	82 83       	std	Z+2, r24	; 0x02

			if( xTimeToWake < xConstTickCount )
    6540:	2b 81       	ldd	r18, Y+3	; 0x03
    6542:	3c 81       	ldd	r19, Y+4	; 0x04
    6544:	89 81       	ldd	r24, Y+1	; 0x01
    6546:	9a 81       	ldd	r25, Y+2	; 0x02
    6548:	28 17       	cp	r18, r24
    654a:	39 07       	cpc	r19, r25
    654c:	70 f4       	brcc	.+28     	; 0x656a <prvAddCurrentTaskToDelayedList+0xaa>
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    654e:	80 91 f2 06 	lds	r24, 0x06F2
    6552:	90 91 f3 06 	lds	r25, 0x06F3
    6556:	20 91 a9 06 	lds	r18, 0x06A9
    655a:	30 91 aa 06 	lds	r19, 0x06AA
    655e:	2e 5f       	subi	r18, 0xFE	; 254
    6560:	3f 4f       	sbci	r19, 0xFF	; 255
    6562:	b9 01       	movw	r22, r18
    6564:	0e 94 a7 11 	call	0x234e	; 0x234e <vListInsert>
    6568:	1e c0       	rjmp	.+60     	; 0x65a6 <prvAddCurrentTaskToDelayedList+0xe6>
			}
			else
			{
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    656a:	40 91 f0 06 	lds	r20, 0x06F0
    656e:	50 91 f1 06 	lds	r21, 0x06F1
    6572:	80 91 a9 06 	lds	r24, 0x06A9
    6576:	90 91 aa 06 	lds	r25, 0x06AA
    657a:	9c 01       	movw	r18, r24
    657c:	2e 5f       	subi	r18, 0xFE	; 254
    657e:	3f 4f       	sbci	r19, 0xFF	; 255
    6580:	ca 01       	movw	r24, r20
    6582:	b9 01       	movw	r22, r18
    6584:	0e 94 a7 11 	call	0x234e	; 0x234e <vListInsert>

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
    6588:	20 91 b5 06 	lds	r18, 0x06B5
    658c:	30 91 b6 06 	lds	r19, 0x06B6
    6590:	8b 81       	ldd	r24, Y+3	; 0x03
    6592:	9c 81       	ldd	r25, Y+4	; 0x04
    6594:	82 17       	cp	r24, r18
    6596:	93 07       	cpc	r25, r19
    6598:	30 f4       	brcc	.+12     	; 0x65a6 <prvAddCurrentTaskToDelayedList+0xe6>
				{
					xNextTaskUnblockTime = xTimeToWake;
    659a:	8b 81       	ldd	r24, Y+3	; 0x03
    659c:	9c 81       	ldd	r25, Y+4	; 0x04
    659e:	90 93 b6 06 	sts	0x06B6, r25
    65a2:	80 93 b5 06 	sts	0x06B5, r24

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    65a6:	27 96       	adiw	r28, 0x07	; 7
    65a8:	0f b6       	in	r0, 0x3f	; 63
    65aa:	f8 94       	cli
    65ac:	de bf       	out	0x3e, r29	; 62
    65ae:	0f be       	out	0x3f, r0	; 63
    65b0:	cd bf       	out	0x3d, r28	; 61
    65b2:	cf 91       	pop	r28
    65b4:	df 91       	pop	r29
    65b6:	08 95       	ret

000065b8 <__prologue_saves__>:
    65b8:	2f 92       	push	r2
    65ba:	3f 92       	push	r3
    65bc:	4f 92       	push	r4
    65be:	5f 92       	push	r5
    65c0:	6f 92       	push	r6
    65c2:	7f 92       	push	r7
    65c4:	8f 92       	push	r8
    65c6:	9f 92       	push	r9
    65c8:	af 92       	push	r10
    65ca:	bf 92       	push	r11
    65cc:	cf 92       	push	r12
    65ce:	df 92       	push	r13
    65d0:	ef 92       	push	r14
    65d2:	ff 92       	push	r15
    65d4:	0f 93       	push	r16
    65d6:	1f 93       	push	r17
    65d8:	cf 93       	push	r28
    65da:	df 93       	push	r29
    65dc:	cd b7       	in	r28, 0x3d	; 61
    65de:	de b7       	in	r29, 0x3e	; 62
    65e0:	ca 1b       	sub	r28, r26
    65e2:	db 0b       	sbc	r29, r27
    65e4:	0f b6       	in	r0, 0x3f	; 63
    65e6:	f8 94       	cli
    65e8:	de bf       	out	0x3e, r29	; 62
    65ea:	0f be       	out	0x3f, r0	; 63
    65ec:	cd bf       	out	0x3d, r28	; 61
    65ee:	09 94       	ijmp

000065f0 <__epilogue_restores__>:
    65f0:	2a 88       	ldd	r2, Y+18	; 0x12
    65f2:	39 88       	ldd	r3, Y+17	; 0x11
    65f4:	48 88       	ldd	r4, Y+16	; 0x10
    65f6:	5f 84       	ldd	r5, Y+15	; 0x0f
    65f8:	6e 84       	ldd	r6, Y+14	; 0x0e
    65fa:	7d 84       	ldd	r7, Y+13	; 0x0d
    65fc:	8c 84       	ldd	r8, Y+12	; 0x0c
    65fe:	9b 84       	ldd	r9, Y+11	; 0x0b
    6600:	aa 84       	ldd	r10, Y+10	; 0x0a
    6602:	b9 84       	ldd	r11, Y+9	; 0x09
    6604:	c8 84       	ldd	r12, Y+8	; 0x08
    6606:	df 80       	ldd	r13, Y+7	; 0x07
    6608:	ee 80       	ldd	r14, Y+6	; 0x06
    660a:	fd 80       	ldd	r15, Y+5	; 0x05
    660c:	0c 81       	ldd	r16, Y+4	; 0x04
    660e:	1b 81       	ldd	r17, Y+3	; 0x03
    6610:	aa 81       	ldd	r26, Y+2	; 0x02
    6612:	b9 81       	ldd	r27, Y+1	; 0x01
    6614:	ce 0f       	add	r28, r30
    6616:	d1 1d       	adc	r29, r1
    6618:	0f b6       	in	r0, 0x3f	; 63
    661a:	f8 94       	cli
    661c:	de bf       	out	0x3e, r29	; 62
    661e:	0f be       	out	0x3f, r0	; 63
    6620:	cd bf       	out	0x3d, r28	; 61
    6622:	ed 01       	movw	r28, r26
    6624:	08 95       	ret

00006626 <memcpy>:
    6626:	fb 01       	movw	r30, r22
    6628:	dc 01       	movw	r26, r24
    662a:	02 c0       	rjmp	.+4      	; 0x6630 <memcpy+0xa>
    662c:	01 90       	ld	r0, Z+
    662e:	0d 92       	st	X+, r0
    6630:	41 50       	subi	r20, 0x01	; 1
    6632:	50 40       	sbci	r21, 0x00	; 0
    6634:	d8 f7       	brcc	.-10     	; 0x662c <memcpy+0x6>
    6636:	08 95       	ret

00006638 <memset>:
    6638:	dc 01       	movw	r26, r24
    663a:	01 c0       	rjmp	.+2      	; 0x663e <memset+0x6>
    663c:	6d 93       	st	X+, r22
    663e:	41 50       	subi	r20, 0x01	; 1
    6640:	50 40       	sbci	r21, 0x00	; 0
    6642:	e0 f7       	brcc	.-8      	; 0x663c <memset+0x4>
    6644:	08 95       	ret

00006646 <itoa>:
    6646:	fb 01       	movw	r30, r22
    6648:	9f 01       	movw	r18, r30
    664a:	e8 94       	clt
    664c:	42 30       	cpi	r20, 0x02	; 2
    664e:	c4 f0       	brlt	.+48     	; 0x6680 <itoa+0x3a>
    6650:	45 32       	cpi	r20, 0x25	; 37
    6652:	b4 f4       	brge	.+44     	; 0x6680 <itoa+0x3a>
    6654:	4a 30       	cpi	r20, 0x0A	; 10
    6656:	29 f4       	brne	.+10     	; 0x6662 <itoa+0x1c>
    6658:	97 fb       	bst	r25, 7
    665a:	1e f4       	brtc	.+6      	; 0x6662 <itoa+0x1c>
    665c:	90 95       	com	r25
    665e:	81 95       	neg	r24
    6660:	9f 4f       	sbci	r25, 0xFF	; 255
    6662:	64 2f       	mov	r22, r20
    6664:	77 27       	eor	r23, r23
    6666:	0e 94 54 33 	call	0x66a8	; 0x66a8 <__udivmodhi4>
    666a:	80 5d       	subi	r24, 0xD0	; 208
    666c:	8a 33       	cpi	r24, 0x3A	; 58
    666e:	0c f0       	brlt	.+2      	; 0x6672 <itoa+0x2c>
    6670:	89 5d       	subi	r24, 0xD9	; 217
    6672:	81 93       	st	Z+, r24
    6674:	cb 01       	movw	r24, r22
    6676:	00 97       	sbiw	r24, 0x00	; 0
    6678:	a1 f7       	brne	.-24     	; 0x6662 <itoa+0x1c>
    667a:	16 f4       	brtc	.+4      	; 0x6680 <itoa+0x3a>
    667c:	5d e2       	ldi	r21, 0x2D	; 45
    667e:	51 93       	st	Z+, r21
    6680:	10 82       	st	Z, r1
    6682:	c9 01       	movw	r24, r18
    6684:	0c 94 44 33 	jmp	0x6688	; 0x6688 <strrev>

00006688 <strrev>:
    6688:	dc 01       	movw	r26, r24
    668a:	fc 01       	movw	r30, r24
    668c:	67 2f       	mov	r22, r23
    668e:	71 91       	ld	r23, Z+
    6690:	77 23       	and	r23, r23
    6692:	e1 f7       	brne	.-8      	; 0x668c <strrev+0x4>
    6694:	32 97       	sbiw	r30, 0x02	; 2
    6696:	04 c0       	rjmp	.+8      	; 0x66a0 <strrev+0x18>
    6698:	7c 91       	ld	r23, X
    669a:	6d 93       	st	X+, r22
    669c:	70 83       	st	Z, r23
    669e:	62 91       	ld	r22, -Z
    66a0:	ae 17       	cp	r26, r30
    66a2:	bf 07       	cpc	r27, r31
    66a4:	c8 f3       	brcs	.-14     	; 0x6698 <strrev+0x10>
    66a6:	08 95       	ret

000066a8 <__udivmodhi4>:
    66a8:	aa 1b       	sub	r26, r26
    66aa:	bb 1b       	sub	r27, r27
    66ac:	51 e1       	ldi	r21, 0x11	; 17
    66ae:	07 c0       	rjmp	.+14     	; 0x66be <__udivmodhi4_ep>

000066b0 <__udivmodhi4_loop>:
    66b0:	aa 1f       	adc	r26, r26
    66b2:	bb 1f       	adc	r27, r27
    66b4:	a6 17       	cp	r26, r22
    66b6:	b7 07       	cpc	r27, r23
    66b8:	10 f0       	brcs	.+4      	; 0x66be <__udivmodhi4_ep>
    66ba:	a6 1b       	sub	r26, r22
    66bc:	b7 0b       	sbc	r27, r23

000066be <__udivmodhi4_ep>:
    66be:	88 1f       	adc	r24, r24
    66c0:	99 1f       	adc	r25, r25
    66c2:	5a 95       	dec	r21
    66c4:	a9 f7       	brne	.-22     	; 0x66b0 <__udivmodhi4_loop>
    66c6:	80 95       	com	r24
    66c8:	90 95       	com	r25
    66ca:	bc 01       	movw	r22, r24
    66cc:	cd 01       	movw	r24, r26
    66ce:	08 95       	ret

000066d0 <_exit>:
    66d0:	f8 94       	cli

000066d2 <__stop_program>:
    66d2:	ff cf       	rjmp	.-2      	; 0x66d2 <__stop_program>
